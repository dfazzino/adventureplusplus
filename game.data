actions = {}
actionQueue = {}


function initActions()

	local action = {}

	action.command = "start chat hi" 
	addAction(action) 
	 
end
	


function addActionToQueue(actions, waitAction) 

	tempAction = {}
	tempAction.actions = actions
	tempAction.waitaction = waitAction
	table.insert(actionQueue, tempAction)
	print("TESTTEST")
	
end	
	

function checkActionQueue(actionWords, cancelActions)
	for i, a in ipairs(actionQueue) do
			
	print(actionWords[1], actionWords[2], a.waitaction[1], a.waitaction[2])
		if a.waitaction == actionWords or (a.waitaction[1] == actionWords[1] and a.waitaction[2] == actionWords[2] and cancelActions == true) then
			if cancelActions ~= true then doAction(a.actions,nil, dt) else  print("CANCEL") end
			a.remove = true
			if cancelActions ~= true then break end
		end
	end
	i = 1
	while i <= #actionQueue do
		if actionQueue[i].remove == true then
			table.remove(actionQueue, i)
		else
			i=i+1
		end
	end

end	
	
	
function loadActions(line)

	thisActions = ""
	actionLines = line:split("=")
	line = actionLines[2]:strip()
	
	if line:includes("/") then
		barList = line:split("/")
	else
		barList = {}
		table.insert(barList, line)
	end
	for h, barLine in ipairs(barList) do 
		actionLines = barLine:split("then")
		for i, actionLine in ipairs(actionLines) do
			localLine = ""
			foundAction = false
			actionLine = actionLine:strip()
			for j, action in ipairs(actions) do
				if action.command == actionLine then
					if localLine == "" then
						localLine = action.id
					else
						localLine = localLine .. "," .. action.id
					end
					foundAction = true
					break
				end
			end
			if foundAction ~= true then
				local action = {}
				
				action.id = table.getn(actions) + 1
				action.command = actionLine
				table.insert(actions, action)
				if localLine == "" then
					localLine = action.id
				else
					localLine = localLine .. "," .. action.id
				end

			end
		end
		thisActions = thisActions .. localLine .. "|"
	end
	return string.sub(thisActions, 1, -2)
	
end


function addAction(action)
	table.insert(actions, action)
	--logFile:write("action " .. table.getn(actions) .." " .. action.command .. "\n")
	
end	
	
function doAction(strActions, barSplit, dt)

	actionList = strActions:split("then")
	for i, action in ipairs(actionList) do
		queueActions = {}
		if action:includes("/") then
			splitActions = action:split("/")
			tempActions = ""
			for i, sA in ipairs(splitActions) do
				if i ~= 1 then	
					tempActions = tempActions .. sA .. "/"
				end
			end
			
			action = trim(splitActions[1])

			queueActions.actions = tempActions
			
		end
		action = trim(action)
		if action ~= nil then
			local actionWords = action:split(" ") 
			verb = trim(actionWords[1])
			varName =  UserValues2(trim(actionWords[2]))
			value = trim(actionWords[3])
			if queueActions.actions ~= nil then 
				addActionToQueue(string.sub(queueActions.actions, 1, -2), actionWords)
			end
			
			if verb == "start" and varName == "chat" then
				if (currChatNode == nil ) then
					initChat(value)
					setupChat()
				end
			end
			if string.match(value, "pointingAt") == "pointingAt" then
				value = split(value, '|')
				value = getPointingAt(value[2])
			else
				value = SystemValues(value)
				value = UserValues2	(value)
			end
			if verb == "append" or verb == "set" or verb == "delete" then
				doCommand(verb, varName, value, actionWords)
			end
			if (verb == "move" or verb == "moveTo") and (varName ~= "" and varName ~= nil) then
				entityCommand(verb, varName, value, actionWords, dt)
			end
			if (verb == "create") then
				eventCreate(varName, value, actionWords)
			end	
			if (verb:includes("Inv")) then
				inventoryCommand(verb,varName,value, actionWords)
			end			
			
		end
		
	end
end


function doCommand(verb, varName, value, actionWords)

	for i, variable in ipairs(variables) do
		if variable.name == varName then
			if verb == "set" then variable.value = ""  end
			variable.value = variable.value .. value
			break
		end
	end	
	if verb == "delete" then

		if varName == "event" then
			for i, event in ipairs(events) do
				if event.name == value then
					table.remove(events, i)
					break
				end
			end
		end
	end	
	
	
end

function entityCommand(verb, varName, value, actionWords, dt)

	if  verb == "moveTo" then
		moveEntityTo(varName, value, actionWords)
	else if  verb == "move" then
		--local xy = split(entity.boxes[1].xy, ",")
		moveEntity(varName, value, actionWords, dt)
		end
	end

end


function inventoryCommand(verb,itemID,entity, actionWords)

	if verb == "addInv" then
		addInventory(itemID, entity)
	end
	if verb == "removeInv" then
		removeInventory(itemID, entity)
	end
	
end


function eventCreate(varName, value, actionWords)

	-- [1] time on the timer.
	-- [2] logic
	-- [3] true actions
	-- [4] false actions
	-- [5] delete/reset

	if varName == "timer" then
	
		local event = {}
			
		values = split(value, "|")
		event.id = 1
		event.onClick = false
		event.onKeyPress = false
		event.always = false
		event.time = values[1]
		event.timeStart = timer.getTime()
		if values[5] == "D" then event.delete = "true" end
		if values[5] == "R" then event.reset = "true" end
		event.logic = values[2]
		event.inventoryClick = false
		event.trueactions = values[3]
		event.falseactions = values[4]
		event.name = "testTimer"
		addEvent(event)
	end

end
ï»¿<?xml version="1.0" encoding="utf-8"?>
<XmlLuaSolutionDocument xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <Documents />
  <DocumentGroups />
  <DocumentFolders />
  <Id>261f0fff-a39f-4158-af8b-ab9a5191775a</Id>
</XmlLuaSolutionDocument>local anim8 = {
  _VERSION     = 'anim8 v2.1.0',
  _DESCRIPTION = 'An animation library for LÖVE',
  _URL         = 'https://github.com/kikito/anim8',
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2011 Enrique García Cota

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

local Grid = {}

local _frames = {}

local function assertPositiveInteger(value, name)
  if type(value) ~= 'number' then error(("%s should be a number, was %q"):format(name, tostring(value))) end
  if value < 1 then error(("%s should be a positive number, was %d"):format(name, value)) end
  if value ~= math.floor(value) then error(("%s should be an integer, was %d"):format(name, value)) end
end

local function createFrame(self, x, y)
  local fw, fh = self.frameWidth, self.frameHeight
  return love.graphics.newQuad(
    self.left + (x-1) * fw + x * self.border,
    self.top  + (y-1) * fh + y * self.border,
    fw,
    fh,
    self.imageWidth,
    self.imageHeight
  )
end

local function getGridKey(...)
  return table.concat( {...} ,'-' )
end

local function getOrCreateFrame(self, x, y)
  if x < 1 or x > self.width or y < 1 or y > self.height then
    error(("There is no frame for x=%d, y=%d"):format(x, y))
  end
  local key = self._key
  _frames[key]       = _frames[key]       or {}
  _frames[key][x]    = _frames[key][x]    or {}
  _frames[key][x][y] = _frames[key][x][y] or createFrame(self, x, y)
  return _frames[key][x][y]
end

local function parseInterval(str)
  if type(str) == "number" then return str,str,1 end
  str = str:gsub('%s', '') -- remove spaces
  local min, max = str:match("^(%d+)-(%d+)$")
  assert(min and max, ("Could not parse interval from %q"):format(str))
  min, max = tonumber(min), tonumber(max)
  local step = min <= max and 1 or -1
  return min, max, step
end

function Grid:getFrames(...)
  local result, args = {}, {...}
  local minx, maxx, stepx, miny, maxy, stepy

  for i=1, #args, 2 do
    minx, maxx, stepx = parseInterval(args[i])
    miny, maxy, stepy = parseInterval(args[i+1])
    for y = miny, maxy, stepy do
      for x = minx, maxx, stepx do
        result[#result+1] = getOrCreateFrame(self,x,y)
      end
    end
  end

  return result
end

local Gridmt = {
  __index = Grid,
  __call  = Grid.getFrames
}

local function newGrid(frameWidth, frameHeight, imageWidth, imageHeight, left, top, border)
  assertPositiveInteger(frameWidth,  "frameWidth")
  assertPositiveInteger(frameHeight, "frameHeight")
  assertPositiveInteger(imageWidth,  "imageWidth")
  assertPositiveInteger(imageHeight, "imageHeight")

  left   = left   or 0
  top    = top    or 0
  border = border or 0

  local key  = getGridKey(frameWidth, frameHeight, imageWidth, imageHeight, left, top, border)

  local grid = setmetatable(
    { frameWidth  = frameWidth,
      frameHeight = frameHeight,
      imageWidth  = imageWidth,
      imageHeight = imageHeight,
      left        = left,
      top         = top,
      border      = border,
      width       = math.floor(imageWidth/frameWidth),
      height      = math.floor(imageHeight/frameHeight),
      _key        = key
    },
    Gridmt
  )
  return grid
end

-----------------------------------------------------------

local Animation = {}

local function cloneArray(arr)
  local result = {}
  for i=1,#arr do result[i] = arr[i] end
  return result
end

local function parseDurations(durations, frameCount)
  local result = {}
  if type(durations) == 'number' then
    for i=1,frameCount do result[i] = durations end
  else
    local min, max, step
    for key,duration in pairs(durations) do
      assert(type(duration) == 'number', "The value [" .. tostring(duration) .. "] should be a number")
      min, max, step = parseInterval(key)
      for i = min,max,step do result[i] = duration end
    end
  end

  if #result < frameCount then
    error("The durations table has length of " .. tostring(#result) .. ", but it should be >= " .. tostring(frameCount))
  end

  return result
end

local function parseIntervals(durations)
  local result, time = {0},0
  for i=1,#durations do
    time = time + durations[i]
    result[i+1] = time
  end
  return result, time
end

local Animationmt = { __index = Animation }
local nop = function() end

local function newAnimation(frames, durations, onLoop)
  local td = type(durations);
  if (td ~= 'number' or durations <= 0) and td ~= 'table' then
    error("durations must be a positive number. Was " .. tostring(durations) )
  end
  onLoop = onLoop or nop
  durations = parseDurations(durations, #frames)
  local intervals, totalDuration = parseIntervals(durations)
  return setmetatable({
      frames         = cloneArray(frames),
      durations      = durations,
      intervals      = intervals,
      totalDuration  = totalDuration,
      onLoop         = onLoop,
      timer          = 0,
      position       = 1,
      status         = "playing",
      flippedH       = false,
      flippedV       = false
    },
    Animationmt
  )
end

function Animation:clone()
  local newAnim = newAnimation(self.frames, self.durations, self.onLoop)
  newAnim.flippedH, newAnim.flippedV = self.flippedH, self.flippedV
  return newAnim
end

function Animation:flipH()
  self.flippedH = not self.flippedH
  return self
end

function Animation:flipV()
  self.flippedV = not self.flippedV
  return self
end

local function seekFrameIndex(intervals, timer)
  local high, low, i = #intervals-1, 1, 1

  while(low <= high) do
    i = math.floor((low + high) / 2)
    if     timer >  intervals[i+1] then low  = i + 1
    elseif timer <= intervals[i]   then high = i - 1
    else
      return i
    end
  end

  return i
end

function Animation:update(dt)
  if self.status ~= "playing" then return end

  self.timer = self.timer + dt
  local loops = math.floor(self.timer / self.totalDuration)
  if loops ~= 0 then
    self.timer = self.timer - self.totalDuration * loops
    local f = type(self.onLoop) == 'function' and self.onLoop or self[self.onLoop]
    f(self, loops)
  end

  self.position = seekFrameIndex(self.intervals, self.timer)
end

function Animation:pause()
  self.status = "paused"
end

function Animation:gotoFrame(position)
  self.position = position
  self.timer = self.intervals[self.position]
end

function Animation:pauseAtEnd()
  self.position = #self.frames
  self.timer = self.totalDuration
  self:pause()
end

function Animation:pauseAtStart()
  self.position = 1
  self.timer = 0
  self:pause()
end

function Animation:resume()
  self.status = "playing"
end

function Animation:draw(image, x, y, r, sx, sy, ox, oy, ...)
  local frame = self.frames[self.position]
  if self.flippedH or self.flippedV then
    r,sx,sy,ox,oy = r or 0, sx or 1, sy or 1, ox or 0, oy or 0
    local _,_,w,h = frame:getViewport()

    if self.flippedH then
      sx = sx * -1
      ox = w - ox
    end
    if self.flippedV then
      sy = sy * -1
      oy = h - oy
    end
  end
  love.graphics.draw(image, frame, x, y, r, sx, sy, ox, oy, ...)
end

-----------------------------------------------------------

anim8.newGrid       = newGrid
anim8.newAnimation  = newAnimation

return anim8ï»¿<?xml version="1.0" encoding="utf-8"?>
<XmlLuaProjectDocument xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <Documents>
    <DocumentRef FileName=".\actions (2).lua" />
    <DocumentRef FileName=".\actions.lua" />
    <DocumentRef FileName=".\anim8 (2).lua" />
    <DocumentRef FileName=".\anim8.lua" />
    <DocumentRef FileName=".\art (2).lua" />
    <DocumentRef FileName=".\art.lua" />
    <DocumentRef FileName=".\buttons (2).lua" />
    <DocumentRef FileName=".\buttons.lua" />
    <DocumentRef FileName=".\chats (2).lua" />
    <DocumentRef FileName=".\chats.lua" />
    <DocumentRef FileName=".\conf (2).lua" />
    <DocumentRef FileName=".\conf.lua" />
    <DocumentRef FileName=".\entities (2).lua" />
    <DocumentRef FileName=".\entities (Dave-HP's conflicted copy 2017-04-05) (2).lua" />
    <DocumentRef FileName=".\entities (Dave-HP's conflicted copy 2017-04-05).lua" />
    <DocumentRef FileName=".\entities.lua" />
    <DocumentRef FileName=".\events (2).lua" />
    <DocumentRef FileName=".\events.lua" />
    <DocumentRef FileName=".\fileutility (2).lua" />
    <DocumentRef FileName=".\fileutility.lua" />
    <DocumentRef FileName=".\flux (2).lua" />
    <DocumentRef FileName=".\flux.lua" />
    <DocumentRef FileName=".\logic (2).lua" />
    <DocumentRef FileName=".\logic.lua" />
    <DocumentRef FileName=".\lovebird (2).lua" />
    <DocumentRef FileName=".\lovebird.lua" />
    <DocumentRef FileName=".\main (2).lua" />
    <DocumentRef FileName=".\main.lua" />
    <DocumentRef FileName=".\playeractions.lua" />
    <DocumentRef FileName=".\spec.lua" />
    <DocumentRef FileName=".\strong.lua" />
    <DocumentRef FileName=".\ui.lua" />
    <DocumentRef FileName=".\utility (2).lua" />
    <DocumentRef FileName=".\utility.lua" />
    <DocumentRef FileName=".\variables (2).lua" />
    <DocumentRef FileName=".\variables.lua" />
  </Documents>
  <DocumentGroups />
  <DocumentFolders />
  <ProjectProperties>
    <ExternalProgram />
    <CmdLineArgs />
    <StartupFileName />
    <WorkingDir />
    <UseRemoteMachine>false</UseRemoteMachine>
    <RemoteMachineName />
    <BuildOutputDir />
    <PreBuildEventCmdLine />
    <PostBuildEventCmdLine />
  </ProjectProperties>
</XmlLuaProjectDocument>

function initDraw()

	animateload()

end

function animateload()
	image30 = love.graphics.newImage('SNES - Super Mario World - Mario.png')
	g = anim8.newGrid(27,27, image30:getWidth(), image30:getHeight())
	testdraw = anim8.newAnimation(g('2-7',4), 0.10)
end


function updateAnimate(dt)
	for i, entity in ipairs(entities) do
		if entity.animate ~= nil then
			entity.animate:update(dt)
		end
	end

end

function drawEntities()
	
	
	-- do we need to sort for z?
	local currentZ = 0
	for i, entity in ipairs(entities) do
		entity.drawn = false
	end
	
	repeat
		local lowestNextZ = 99999
		for i, entity in ipairs(entities) do
			if entity.drawn == false and #entity.boxes > 0 and entity.visible ~= false then
				xy = split(entity.boxes[1].xy, ",")
				x = tonumber(xy[2])
				if entity.zCalc == true then entity.z = x  end
				if entity.z == currentZ  or entity.z == nil then

					if entity.drawType == "lovedraw" then drawASquare(entity) end
					if entity.drawType == "anim8" then drawAnimation(entity) end	
					entity.drawn = true
				else
					if entity.z < lowestNextZ then
						lowestNextZ = entity.z

					end
				end
			end
		end
		if lowestNextZ == currentZ then break else currentZ = lowestNextZ 	end
	until true ==	 false	

end

function drawASquare(thisEntity)

	for i, box in ipairs(thisEntity.boxes) do
		if box.color ~= nil then 
			rgb = box.color:split(",")
			love.graphics.setColor(rgb[1] or 255,rgb[2] or 255 ,rgb[3] or 255,rgb[4] or 255 )			
		end

		xy = {}
		size = {}
		local xy = split(box.xy, ",")
		box = split(box.box, ",")
		if getPointingAt("action") == thisEntity.action and thisEntity.action ~= nil then 
			love.graphics.setColor(255,0, 0, 255)
		end
		draw.rectangle("fill", tonumber(xy[1]), tonumber(xy[2]), tonumber(box[1]), tonumber(box[2]))
		love.graphics.setColor(0,0, 0, 255 )
		draw.rectangle("line", tonumber(xy[1]), tonumber(xy[2]), tonumber(box[1]), tonumber(box[2]))
		love.graphics.setColor(255,255, 255, 255 )
		if thisEntity.text ~= nil then
			love.graphics.setColor(0,0, 0, 255 )
			love.graphics.print(thisEntity.text, xy[1] + 5, xy[2] + 5)
			love.graphics.setColor(255,255, 255, 255)
		end

	end
end


function drawAnimation (entity)

	xy = split(entity.boxes[1].xy, ",")
	entity.animate:draw(image30, tonumber(xy[1]), tonumber(xy[2]), nil, 1,1)
	
endPNG

   IHDR  ¼  ¼   ºlC   tIMEà	%¿7Q   tEXtSoftware GLDPNG ver 3.4q¤á   tpNGGLD3    J)   gAMA  ±üa   bKGD ÿ ÿ ÿ ½§  HðIDATxíÝ?¨-×~'xùaèÖáFj48¸zpÑCãFÔQ(awt@-Ü3p¡¡;046\p :4bOpÃÃ¡ÏÐ300ÆÉ èöÜu¤u´ÎºUµk×®µ×úløpÏ½×]¿µêÏ·jWíóÖétz  FU½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ´ì³O>ýàÝGj÷éÈFQê ^itúÝWÏOßóå#µûd>úQêe¹`|Eeë;óøuí~y>ò¹èu>F©cå
ñit øòåËS*Ôþ­Ý¯-ó1BÀçc:FY® _FGéY«XÇÝçÝÕÏG¯kn.Ôa¹svop 8õvm¨£v¿¶ÎGï+PGo¡RÇ(Ë Ç°{£Å¹Zj÷éÚzX£ÌÇ(u´\0¾"°CWG{ÔÑQê `|EeGxwwwº÷º{¯¿®Ý§£ÎÇsÑé|RÇ}-,W Ãî²C¿¿.ñÇZ^½zuzúôiu05ds¡jéx¹à8vopn§^»ÐKäa·×:Òùè5`ÅñsÏ:ê.S=/W Ë®å!±× o¬!|Ýcs¡½§:B¿ã¨£¾; Ç±kcaî{ià;òëÈç£·`CbuÔûëH×ê àXvm,X=ÅXËu|Õ×Ç«åóÑ[0%(RÇé$ðÐ§])ð¦×ñÆsÒàÒ#ÞxãTí>\Çé$ðÐ§ÝÌÏöz÷vLz½9¼÷  £`²&(öPÏ(uDéµá/ =Ø½ÁGgF_ÝâutHRSs¿ïásSãÙÎüÚðÞæc:¢PÇÃ_Yë¸ a÷GÚ¡xóKLz¬#Å«Qêæ«¢ 8Ý)(RGïWí¥ a÷G	øöéÞ¹¾ß×îùøiNzQêxèÉî<yrÍëÚ};â|¼÷Þ{§ÿüçô6#Õ1ÊrÀ1ìÞà(Aq©j«£v¿¶ÔbQí~µQ; Ç°{S+ü,ýyí¢×ê^[í>n^ú>WK´Ú};ZS·§þp,»7vyPÌÓCàZ{sµûu­ü¬h¯a«×:âz¥!¸vß  ·{kbíÂ£©@~i[ªgJ'sß÷¨× 8Rù2$ðÐªÝ<bàm­¦ÜTÀm¹¿kk_÷²z®cjzhÑîövçú´µ-ÖÌÑmµ¿kk
ÿö®z¯c.ôÖî ¤vo°ÇÀûuí5¹­Ö6×·û»¤ç³¢£Õ!ðÐ]ë5ìîiîrYCïgE{®#ýD©w] Z´kcçTËap/-×8Bàá¬èHuäÔP»? 0e·Ö§Ãà¼í¥! g·ìøÚ5umr¯óÅ F©£×åcÙ­!;¾v¬ùËv½Î×(Aq:z] 8Ý²ãëK¯óÕs8±^# e·FÙE¯óÕk¿G­Cà »54Êü(Ì{°Ðê ú%ðÐê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  4úéïr}òìT»ØK>ÏÕñý7_Ú} `YFcLÝ}õüT»Øµýß>OÕ2õ\  Úô³·<ÿÝ¿ùßîå_ÿ£ùï~íÿÙo×ìÇGý/þÙ?>áhüúåË§ÚéþW¯^=êc8ÃúZâ×ñ÷ß~ûmó5 ]Fc0¼{ñ80¶~	@xÓ×~?Rà×&Gµû °§">\·ûâyw×ñÞÝÝ=ô1½7­%Öä^¥aWð FS¬áýk?;=Ý`ê,okIëHÃqÏb°ÿ/ 0bÇÀCT/7ÈÏòi-SÏëY¼!äë­{¯%ÎX Åað^xãÏj}N8ËûÐÿ:ÂóF¸7½N9½^9ßÚ}»K5  H£!Þ§×ÿðøôéÓà^»ðsB¿¹:b(®ÝÏk¥¤7öð©ç¸T vo0ÁbhLbxN/gFêè=ìæg¯c01ðx© °ÞîÆ ¸x{út¥:z_®q;¹dãë¯¿îº¾`äK5 ËìÚXdcP:+ÚËÞsuôèkÓÀûc]£ÞQ/Õ  .³kcoÛ¦ÂîTM=Þ#\ª \f×ÆÒ¿¦v.(ÐÛÃ__%ð»!ä=Â#\ª \n×Æ¦ïÜYÄüù­ZSGÒO×$§õ@_»×ÖwK5 Ëkx 8JùÇ©¥¡7Áïhj¬© X¯XÃ£ÅQêHû~Æp½ÞÑ.ÕHJjªÝO èI±ãlè=(RÇ½óFh!°×°t©Æ¹ð/Ó!¾v ÅþüÃ·O!dáëø}íÕñ¸ÚýºÖ(j¤uÄ@;v>SØÑ Õ5ÆÚ«ãééÉ'j÷ëZ£\ªö?ÊCoþ©=Üô	 -(ÖpC¸ê%|¨£Kj¤µ×îç:ò°kyt¦7	¼ið­Ý hY±ó3½,u´-½L£çK5ÒbØMoxÎRàz`^±çÞúï-d©£m!Ü~üñÇ.Õè±¦XGÜãµâé_0
¼ÎòÀ²bÏÞÂ:ÚÃnï×X/Õ¯K_ÏÝO?x·»àV5<JÀRGÛ={vÊõXÓRñ¶¹ÐÂ®À ó5<JÀRGÛB0¡¦suÄÐûð½° «kx)tôHÔÑ¶£Þ ½ál¯° ëiô\àè%¨£}G
¼ÁÃºv£ ¬V¤ÑQ:Úw´À \®H££,u´o 8J Ð¢"°ÔÑ¾Qâ(u @4>üÿß·Bmp%¥ hUFG	XêhßÔÑR ´¨z`­©³ =ÅQê ^Tï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÅþìg§O?x÷ÚÅ^SK^Oí>©e¬Z r5|÷ÕóÓ÷ß|ùHíb¯©%¯§v®­%­§vÔ T¬áBâY·Dz>U^Oí~m­%¯§vÔ T¬á/_¢Hâ×µ¾¶Tí~mâuV PNFãÛË1Ü½xÞu «§v¿¶HßþOë©Ý¯£× S¤Ñüz×Bz¾¾rªø»oïîN©Ú}]SKZO¨e®Ú}½¶Tõ  ekx´ÖÖÖÒzX¼ä&¯j «XÃ£Þ»×ïÞÒÐbP|õêÕiªk	/LÕÓc- @YEMCÈ,hôª3Z¯'Ô²¦ûçÌÇVÂb»×Ö Ãî~ûí·?Ü<ôcØxúôé£ ×z@BÓpj	ÿN=7¯§pÅÒZfëÎbkµ¤sZ[ p,»78cØA8>7ãÚ°$ÞùÏ$ÆZÎ½®µk=Ö²æu-^Çç%­ç×·V PÖîNÞôìg¹­Ý`*$Æp5uÖ°åO8HCâÃAÈ3­×ò¨gqE=w}ëÒÛÏ-+oí~/Õ²æF¯ëHkyTÀ Ì(Òh"s×ïöâád>þþáluã1­%¼¿õÏ?:õp¦}®´^k Ê+Òh<+:{±x{
»i-ià][¬m*ð
» À"x{¹$cª4ðÖîÓµµ¤õÔî Ð®"¾q­h§ëÜ%=x£*Ò¨ÀÛ 8ª"NÄCÉ(uÄZòzj÷éÚZ^ `"~þáÛ§/>zç^ø:~_»Ø£Ökýï¹´´Ú} ÚU¤Ñø¹µ¹ÚÅµ¹Zj÷I- À-i4#O<é2RG^KÏuV P^FcIõJF©#¥Ñj Ê+ÒèÜÛÌ½Qê«¥Ç:¦jéµ à64:@z&£Ô1×çëêw¯u  ·Q¤ÑQâ(uÌõ¹Ç:¦úÝk ÀmìÞà¹ðÑK8¥s}í©¥þöV p;»78JP¥s}í©¥þöV p;»6¶&tôLF©cM?{©ã\_{ª ¸­]%(RÇ~öRÇ¹¾öT p[»66JPTG{F
î ÀmíÚØ(Kíx­vml¥¶R PGõÀ9Â, pê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z(ï³O>ýàÝGj÷	 àV5<RÈ
µäõÔîÓ%î¾z~úÿìßûþ/¾®Ý¯­s1Êr ÜF±CÈ
á*U»ØkjÉë©Ý§#ÏÅ(µï pÅÁ$îÄC(éyCV^Oí~­õòåËSú¿®Ý¯­s1Úr5Bxkx¤ÖªÝ¯5b}¾{ñ¼«þ/ÍEïËÕHá ZV¤ÑÑBÖ\=µûµF~1ô½×3£-W#w hYFG
YsõÔîÓÖþõ¯ýì^ó1Òr5Zxkx¤ëG¨%ÞxÞW»OG©:zï ÐºbLîîN÷zþ¤?þ¬vß.®eåj´Z  eEXészØÁ¿zõê!Ój=¡o÷o¿þ7ÔóôéÓ>Ç×îãÑ«z^ ¸ÝüöÛogVNzØÁÇPêµ§Ûb=qòÒ¹óU»k´\Å¹9Þ}ìÞàTH;£ØzØ7Å3½±Úýºd.bsw.À·f¤åê\xïí] hÝîNtGÃHë¡$uÄ³ºyàmýÆ¯4ÈÆù:+ÚÃ<[®ÂûÒHëË ´ªH£çÎLõrV1á$?3Úzø-ðZ®Îw `_E]
X=yøÔ,hÅß·Ó un>B=®Q«Àå
 p;EgEçb/oËa7
¼KóÑCàe¹Jçdð ­+Òè(Ád.ðöòÖyZÇ¹ÀÛQ«ÑjÖit¤µtIC/Fêµ¼ pE%x§>æªv¿¶Ô1Âr5Z- Ðº"°F¨ãóß>}ñÑ;÷Â×ñûÚý:ê|ÄZ^ ¸"°F©#~¬Z®v¿:ÁHá ZW¤ÑQÖ¨u<yòd:z`¤ð ­+Òè¨«ç:BßS½Ö1Â|LÕÒsxÖit¤5JSýî­Qæ#Â; ´®H£#¬Qê¸äç­e>b§Â{µ @ë4:RÀRG;F©c´Z  uEeg®¶RÇhµ @ëvoðÜ»ú(uëk/ue>z« z°{£ìÌÕÑQê­ èÁ®­ÙQ÷°3¥5ýì¡#ÍGOµ @/vmlù(u¬égui>zª z±kc£ìÌG©cM?{¨ãHóÑS- Ð]eg>JAø|×k~ßæc¤Z  »66ÊÎ|:·-#Õ ½¨Þ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   J*Öðg<;~ðîÚÅY>æ 8bß}õüôý7_>R»Ø-F	î#Íà \¢XÃ1`ÅP¿®]ðÖ:z¡|.Ì pÅ~ùòå)Iø·vÁ%¸OÍE¯ó1Bp n§H£éÙ·¬î^<ï2`Üçæ¢·:òùè9¸ ·S¤Ñ©·CÈª]ì¥F	îù|z¼`¤à ÜN±G¸Örà>ê|ôÜÛ*ÖðKí¥ àv4zwwwzð: <xý}ø}OAeµ4Q/µ0 ÀmiôÛo¿½T¯^½º÷ôéÓ ~ßKP!¸¹¸¿ÞõÇùHç"½=Ô2Rp n§H£iØMCVzsQbµ?gàÇ}ª{; p[E
¼ii9X«£·à>x§æ¢Ç:zî ÀíiôÑ¥ ?!+ÚE_RGïÁ}i.âszQ; p{EÁ$ü2Üã|Ì]ÐQ; p{E+«V¬càç#µûµu>z_® Û*Òh{&#÷ïÔ\ôX p[E)ðª££Ô ÜVFG	&êhË(u  ·U¤Ñø1Q½Qù  ¬H£øöéÞ¹¾ß×.öR£Eó YFó7óáf¯Tíb/5JPó EFóÀûäÉ.Ö(A1ï¿ù  ¤H£y¸%`õ^GÞëè}> Û*Öp%álï{ï½wª]è55ôÜóZÒ¹©Ý¯-5ôÜÛ*þ@Òkàý5=¬ôv£Úý:ê|  ·Qü?è=ðÆb¿õÏ?ê¶¹k^{
½yÿ{í Àmm<Þo¬%è=ðNý¼§ÀØ{` n¯XÃ#Ý ªßBï=,ØÛ+ÒèHa7^+:U_o¦.¨Ý§kúßs- Àíi4Ü=þí=ðÎõÀÛ[@<7æ½Õ ÜNFG¼K}!ðÆ9êÁñx9ExÛ"ð GT´ñïR ì),¥ß½Ö W´ñø×°j¹wß{­«ç~Z P^õ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T¤ÑÏ>yvúôw©]è àÈ4z÷ÕóÓ÷ß|ùHíB·
=ÅQæ `"ÃaW=ÅÿÛÿê^¨#~]»_Kýy>  ¶(ÒèË/OQXñëÚÅ^ÇÜÛÞê  ØÓîÆ·Ìc¨º{ñ¼ÛÎöïîîÞèÛHó °Åîæ×Õã5£ù5¯=ÔñêÕ«7ú7Ê|  lU¤ÑnZç®­Úï³¼#Ì ÀVE!`³¥Suä²µÚÖåm­Ï  %íÞ`÷^¬IHlñ¬èl¯åa7¼S³¶Gã}f>  F·kc!HýÙýÙ} 
AðéÓ§!±å3±¿suä7{µxïÏN_X À¨vk(¨ «¥ÀÛbHÌk«#Èôwµû<'ôm:  ®µK#éÃ¹Ql1`å¡|MpïÁÚ:Z =ìÒH bÀ
?ËoËgó®uª£v?/57SµÖî+ @	»4²&ðÖ.tmñFµëH­¼-_W p]%ð¦biê  èÏ.¼í¥ ­vi$};<¼=,u  a·â%`© `»7V®zXê  Ãî~þáÛ§/>zç^ø:~_»Puô] ÀV»7øäÉû¤¢ø}íB÷ª#ªÝ¿£Í ÀVEMÃU¸j»Gáßø»Úý»¦Ú} ¸ü'=ÄsµôVOÚï|×<  w7ùOzsÞ{ï½SoµLØôRü,píþ ì¥ø§^Bbì÷T ·:æ à6ÞkØë{7­-Õ pEïýRxéÂT=½g¬Sµû PR±{>»
¡7ªÝ[Í ÀH4:JØ=
 YF{¿ qiTà  EÍÿÈAí" 8®âÿÀ @MÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T¬áÏ>yvúôw©]ì¶¶±køî«ç§ï¿ùòÚÅn1ÊÐ|´Å|´Å| ­XÃa7¸açÑëÆw¡ùhùhù [±_¾|yÂF7~]»àK²#4m1mùÛ¿ý[ó0°"Æ3q§q÷ây·;ùhËhóÂbj_×î×ù¡7ÌGüºvß¶ÌGïë@	EÍßV;ßZ%¶8! Æùè-ð8=¯ %kxkÉFÙö¶±kx:Ús:z©í(óÑQê Ø[FïîîN÷^o|¼þ>}N/ãv æ£-sóÎI/µÜ­ ãÛ½Áo¿ýöëÇ^ï0^½zuzúôéÃÎ¼·ú;BóÑ¥ù?O[»¿[æ£§åÊúp»7wÜaçÑó}¡ùhËÔ|¤}sÐò\+ëÀ1ìÞà(;ôQvæ£-iòê«ÝÏ-ó1Êr5J=® ¥iÔ½-æ£-±¹³p=%¸OÕÒc#­ %itz0ÂÐ|´gùPG[FY? J(Òè(;QêýÏkè±QæCm	uX? ÆV¤ÑQ6¼£íG¨Ã|´ÃzÞQê (¡H£#íÐGØ¶4êhÇ(ë@	Ei¢v¨£-êhË(u P¤Ñø18½oxGÙ¶¶ñiôóß>}ñÑ;÷Â×ñûÚÅ^j¡ùhùhù _Fã§äj{©Qvæ£-æ£-æ`|EÍwO<ér2ÊÐ|´Å|´Å| ¯H£q§êqÃ;ÒÐ|´Ã|´Å| ¯H£sgzÛø¶#4m0m1 ã+ÒèÜF¶·ïH;BóÑóÑó0¾"´QG;ÔÑu´e: J(Òè(^u´Em¡s}¡j (e÷GÙ¨£-êh:Ú2J ¥ìÞà(^u´EmQG[F© ][³QíaÃ«¶¨£-êhË(u ´kc£lxÕÑu´Em¥vml¯:Ú¢¶¨£-£ÔPÒ®²áUG[ÔÑu´e: JÚµ±Q6¼êh:Ú¢¶R@IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRF?ûäÙéÓÞ}¤v¡êPG+ÔÑu´E@	E½ûêùéûo¾|¤v¡êPG+ÔÑu´E@	?{«Ðã÷þèOïÅ¯ÿÕÏÿëS©ÿ«äCm=ÔÑÖCm=ÔÑÖc:<<xHÑ/_¾<Eá¨6~];Ý«C-PG[Fªãîîîôóÿæû:Â¿áûÚý:rSË³½PÇîÆ9®Üw/w¹QG[ÔÑu´åuôÏÍGz·{ùuKaEïe#¥v©£-êhK¬£÷À{®^â¹åª:`$Eåb}u´EmQG[PGOAq:`E=Â·'êh:Ú¢¶G©F±{aE¾÷zeÐáÊ­¶¨£-êhËèuÄZz©i:`$»6Vâxí«W¯NO>}´÷BmQG[ÔÑ#ÔÞCM£Ô£Ù­¡¸2a%ïuÃ«¶¨£-êh:Ú2J0¢ÝwÑö¾¢«£-êh:Ú¢¶Rh·âÊWôð}+z^GZ:Ô¡1ëe{¥u Óvkh}Ôº:Ô¡ù:FÙ^©CÀ´ÝeEq×Ðc¡êe>FZ?FÚ^©CÀ´ÝeEq>RÀ¡æcõc¤í:ÔLÛ­¡ø¡Ú½u´EmQG[ÔÑQêíÚXüè½¯èêh:Ú¢¶¨£-£Ô£Ùµ±ð×dÒÖ~äõïj«u¨CêhÓRµûvÄ:`4»7øùo¾øè{áëø}ø]OÛ]mQG[ÔÑ#ÔÑQêìÞ`¼>W»Pu¨£êh:Ú¢ ÝÌWð'Ot¹¢«£-êh:Ú¢¶Rd÷ãÊêqEWG[ÔÑu´Em¥ÉîN­Ô=®èêh:Ú¢¶¨£-£Ô#Ù½ÁQVtu´EmQG[ÔÑQêìÞà(+º:Ú¢¶¨£-êhË(uÀHvop]mQG[ÔÑu´e:`$»78Ê®¶¨£-êh:Ú2J0ÝeEWG[ÔÑu´Em¥Éî²¢«£-êh:Ú¢¶Rd÷GYÑÕÑu´EmQG[F©F²{£¬èêh:Ú¢¶¨£-£Ô#Ù½ÁQVtu´EmQG[ÔÑQêìÞ`øk~Ö:u´EmQG[ÔÑQêìÞà(+º:Ú¢¶¨£-êhË(uÀHªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤]¹ûêù©v!ê  `Ê.|ÿÍ§ôûÏ>yvúôw©]èê  à'W7pwwwzãg_=?ðÊ_»ðQë  à±«ñhùÙÑ<8¶`ª/_¢ÐçøuËu  ðØÕl	s¯«iª?iß{© Ç®n |ñ­ÿï^<ï"(ÎÕ:¦Îè¶V  ]Ý@øòë^çâ«W¯ÞøYM£Ô ÀcW7°åf¯ µ êHk¹ÿþÜMk¯ÓZ  <¶K#Å Å ëá7xtw"·X  ?Ù­¡4$ÆÐû -Äµu»  }Øµ±Õ~O>}áû<ø¶j:  Ø9ð!(P8k{Ä:  n÷çbíBZ ÀÑíÞ`!öCßG¨ àèvo0Þ4$öC¡Þë  8ºÝ)ð¦7¨õZ ÀÑíÞ`<3Ú{Px Æ°{£ÅQê  8ºÝ%(R ÀÑíÞ`ü½ÅQê  8ºÝüüÃ·O_|ôÎ½ðuü¾v¡G­ àèvo0~W®v¡G­ àèvop*$>yò¤»°8J  G·{i8Þ{ï½{=ÅQê  8ºÝa0Â¹ßÕ.øhu  Ýî.Áâ(u  ÝîÎÁÞBâ(u  ÝîG© àèvop 8J  G·{S°Ç8J  G·{£ÅQê  8ºÝ
á3lkzÔ:  n÷G	£Ô pt»78J(¥ £Û½ÁQâ(u  ]õ  @IÕ;   %Uï   T½  PRõ  @IÕ;  ´íîîîtNí>®ñéï?üßU»ê(SÇÏÞòðððððððXx¼÷Þ{gyóøøST»/»=j§{  m¿úÕ¯NçÔîãw_=?ßóå¬Ú}¬]Ç-çõóá¯Göò,çÇ¯ÿú¯ÿZP»{?^n[BéïýÑ¾õoÿý¼~=õh9ü]RGËÔQû´< Ð¶/iØÒ¿ûËß?Å·ÑÃváùw/ÿðïëï{¹¤áVu×[Î3¼KÎÞò­ÿüÿoÃ_r6öÉùê­ÿë?ÿ÷_Ã÷=>Ô±îñë»¶æááááááÑý#Ê ×ÙðÜüuÍ?þïþyòOÿÉý¿ÿè_þ»>ú?
Õqóy,9µOË íoc§±{éå¥ß
¿ä2ð¶x|Û<¾? ¼}ôð	ê¸NõÂ`4½ü!´¿×P®¹ç®-zçÚ^ú«©uÉG`m½^yËkJÖ±W[¬cÉMV$ 848ÖîËÚþ^p×Þ(¶GZÆS¨/«4`}ýõ×§ï¾ûî^|Î¹>Ü"ð¬cÏ~¶ZÇj+ ¨§À»GØMÏ
çí_ ¶ÝGoÿØ·<`å~ùË_þðÜ×¿?×Kêºäù·ªãÚ~¶\Çê+ $-Þ½Âî¹à»5D­Si*` õWüéiêmöpõãóâs¶ö©õ:úyõrU¹9ÕW8 Mgy÷»s¡·FàMCVü×ÂÅ²Ráç1T×Ð»¥êØ£®ëS}Þ¥hþlkèj¯DKÞ½Bï5×î>ô#þQ$d¥?+}ë<>/þÑÐ¶ôkê5ñuS¯_
%ê¸¶¦KæãVu,¹ùF F_Â0õq^kkþÚ^ozKÞ4dÅ×ð4¶Î ¦sõãëãÅ©°÷mk=suM½µC`©:.çÕËU¥:Î©¾¡ ]þr±¥Ï¼-zK\¿;Ww:N[Æv±ü¬áWÏ'o~ñ_<±5÷K5ÖÔõ,UÇîËUÃuTßP @Ïã¹³µkþ¸ÃÞ÷Va·tàMÃTzè¹Àß§á*T±½ïÚ:âõ­×Öñè±·õ:ªo(  gsá1ÿù\àzn©À{Ë°»Gà­cæmó<ð.¬xfqªÐÒ¶JÅ¥:Ò xmi=jÕ7 Ð»©p{. Î½¦Ôe·»±ßéÿ»ËX/«ôÌlYsoß?+TñgiàÝ;0«#ýkëÈ~Ä:ªo$ `kÎÖæâkçâÞ÷aw*Ìï2Îá*ýYúÿæyg§~¶ÿ_·¨ã\ß/©cîÿ:RÕ7 0kÎ Nµ³÷°¨xw­câ,_zhGyè
QéÛçñÌc~&2¼{Å5uç¥}ÞZGÉÐÛKÕ7 °ÆÜ'´òÇöºd`êLñµ5®í[xnË7^z.\Å:Ò·Âó 4wTY}yËþVu×Ô1wæõhuTß@ À5¡¶à{mØMëØ;Ì¯í[|~ë7øû¿þGái*ô¤×¦_Ï}ôUl#?³´½bé:òÿëÈuTÛ0 À9¤¡wËÞøÚüìêÞ~íÙÝ´?[ë(zó»üCÈJVþüô-ô4dM	mç¯ÍCÖßüùìÕqû:ªl à­Á¨Vèÿï¥7­ÍÂ¿»&ìF[ï×][×ÔÛÞKa'YSoÏµÃWVAs{] ÛÖqó sMØ­uoþÿ\sC7¸4ì®yÍ­o¬4hÅpM|³ÃU<s¹çõ¯ê¸mÅV| ÚÒò_S}=WÇÒÏæ¾¾e·Ý´­[_Ú?Kà=÷º=êIN¼îmôûºgÞ6¡k.`Å×n	uêh«âKWýÙªõ;Íù0æ#ÎÅ­Ï&^Ûßµu¤ó´ÔÎ-êËÿ¿=ïÞý¯x÷ª#^ËÿzW~mgþü©?z]Ì?MàÑÍ,uôUGÑÿ ·IXi_½z5»C¾þúëæë0m1ma>.	^­Þ¹~\:¥BãR¿Óÿ#ögKèí5ðÞjKUúÑXsëO~÷·Oç¼1VÙT{UÇmë(¶âO¹t¿eß.±´^¾|y¿Coy§n>Úb>Ú2Â|l9ËØBè=×ÖïÜòöqËìÑÿwÏñ;8~ÂÇ^óh³ùÿµôv»:Ú­£Ø¿e¥éa'7háìUÜaOíÌ£¥kXj2õûn>ÌG«uÔ¾Äaéÿ¾dnxc<×÷5uLµq«3¼ØïÚë8·¬øo~SýÕQdÅ²uÃÛÚN$îÌSùN=Ý§G%µûn>Ìù8Ö|\SGÍÐ./Ö>÷ýOdü·Ô1wø7íã%ã¾vÛs>òíÇ¹·µçBÕûï¿ÿï³gÏNyûiÀÊC:ú«£øF`ÍJÐÓNäÞycgÜïÄÓ3Yw¶´S7æÃ|?×ÖqëÀ8·\Ç[ÔqnìÖÔ_3µ,í'úrÍ²³öu{ÏC¾YznQi°¦Î(Æöó·ç÷ê¸]»zÎµÞVv"aÅyºC¿z+;uóa>ÌÇøó±G5ÏòÆ·öûuäÿ_ZÃ:òþ¥ËPÍ³íkõ©¯[Y¢üíò¥·ÐÆ>Û>µp:¶Õq³ÂFÙ|þáÛ§?þøa§¾ÿß3Zù¤´zË|ó1ö|\sf´Ò{àË@zÖz®S}[úÝ­mYÞ[YRSaê\ÀºÃÎ\ª£Ý:nVØ; ìÌ>}úð»°Cg²¦&$îÌ?ýàÝ&ê0æÃ|=½ÞXÃÖOÈç¡FàÍÿÿ)sËJí±ÏûÒò²¾ÖÖÕuls³ÂFØá\Ü¡Çvævêagnn>Ìù¸ï:¦Ânl§V×>§U­/ëk	m9dà=÷ûV¨üÎÁ îÐ¸Sø¾Á¹ù0æcüùXsÍhëa7Öqîøï\ØMÛª1ÖkÓª÷5Å¶6ð.=§ö¤¤ÎíÐt§Îfµ¶37æÃ|?kïÒsZ»ysLÝ06×Ö­ÇzíµÈµÇyÉh7\zÿ¬Ç ¨ËÜ¬°5+J+Òzvä÷Zµ¡qÌù0ÇkBX+awkKmÝª|,YKã=Eàm:¶¹YakWÖW¢µ;ôÖ¶¶ô>½½õ§Ü¢¥öJ÷w.ì
¼õ	m2ð°¢D#ìÐÍG[ÌG[z5lÐzÀº¦¹ÚnUó¥a·ùxÛ¢mnRÔ+JdÞóÑóQ×¹¼z	X{×Qó³GÑ¯½Ú0äMk#¬(AØq/}ìR/ÌG[ÌG[zs7qõ°öª#o£×:Z!ð¶EÛ)¢÷bÉÔ¬Ö¶¶0ç®­ ÕÑgÀÛulS¤ÞWhêlºù0æ£5K«vßÔÑoÑ(÷ý÷ß?½EulS½`  ]KÜËYê ¬hîg­SÇ6Õ ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z zóéï¢?üßT» ü¤z z#ðô¥z zs÷ÕóSôý7_NªÝG ~R½ ½xú²éEéÆ>Øûù -K·géeé×µûÀO.~A~Fã\ÍÏ½PkP¯ówùûâïîîN¿úÕ¯Nw/ÿðïëïk÷±e?àÖ~öÖÿã?ýáéÉ?ý'~vúïï-=?øþßÿïìó=<<<z|<ù/_½õþ§sÿuø7|ïááááÑÐcm2giÓ³µá,GtíóÛqêuò3¼÷ÛºÏï»ó,À­­~b`Óðº&ð{>p;ÇåÒK²ÒÀûp¹À»å¸µÕO;S¿»kîùµ#sÓÕú1ÊØ\àÖ.[Ëp+=9ÝHÅðw swêùñ5µ£rÓÕ²¹ Æ%¼§÷ë¯¿>}÷Ýw÷lßÎ³ü·¶éESÔ°ô¶³ ç¹kyÛxÍñZ6uêýÏ^ütpZ»µÌmßB¼©_þò?<×'ÒÌ²ü·¶éEsoó]xí~"ðn/w7]M[Ú¶ÅÀí_ýñ§o_z8>Oèµüm¸øqõ÷ý÷Ò}¼7"á¹óç0ù|;7ÇÕM×ÜX¯7¹éjÝr5wpßzA6_½©³»¯þÍ_[»¶Ú,@M¿ ÿ«ii±ü:¬x&$Þ|ÞåqàÖÀ{ù¹éjyÌæïC`ËÎÞÆñÌ/e_y[gùZrÑCxÍoVË¯ÁÊ¯ÃÊBoºó¨= ­p×ò¶ñ«£ï4ÝtuÝr5w¹VpBn"é=ò%\? 5=y)ìN]uîùµo»¯¯±:ràuÓÕöq3õ)3qñ_<òÆ[õÛæYþ]ôä<¼NnÔÀ{îùµo»·×Ã2öâñrV»5Ì½7]MÛÔ|¼V7¼¹|¶{GGËÐ¢ÕO#o.Ðæg6¦_»ø¸kù¼ü-å¹±:òx-]^ê¦«Çc6w Þ¥ÐoºÍc®×µkµüGµêIé¥°;uÖÜ¯vá-
pïº^¦Æê¨ãÇl.p<¬nº\Æ¦þMÙ\èá6Þ4ä¦g1|-@«Î>!Kojã}î:¬ð}ÜiØp½i.ðNYÛ^º#©]ßÖ1Üqf× ^3N#Z:[!wÓÕOËÙ\0ÍÏB.gxó³GzËò´êìÞ¸jbg°æ:¬ð¼ÚÅ¶jÍ]ËAüH·øÆy;qG¾ÍÚcàÛaNÝô2ùÎÂAoð[Oóå"={yô®Ò1
ëÔÜ6.5õó©Ëbà:{<âxZþ}ÂÔFzn'7wVíb[ïÖÜµÝôùi±­TíZ/Ù·C¨¥3¼é»µë©±<¥cæ¦«eé¸Äu+ßô =ßÎåË^>vñµùö2|>q´ñ´ü­;û¹ 6bk®Ã²±Z?¦éN"ÿãôò×ÄÏ5íö|wéûñÉÂnþüôíÑ#Ýá½ô6²®¥ëÙÜYÈüle´ñëÔò3Ã¡ý<$¸M´ü=8û¹Ü5×a¹¤áü¦;<ÈåþðýÔ_®KwÞ£ÞG!ùX£ÔÃr¼³pÐ;uV-ý×MWçM$ÎaLîTÍåV}Àkùzqö	s!,=«{î:,¨L;º9+ÝèÇÀ>7?kÒ[à:SÜÜÞG¸Ë;SgÝtµl*M­éØÌm§Ú5ìZþ}ÂÜgÍÛRéN¢v¡­;47¾éYÛôg1ìÎídãºv½[Ç%´Sg½ßxgá«®!×Úu77]m0NéÇ©³¿é:;w©Ä(cgùzqö	yhH7BS¿Ëß²Qz,ß,=
³ùïòkú¼Úµn¼¦¹^Âsòwòñ;BàuÓÕþã¹Tç.c¿:	þ;ÚYþ^}B¾±Ï¼óßO]U»ÈLýÈÏZ¬ùþÜÐ^.eÚù­	¼iùÎ2'#ïÝtUfL®5ÍÏäÎ­ùYÞÚuYþ#[õ¤k®Ãª]`kò°ÞÔqng¿N¯	ÌÏF¥ÿÖ®uíXLÝ¸³\ºf2=Ó×nxqÓÕþã9÷ÉüîoäËéÈa×òôdÕ®¹«v­
y¹©·´ñz¶ì\é8ÌzW!_öÒ ÿµkß®Ê,S×ÂçÑÌq9³ü=»èÉ[¯Ãâ±s7?µ©¾éå¬ÒÔÙ×©À¾t5õ®B¾S=JèuÓÕmÌÜgÏÍªÝgËpt=9ßP-]å(|ÞÔÛxS!xj§0JØú¨±´üüySï*Ä³ISwxOÞÚcPj\ÝtUVtßÿýûP{ôÐkùZvÑ§Îç6`=®ò·÷æ.cº¦wàßÝ/?ùr7u5õ®Bz°ÛQÆÜtUÞ³¼G½? %¿`î-©4h(ö¿Å·tö#íÌ¯ëyóbúqFS7½yØ
³S¡7þ)æQ7]7xÃï^ËÐM/:wÔec8èò³j÷·KÎXO]»æøót§þsí1(%Å®æÎ´ó¦©À5ð? 5^´t&ÒåëÇp)ôáàáÒK4¶¼³Ãn<<Âå ×X8j÷±7éåñgGºkÇÊòÜÚ¦-]ÃGíÂZÜ£<äo_.ÝºÆ/»sc5ÚõÏ×
ùMWµûØôÚÝø3aw~¬,@^tî:¬ va­:³{Äü/5å×Üæc6õÎÌÞÚµ×CEQúóÚ}ìI~³ZøYpÂÛôxYþ6½ÈÛR×û_>ý­S°tÐ~_»¥M}ÑÜMeKwwOä×öýìn¯§ih³î^>ùÙÜâj÷¯U? M/x¯·fþó?sgv§Bé%ï,¤¡xê®ñÚu·²ì¥ß;+yùÎ]º ô;ËpK^4ÐÒ·¦jÖ:?XúÌÎkÆ,ÍyèxaÛcnLxÇÎòÜÚ¦Í]Þ|P»°Ö-¶xàP»·__»t©ÁÚÀ]`??SãZ»=pFòº±³ü·¶ùÒ¯ÕÜCí>ÞB~Ú¹1;÷ÎBz§ÎòÖ®¹6ãzî·³ü5l~¡ë°®7àìHçÇkî aî²©Üj×Q[§?þø~þe.YØÎòÔ°ùÎð^o)ð:hX?^Kg.9|SáBà¸Ð»å¨aó½-u=gx¯³¹q~üë¼³üµl~¡Ðq½|¼ÂÇÃËÆÍò·mìB°HÇiêg°7ËPË¦ÍGéÛÇ1|/ðn»¹q~Ü·bùjÙô"oK]ÏAÃ>ãgùÛ6n5XþZ6½Hà½1¼~ìÂåwz§?c~ìj°üµlzÑ\(Ö.Ã©À+´­;
»ÑJàà,@-^ä(ý:çßºñsýîåæOà,@-^$ð^Çøí?~Æn,@-^$°]Çøí?~Æî:5YþÒ6½H`»ñ»Nú'~ lzQ.æBàaün5K? ¨Þ  (éªúÁ»§àç7fÕ.×ß¥u¸v`W½Xà½1Ügü6cWkü¬»ÆhßÏÞºâñþçÿþÞÿú?ý³<<<Ú|ÄõwiöðððððâqMZ¾ûêù)øþ/gÕNô­3ûßÒÖîc«Ý>ãgÝ5~@û®:Ã¿÷GúÖ¿ý÷ÿñ^úµGë°ÇÐkÒòßýåï?!º»»;ýêW¿:Ý½xþÃ¿¯¿w~^¿ôZ¶ôkc¸nüÆ°v[õhýYk÷±eÖ]ãôãª§;Ì°qºÿúÅã·©jØ:;Ð¶yìÖßl®ÝÇYwÐ«^üÆóÅ;Ka÷1tÐ°yüí@_ük÷±Uù²¯Ãµû×:ë®ñúqñÒ3Aq5µ³´±ZÇAÃ~ã¾Ú¦¥7Í­¿Æî2Ö]ãôãìæî¤ÛaºÃvY84\6vÞzOÁv¶,ÝÞ.¶þ^¾Ü;`°î®CãÔ0ûs;Ì<¬}ýõ×§ï¾ûî^|NíâZ15KgÙËàBà=úø--O÷a×ú»y¹sÀpý? ÉnÙaæ~ùË_>lØjYÓäÙñdüõãßTàMÇðã7u`eýÝg¹»ôá¨×ïuÀuÔñÊxãs/ä¬°Cü«?þtòëv?>ï¨­t\®/Í6øgCÇÁÆnîløÔ3¼ùYÞ8~GÃsëî5ëïÆðÜÁÂØÎÆoÍn9à:ÊØe½ñ¥·6Þ?îÃ+ì4Sáçq'þ=rpËÇð~8~K¡ãhcwÉW>~1ð
lã·uý<|¬9XØzÀðhì¿µcè¨å,Ý¤öH¶1#ß9ÆWl£vÁ·2>bè#1pDGØQ³¥®¹ñËÛ¿s×;?Z7¬¿i{µk½åØ½1F¿µcè¨å¤;À<¨MßÔ;Æ¸aÚÐ¼±ÇÙÀ»"pÄßiÜVÞ+ÛÈã8w9ÈÜÏÖ¬¿KÀµë½Å²×¿ÇÃã·vpµ¼ñ7ÎäfoOmÌ~ñ_<²´³j}sSø7Çø£JÇlíY¶xààëÍå-ÎÍ­»çÖßssP»æã7µÍ¸KrÐàhÕ£o¦6Lñ¬äÒN3>gíÎ²vÑ·0@¦v¨qìRsÏ¯]×­Ælêà`®ÇpjÜâ:y.ð®]§®·e,÷<X:{eÑÐºGß¼k6\SmÞÑ6Ty0ãxiè1`,YÞÖ¶8vé²6uFi´1RùØ­Ywc¨]
¼ùxÖ®ÏenëÁB:~K£.{pÍ­¿ù²9ÊØ·óè|]®¥b¾ÓLòGÛÈ/Ùz¦<nôÓñ;ÒØÛi^sÀ5rXZÖÒõviüòuw*XLýl±Üã`!X:X[G¿½Æpí×(cÔñè|C78ù´sbàÈ>ÚFþ¥µÁcnC_»¶[ÙÔNóÐv.°2s5¥ëmxÞÚu7¯ÜTàíy,÷8XÈÃÚÜrþnîÿímüöÃµ\ù%5GØ ûzôM~"ég.ìÆ×Ìm¨zßÈ¯1x×<L4äãV»¾ãÓ\ùA×(ËàÔÎ?_oãsÏ­»ùAÆÔó¦ÎÀ÷:·<X
»½ß­Çp´àö}oPþþ¯ÿâ^Ü ,mxæn6HÛ6VçÎ4ägwG³©°;uwnÜÎp=ü»fíú·ÈkZ
»ÑÜÁçÜºØÆc¹çÁB¾¼N$:sÙóøÃüyéåtGÚ ûyôM¾!¡7¼1ÈÆ¯çî¯1p³tð°ö a.\¶?wF<>oéÝ¥®ü kjíMúöðÔr5õ8yøJÏ®ås1ÕÆ\Ðée¹Ür°Ósg5§ææ­çe±Æ×HÀí=úfiã=Ôò3¾©°Ñí8ÎY:xÈÂ\èX
#ÛÔxÄgú¼­-=Ëþ7þ]/ùõùÕÔk¦X×¬¿SíLg/c¹å`!Ö/{°QÅ=¸Önã¦¶½PÏ?;»©QzÖl.§g%çÚÌ7òµ¡KæÇ;Æ5Ò1ÉwéóÒ3=¶øó0Aøz?xXsF1·fÝ]ÓÎÜxö0[âØ­YöÎ0°,Ö8àå`¨còùÆ,¯tÃ2õöTÜ!!ln¸òð_Æ[Ü¸Çk×¸¥gþÜüíÍµ-[lûØª-7áÔÙÈ¹õwnùÏ^Æò±[öÎN¸,Ö8à:â¾ØÇì/Ò3Sg§ÄÙÔsükòÐÇ/nØó 8{µôOSÏ
½kÛÒ÷Úc°U¾lÍÏÇanÝ=wvrÍxÖKÇíÒå`iÙ»ä¡÷e±Æ×(Àí-þ2ýÜØ<ðNµôíª¼­6ð[;xH7øyà8Ê¸ÍÕ8Þ¶¶ÚÒ².Wù²5õ©·ówjÖüßSãÙÓr¹å`áåoÄe±Æ×Q¶À¾9·ýßýí³béFmüVsSià8ÊÆ}ªÆü/ûÅ/lé285öµkß{¹J§©×\²þNe<·,äËßÔöméa±»f¯=à:ú¾Øfñs°pWü9áyyXaK æv£oÜÓ°;uùGxÎ¥\SmÆïk×[jZZ¿Ö®¿ÌQú}í1Ù2vk.]þR#.·<àí`¸­Å_æGÞñçÞ¸a©`27~[Î<`ÍôÀ=ÏÛ¯]ïÞËÔåäÚÀ;Ên9X¸füF·kÇpËøx° ÜÖÙ'L]5·zÿý÷ïÿ}öìÙ5lü5ò¥þQÇlé²sËßÀiíz÷^¦.9([/¼½éK¿ÇíÚ1¼&ðu»\oÓÒPwÑThi­ô "qLÃ¿G³57]×¶üÒß~_»L]ò@>vÁÓ§OÏÞ¥1íé=Ö0¶,nÃKÇÏ¾¸ÖææGãsGésGæµ¯)=`ÈâÏGÚ)^*ß®yk4?àZÓfOá¬©õöã?¾·×<µl-gÈGZ·áÔØ¿ÑÛÚüÂ©·Î½­<ÂÆ}/sùå é¸iÃ¾vc<;¹´ÃÜnF6÷òÀ{ô1M·µ5·l½,ÄþØbóç6Lsgy¾q?7~ià4·ËÆñ\àåMs¡mmà=º0~scX»o=·sÕØ.[l~áÒÝFÿòñËÏðÖî_/ÞëÄÀ6Új÷­Kãç á¼-`Í/\xmð×°qÝeMà½À[nülÿÎ3(aóç6êéÏmðÏÀ»Ï
¼Û¼û_ø^à½ÀÜÂæ®	¼µkÙÔ8»mcï(ßzs·v¿z!ðn?/_î^ Í/<xm°.?;ÊËÇ/Wzíñ[OàÝgü¦Öcã8/¼é²¯uØÛæ
¼ÛÍx·a»vKCGúÐAí¾µnn³<o.ðº(eóç6ê6öëÇ.4vÛÇ0³»ÛäoÉsùØ	¼[
¼µûióç6PÎm;ýõò¿Êdì¶x÷;ËâyùþÁ¥m~áÒJèÝ6v6úëåË±ÛFàÝì,3f@i_hµÀ»zÝ6ïþcgY¼1JÛüÂ4hÔ.¢GSgÁmô·3vÛx7æúñx÷GctÕí,÷å.ycW{ìj÷¥7ScgYÜo,öR½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @Iÿ?ÐÇþði=ë    IEND®B`PNG

   IHDR  ¼  ¼   ºlC   tIMEà	%¿7Q   tEXtSoftware GLDPNG ver 3.4q¤á   tpNGGLD3    J)   gAMA  ±üa   bKGD ÿ ÿ ÿ ½§  HðIDATxíÝ?¨-×~'xùaèÖáFj48¸zpÑCãFÔQ(awt@-Ü3p¡¡;046\p :4bOpÃÃ¡ÏÐ300ÆÉ èöÜu¤u´ÎºUµk×®µ×úløpÏ½×]¿µêÏ·jWíóÖétz  FU½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ´ì³O>ýàÝGj÷éÈFQê ^itúÝWÏOßóå#µûd>úQêe¹`|Eeë;óøuí~y>ò¹èu>F©cå
ñit øòåËS*Ôþ­Ý¯-ó1BÀçc:FY® _FGéY«XÇÝçÝÕÏG¯kn.Ôa¹svop 8õvm¨£v¿¶ÎGï+PGo¡RÇ(Ë Ç°{£Å¹Zj÷éÚzX£ÌÇ(u´\0¾"°CWG{ÔÑQê `|EeGxwwwº÷º{¯¿®Ý§£ÎÇsÑé|RÇ}-,W Ãî²C¿¿.ñÇZ^½zuzúôiu05ds¡jéx¹à8vopn§^»ÐKäa·×:Òùè5`ÅñsÏ:ê.S=/W Ë®å!±× o¬!|Ýcs¡½§:B¿ã¨£¾; Ç±kcaî{ià;òëÈç£·`CbuÔûëH×ê àXvm,X=ÅXËu|Õ×Ç«åóÑ[0%(RÇé$ðÐ§])ð¦×ñÆsÒàÒ#ÞxãTí>\Çé$ðÐ§ÝÌÏöz÷vLz½9¼÷  £`²&(öPÏ(uDéµá/ =Ø½ÁGgF_ÝâutHRSs¿ïásSãÙÎüÚðÞæc:¢PÇÃ_Yë¸ a÷GÚ¡xóKLz¬#Å«Qêæ«¢ 8Ý)(RGïWí¥ a÷G	øöéÞ¹¾ß×îùøiNzQêxèÉî<yrÍëÚ};â|¼÷Þ{§ÿüçô6#Õ1ÊrÀ1ìÞà(Aq©j«£v¿¶ÔbQí~µQ; Ç°{S+ü,ýyí¢×ê^[í>n^ú>WK´Ú};ZS·§þp,»7vyPÌÓCàZ{sµûu­ü¬h¯a«×:âz¥!¸vß  ·{kbíÂ£©@~i[ªgJ'sß÷¨× 8Rù2$ðÐªÝ<bàm­¦ÜTÀm¹¿kk_÷²z®cjzhÑîövçú´µ-ÖÌÑmµ¿kk
ÿö®z¯c.ôÖî ¤vo°ÇÀûuí5¹­Ö6×·û»¤ç³¢£Õ!ðÐ]ë5ìîiîrYCïgE{®#ýD©w] Z´kcçTËap/-×8Bàá¬èHuäÔP»? 0e·Ö§Ãà¼í¥! g·ìøÚ5umr¯óÅ F©£×åcÙ­!;¾v¬ùËv½Î×(Aq:z] 8Ý²ãëK¯óÕs8±^# e·FÙE¯óÕk¿G­Cà »54Êü(Ì{°Ðê ú%ðÐê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  4úéïr}òìT»ØK>ÏÕñý7_Ú} `YFcLÝ}õüT»Øµýß>OÕ2õ\  Úô³·<ÿÝ¿ùßîå_ÿ£ùï~íÿÙo×ìÇGý/þÙ?>áhüúåË§ÚéþW¯^=êc8ÃúZâ×ñ÷ß~ûmó5 ]Fc0¼{ñ80¶~	@xÓ×~?Rà×&Gµû °§">\·ûâyw×ñÞÝÝ=ô1½7­%Öä^¥aWð FS¬áýk?;=Ý`ê,okIëHÃqÏb°ÿ/ 0bÇÀCT/7ÈÏòi-SÏëY¼!äë­{¯%ÎX Åað^xãÏj}N8ËûÐÿ:ÂóF¸7½N9½^9ßÚ}»K5  H£!Þ§×ÿðøôéÓà^»ðsB¿¹:b(®ÝÏk¥¤7öð©ç¸T vo0ÁbhLbxN/gFêè=ìæg¯c01ðx© °ÞîÆ ¸x{út¥:z_®q;¹dãë¯¿îº¾`äK5 ËìÚXdcP:+ÚËÞsuôèkÓÀûc]£ÞQ/Õ  .³kcoÛ¦ÂîTM=Þ#\ª \f×ÆÒ¿¦v.(ÐÛÃ__%ð»!ä=Â#\ª \n×Æ¦ïÜYÄüù­ZSGÒO×$§õ@_»×ÖwK5 Ëkx 8JùÇ©¥¡7Áïhj¬© X¯XÃ£ÅQêHû~Æp½ÞÑ.ÕHJjªÝO èI±ãlè=(RÇ½óFh!°×°t©Æ¹ð/Ó!¾v ÅþüÃ·O!dáëø}íÕñ¸ÚýºÖ(j¤uÄ@;v>SØÑ Õ5ÆÚ«ãééÉ'j÷ëZ£\ªö?ÊCoþ©=Üô	 -(ÖpC¸ê%|¨£Kj¤µ×îç:ò°kyt¦7	¼ið­Ý hY±ó3½,u´-½L£çK5ÒbØMoxÎRàz`^±çÞúï-d©£m!Ü~üñÇ.Õè±¦XGÜãµâé_0
¼ÎòÀ²bÏÞÂ:ÚÃnï×X/Õ¯K_ÏÝO?x·»àV5<JÀRGÛ={vÊõXÓRñ¶¹ÐÂ®À ó5<JÀRGÛB0¡¦suÄÐûð½° «kx)tôHÔÑ¶£Þ ½ál¯° ëiô\àè%¨£}G
¼ÁÃºv£ ¬V¤ÑQ:Úw´À \®H££,u´o 8J Ð¢"°ÔÑ¾Qâ(u @4>üÿß·Bmp%¥ hUFG	XêhßÔÑR ´¨z`­©³ =ÅQê ^Tï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÅþìg§O?x÷ÚÅ^SK^Oí>©e¬Z r5|÷ÕóÓ÷ß|ùHíb¯©%¯§v®­%­§vÔ T¬áBâY·Dz>U^Oí~m­%¯§vÔ T¬á/_¢Hâ×µ¾¶Tí~mâuV PNFãÛË1Ü½xÞu «§v¿¶HßþOë©Ý¯£× S¤Ñüz×Bz¾¾rªø»oïîN©Ú}]SKZO¨e®Ú}½¶Tõ  ekx´ÖÖÖÒzX¼ä&¯j «XÃ£Þ»×ïÞÒÐbP|õêÕiªk	/LÕÓc- @YEMCÈ,hôª3Z¯'Ô²¦ûçÌÇVÂb»×Ö Ãî~ûí·?Ü<ôcØxúôé£ ×z@BÓpj	ÿN=7¯§pÅÒZfëÎbkµ¤sZ[ p,»78cØA8>7ãÚ°$ÞùÏ$ÆZÎ½®µk=Ö²æu-^Çç%­ç×·V PÖîNÞôìg¹­Ý`*$Æp5uÖ°åO8HCâÃAÈ3­×ò¨gqE=w}ëÒÛÏ-+oí~/Õ²æF¯ëHkyTÀ Ì(Òh"s×ïöâád>þþáluã1­%¼¿õÏ?:õp¦}®´^k Ê+Òh<+:{±x{
»i-ià][¬m*ð
» À"x{¹$cª4ðÖîÓµµ¤õÔî Ð®"¾q­h§ëÜ%=x£*Ò¨ÀÛ 8ª"NÄCÉ(uÄZòzj÷éÚZ^ `"~þáÛ§/>zç^ø:~_»Ø£Ökýï¹´´Ú} ÚU¤Ñø¹µ¹ÚÅµ¹Zj÷I- À-i4#O<é2RG^KÏuV P^FcIõJF©#¥Ñj Ê+ÒèÜÛÌ½Qê«¥Ç:¦jéµ à64:@z&£Ô1×çëêw¯u  ·Q¤ÑQâ(uÌõ¹Ç:¦úÝk ÀmìÞà¹ðÑK8¥s}í©¥þöV p;»78JP¥s}í©¥þöV p;»6¶&tôLF©cM?{©ã\_{ª ¸­]%(RÇ~öRÇ¹¾öT p[»66JPTG{F
î ÀmíÚØ(Kíx­vml¥¶R PGõÀ9Â, pê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z(ï³O>ýàÝGj÷	 àV5<RÈ
µäõÔîÓ%î¾z~úÿìßûþ/¾®Ý¯­s1Êr ÜF±CÈ
á*U»ØkjÉë©Ý§#ÏÅ(µï pÅÁ$îÄC(éyCV^Oí~­õòåËSú¿®Ý¯­s1Úr5Bxkx¤ÖªÝ¯5b}¾{ñ¼«þ/ÍEïËÕHá ZV¤ÑÑBÖ\=µûµF~1ô½×3£-W#w hYFG
YsõÔîÓÖþõ¯ýì^ó1Òr5Zxkx¤ëG¨%ÞxÞW»OG©:zï ÐºbLîîN÷zþ¤?þ¬vß.®eåj´Z  eEXészØÁ¿zõê!Ój=¡o÷o¿þ7ÔóôéÓ>Ç×îãÑ«z^ ¸ÝüöÛogVNzØÁÇPêµ§Ûb=qòÒ¹óU»k´\Å¹9Þ}ìÞàTH;£ØzØ7Å3½±Úýºd.bsw.À·f¤åê\xïí] hÝîNtGÃHë¡$uÄ³ºyàmýÆ¯4ÈÆù:+ÚÃ<[®ÂûÒHëË ´ªH£çÎLõrV1á$?3Úzø-ðZ®Îw `_E]
X=yøÔ,hÅß·Ó un>B=®Q«Àå
 p;EgEçb/oËa7
¼KóÑCàe¹Jçdð ­+Òè(Ád.ðöòÖyZÇ¹ÀÛQ«ÑjÖit¤µtIC/Fêµ¼ pE%x§>æªv¿¶Ô1Âr5Z- Ðº"°F¨ãóß>}ñÑ;÷Â×ñûÚý:ê|ÄZ^ ¸"°F©#~¬Z®v¿:ÁHá ZW¤ÑQÖ¨u<yòd:z`¤ð ­+Òè¨«ç:BßS½Ö1Â|LÕÒsxÖit¤5JSýî­Qæ#Â; ´®H£#¬Qê¸äç­e>b§Â{µ @ë4:RÀRG;F©c´Z  uEeg®¶RÇhµ @ëvoðÜ»ú(uëk/ue>z« z°{£ìÌÕÑQê­ èÁ®­ÙQ÷°3¥5ýì¡#ÍGOµ @/vmlù(u¬égui>zª z±kc£ìÌG©cM?{¨ãHóÑS- Ð]eg>JAø|×k~ßæc¤Z  »66ÊÎ|:·-#Õ ½¨Þ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   J*Öðg<;~ðîÚÅY>æ 8bß}õüôý7_>R»Ø-F	î#Íà \¢XÃ1`ÅP¿®]ðÖ:z¡|.Ì pÅ~ùòå)Iø·vÁ%¸OÍE¯ó1Bp n§H£éÙ·¬î^<ï2`Üçæ¢·:òùè9¸ ·S¤Ñ©·CÈª]ì¥F	îù|z¼`¤à ÜN±G¸Örà>ê|ôÜÛ*ÖðKí¥ àv4zwwwzð: <xý}ø}OAeµ4Q/µ0 ÀmiôÛo¿½T¯^½º÷ôéÓ ~ßKP!¸¹¸¿ÞõÇùHç"½=Ô2Rp n§H£iØMCVzsQbµ?gàÇ}ª{; p[E
¼ii9X«£·à>x§æ¢Ç:zî ÀíiôÑ¥ ?!+ÚE_RGïÁ}i.âszQ; p{EÁ$ü2Üã|Ì]ÐQ; p{E+«V¬càç#µûµu>z_® Û*Òh{&#÷ïÔ\ôX p[E)ðª££Ô ÜVFG	&êhË(u  ·U¤Ñø1Q½Qù  ¬H£øöéÞ¹¾ß×.öR£Eó YFó7óáf¯Tíb/5JPó EFóÀûäÉ.Ö(A1ï¿ù  ¤H£y¸%`õ^GÞëè}> Û*Öp%álï{ï½wª]è55ôÜóZÒ¹©Ý¯-5ôÜÛ*þ@Òkàý5=¬ôv£Úý:ê|  ·Qü?è=ðÆb¿õÏ?ê¶¹k^{
½yÿ{í Àmm<Þo¬%è=ðNý¼§ÀØ{` n¯XÃ#Ý ªßBï=,ØÛ+ÒèHa7^+:U_o¦.¨Ý§kúßs- Àíi4Ü=þí=ðÎõÀÛ[@<7æ½Õ ÜNFG¼K}!ðÆ9êÁñx9ExÛ"ð GT´ñïR ì),¥ß½Ö W´ñø×°j¹wß{­«ç~Z P^õ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T¤ÑÏ>yvúôw©]è àÈ4z÷ÕóÓ÷ß|ùHíB·
=ÅQæ `"ÃaW=ÅÿÛÿê^¨#~]»_Kýy>  ¶(ÒèË/OQXñëÚÅ^ÇÜÛÞê  ØÓîÆ·Ìc¨º{ñ¼ÛÎöïîîÞèÛHó °Åîæ×Õã5£ù5¯=ÔñêÕ«7ú7Ê|  lU¤ÑnZç®­Úï³¼#Ì ÀVE!`³¥Suä²µÚÖåm­Ï  %íÞ`÷^¬IHlñ¬èl¯åa7¼S³¶Gã}f>  F·kc!HýÙýÙ} 
AðéÓ§!±å3±¿suä7{µxïÏN_X À¨vk(¨ «¥ÀÛbHÌk«#Èôwµû<'ôm:  ®µK#éÃ¹Ql1`å¡|MpïÁÚ:Z =ìÒH bÀ
?ËoËgó®uª£v?/57SµÖî+ @	»4²&ðÖ.tmñFµëH­¼-_W p]%ð¦biê  èÏ.¼í¥ ­vi$};<¼=,u  a·â%`© `»7V®zXê  Ãî~þáÛ§/>zç^ø:~_»Puô] ÀV»7øäÉû¤¢ø}íB÷ª#ªÝ¿£Í ÀVEMÃU¸j»Gáßø»Úý»¦Ú} ¸ü'=ÄsµôVOÚï|×<  w7ùOzsÞ{ï½SoµLØôRü,píþ ì¥ø§^Bbì÷T ·:æ à6ÞkØë{7­-Õ pEïýRxéÂT=½g¬Sµû PR±{>»
¡7ªÝ[Í ÀH4:JØ=
 YF{¿ qiTà  EÍÿÈAí" 8®âÿÀ @MÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T¬áÏ>yvúôw©]ì¶¶±køî«ç§ï¿ùòÚÅn1ÊÐ|´Å|´Å| ­XÃa7¸açÑëÆw¡ùhùhù [±_¾|yÂF7~]»àK²#4m1mùÛ¿ý[ó0°"Æ3q§q÷ây·;ùhËhóÂbj_×î×ù¡7ÌGüºvß¶ÌGïë@	EÍßV;ßZ%¶8! Æùè-ð8=¯ %kxkÉFÙö¶±kx:Ús:z©í(óÑQê Ø[FïîîN÷^o|¼þ>}N/ãv æ£-sóÎI/µÜ­ ãÛ½Áo¿ýöëÇ^ï0^½zuzúôéÃÎ¼·ú;BóÑ¥ù?O[»¿[æ£§åÊúp»7wÜaçÑó}¡ùhËÔ|¤}sÐò\+ëÀ1ìÞà(;ôQvæ£-iòê«ÝÏ-ó1Êr5J=® ¥iÔ½-æ£-±¹³p=%¸OÕÒc#­ %itz0ÂÐ|´gùPG[FY? J(Òè(;QêýÏkè±QæCm	uX? ÆV¤ÑQ6¼£íG¨Ã|´ÃzÞQê (¡H£#íÐGØ¶4êhÇ(ë@	Ei¢v¨£-êhË(u P¤Ñø18½oxGÙ¶¶ñiôóß>}ñÑ;÷Â×ñûÚÅ^j¡ùhùhù _Fã§äj{©Qvæ£-æ£-æ`|EÍwO<ér2ÊÐ|´Å|´Å| ¯H£q§êqÃ;ÒÐ|´Ã|´Å| ¯H£sgzÛø¶#4m0m1 ã+ÒèÜF¶·ïH;BóÑóÑó0¾"´QG;ÔÑu´e: J(Òè(^u´Em¡s}¡j (e÷GÙ¨£-êh:Ú2J ¥ìÞà(^u´EmQG[F© ][³QíaÃ«¶¨£-êhË(u ´kc£lxÕÑu´Em¥vml¯:Ú¢¶¨£-£ÔPÒ®²áUG[ÔÑu´e: JÚµ±Q6¼êh:Ú¢¶R@IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRF?ûäÙéÓÞ}¤v¡êPG+ÔÑu´E@	E½ûêùéûo¾|¤v¡êPG+ÔÑu´E@	?{«Ðã÷þèOïÅ¯ÿÕÏÿëS©ÿ«äCm=ÔÑÖCm=ÔÑÖc:<<xHÑ/_¾<Eá¨6~];Ý«C-PG[Fªãîîîôóÿæû:Â¿áûÚý:rSË³½PÇîÆ9®Üw/w¹QG[ÔÑu´åuôÏÍGz·{ùuKaEïe#¥v©£-êhK¬£÷À{®^â¹åª:`$Eåb}u´EmQG[PGOAq:`E=Â·'êh:Ú¢¶G©F±{aE¾÷zeÐáÊ­¶¨£-êhËèuÄZz©i:`$»6Vâxí«W¯NO>}´÷BmQG[ÔÑ#ÔÞCM£Ô£Ù­¡¸2a%ïuÃ«¶¨£-êh:Ú2J0¢ÝwÑö¾¢«£-êh:Ú¢¶Rh·âÊWôð}+z^GZ:Ô¡1ëe{¥u Óvkh}Ôº:Ô¡ù:FÙ^©CÀ´ÝeEq×Ðc¡êe>FZ?FÚ^©CÀ´ÝeEq>RÀ¡æcõc¤í:ÔLÛ­¡ø¡Ú½u´EmQG[ÔÑQêíÚXüè½¯èêh:Ú¢¶¨£-£Ô£Ùµ±ð×dÒÖ~äõïj«u¨CêhÓRµûvÄ:`4»7øùo¾øè{áëø}ø]OÛ]mQG[ÔÑ#ÔÑQêìÞ`¼>W»Pu¨£êh:Ú¢ ÝÌWð'Ot¹¢«£-êh:Ú¢¶Rd÷ãÊêqEWG[ÔÑu´Em¥ÉîN­Ô=®èêh:Ú¢¶¨£-£Ô#Ù½ÁQVtu´EmQG[ÔÑQêìÞà(+º:Ú¢¶¨£-êhË(uÀHvop]mQG[ÔÑu´e:`$»78Ê®¶¨£-êh:Ú2J0ÝeEWG[ÔÑu´Em¥Éî²¢«£-êh:Ú¢¶Rd÷GYÑÕÑu´EmQG[F©F²{£¬èêh:Ú¢¶¨£-£Ô#Ù½ÁQVtu´EmQG[ÔÑQêìÞ`øk~Ö:u´EmQG[ÔÑQêìÞà(+º:Ú¢¶¨£-êhË(uÀHªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤]¹ûêù©v!ê  `Ê.|ÿÍ§ôûÏ>yvúôw©]èê  à'W7pwwwzãg_=?ðÊ_»ðQë  à±«ñhùÙÑ<8¶`ª/_¢ÐçøuËu  ðØÕl	s¯«iª?iß{© Ç®n |ñ­ÿï^<ï"(ÎÕ:¦Îè¶V  ]Ý@øòë^çâ«W¯ÞøYM£Ô ÀcW7°åf¯ µ êHk¹ÿþÜMk¯ÓZ  <¶K#Å Å ëá7xtw"·X  ?Ù­¡4$ÆÐû -Äµu»  }Øµ±Õ~O>}áû<ø¶j:  Ø9ð!(P8k{Ä:  n÷çbíBZ ÀÑíÞ`!öCßG¨ àèvo0Þ4$öC¡Þë  8ºÝ)ð¦7¨õZ ÀÑíÞ`<3Ú{Px Æ°{£ÅQê  8ºÝ%(R ÀÑíÞ`ü½ÅQê  8ºÝüüÃ·O_|ôÎ½ðuü¾v¡G­ àèvo0~W®v¡G­ àèvop*$>yò¤»°8J  G·{i8Þ{ï½{=ÅQê  8ºÝa0Â¹ßÕ.øhu  Ýî.Áâ(u  ÝîÎÁÞBâ(u  ÝîG© àèvop 8J  G·{S°Ç8J  G·{£ÅQê  8ºÝ
á3lkzÔ:  n÷G	£Ô pt»78J(¥ £Û½ÁQâ(u  ]õ  @IÕ;   %Uï   T½  PRõ  @IÕ;  ´íîîîtNí>®ñéï?üßU»ê(SÇÏÞòðððððððXx¼÷Þ{gyóøøST»/»=j§{  m¿úÕ¯NçÔîãw_=?ßóå¬Ú}¬]Ç-çõóá¯Göò,çÇ¯ÿú¯ÿZP»{?^n[BéïýÑ¾õoÿý¼~=õh9ü]RGËÔQû´< Ð¶/iØÒ¿ûËß?Å·ÑÃváùw/ÿðïëï{¹¤áVu×[Î3¼KÎÞò­ÿüÿoÃ_r6öÉùê­ÿë?ÿ÷_Ã÷=>Ô±îñë»¶æááááááÑý#Ê ×ÙðÜüuÍ?þïþyòOÿÉý¿ÿè_þ»>ú?
Õqóy,9µOË íoc§±{éå¥ß
¿ä2ð¶x|Û<¾? ¼}ôð	ê¸NõÂ`4½ü!´¿×P®¹ç®-zçÚ^ú«©uÉG`m½^yËkJÖ±W[¬cÉMV$ 848ÖîËÚþ^p×Þ(¶GZÆS¨/«4`}ýõ×§ï¾ûî^|Î¹>Ü"ð¬cÏ~¶ZÇj+ ¨§À»GØMÏ
çí_ ¶ÝGoÿØ·<`å~ùË_þðÜ×¿?×Kêºäù·ªãÚ~¶\Çê+ $-Þ½Âî¹à»5D­Si*` õWüéiêmöpõãóâs¶ö©õ:úyõrU¹9ÕW8 Mgy÷»s¡·FàMCVü×ÂÅ²Ráç1T×Ð»¥êØ£®ëS}Þ¥hþlkèj¯DKÞ½Bï5×î>ô#þQ$d¥?+}ë<>/þÑÐ¶ôkê5ñuS¯_
%ê¸¶¦KæãVu,¹ùF F_Â0õq^kkþÚ^ozKÞ4dÅ×ð4¶Î ¦sõãëãÅ©°÷mk=suM½µC`©:.çÕËU¥:Î©¾¡ ]þr±¥Ï¼-zK\¿;Ww:N[Æv±ü¬áWÏ'o~ñ_<±5÷K5ÖÔõ,UÇîËUÃuTßP @Ïã¹³µkþ¸ÃÞ÷Va·tàMÃTzè¹Àß§á*T±½ïÚ:âõ­×Öñè±·õ:ªo(  gsá1ÿù\àzn©À{Ë°»Gà­cæmó<ð.¬xfqªÐÒ¶JÅ¥:Ò xmi=jÕ7 Ð»©p{. Î½¦Ôe·»±ßéÿ»ËX/«ôÌlYsoß?+TñgiàÝ;0«#ýkëÈ~Ä:ªo$ `kÎÖæâkçâÞ÷aw*Ìï2Îá*ýYúÿæyg§~¶ÿ_·¨ã\ß/©cîÿ:RÕ7 0kÎ Nµ³÷°¨xw­câ,_zhGyè
QéÛçñÌc~&2¼{Å5uç¥}ÞZGÉÐÛKÕ7 °ÆÜ'´òÇöºd`êLñµ5®í[xnË7^z.\Å:Ò·Âó 4wTY}yËþVu×Ô1wæõhuTß@ À5¡¶à{mØMëØ;Ì¯í[|~ë7øû¿þGái*ô¤×¦_Ï}ôUl#?³´½bé:òÿëÈuTÛ0 À9¤¡wËÞøÚüìêÞ~íÙÝ´?[ë(zó»üCÈJVþüô-ô4dM	mç¯ÍCÖßüùìÕqû:ªl à­Á¨Vèÿï¥7­ÍÂ¿»&ìF[ï×][×ÔÛÞKa'YSoÏµÃWVAs{] ÛÖqó sMØ­uoþÿ\sC7¸4ì®yÍ­o¬4hÅpM|³ÃU<s¹çõ¯ê¸mÅV| ÚÒò_S}=WÇÒÏæ¾¾e·Ý´­[_Ú?Kà=÷º=êIN¼îmôûºgÞ6¡k.`Å×n	uêh«âKWýÙªõ;Íù0æ#ÎÅ­Ï&^Ûßµu¤ó´ÔÎ-êËÿ¿=ïÞý¯x÷ª#^ËÿzW~mgþü©?z]Ì?MàÑÍ,uôUGÑÿ ·IXi_½z5»C¾þúëæë0m1ma>.	^­Þ¹~\:¥BãR¿Óÿ#ögKèí5ðÞjKUúÑXsëO~÷·Oç¼1VÙT{UÇmë(¶âO¹t¿eß.±´^¾|y¿Coy§n>Úb>Ú2Â|l9ËØBè=×ÖïÜòöqËìÑÿwÏñ;8~ÂÇ^óh³ùÿµôv»:Ú­£Ø¿e¥éa'7háìUÜaOíÌ£¥kXj2õûn>ÌG«uÔ¾Äaéÿ¾dnxc<×÷5uLµq«3¼ØïÚë8·¬øo~SýÕQdÅ²uÃÛÚN$îÌSùN=Ý§G%µûn>Ìù8Ö|\SGÍÐ./Ö>÷ýOdü·Ô1wø7íã%ã¾vÛs>òíÇ¹·µçBÕûï¿ÿï³gÏNyûiÀÊC:ú«£øF`ÍJÐÓNäÞycgÜïÄÓ3Yw¶´S7æÃ|?×ÖqëÀ8·\Ç[ÔqnìÖÔ_3µ,í'úrÍ²³öu{ÏC¾YznQi°¦Î(Æöó·ç÷ê¸]»zÎµÞVv"aÅyºC¿z+;uóa>ÌÇøó±G5ÏòÆ·öûuäÿ_ZÃ:òþ¥ËPÍ³íkõ©¯[Y¢üíò¥·ÐÆ>Û>µp:¶Õq³ÂFÙ|þáÛ§?þøa§¾ÿß3Zù¤´zË|ó1ö|\sf´Ò{àË@zÖz®S}[úÝ­mYÞ[YRSaê\ÀºÃÎ\ª£Ý:nVØ; ìÌ>}úð»°Cg²¦&$îÌ?ýàÝ&ê0æÃ|=½ÞXÃÖOÈç¡FàÍÿÿ)sËJí±ÏûÒò²¾ÖÖÕuls³ÂFØá\Ü¡Çvævêagnn>Ìù¸ï:¦Ânl§V×>§U­/ëk	m9dà=÷ûV¨üÎÁ îÐ¸Sø¾Á¹ù0æcüùXsÍhëa7Öqîøï\ØMÛª1ÖkÓª÷5Å¶6ð.=§ö¤¤ÎíÐt§Îfµ¶37æÃ|?kïÒsZ»ysLÝ06×Ö­ÇzíµÈµÇyÉh7\zÿ¬Ç ¨ËÜ¬°5+J+Òzvä÷Zµ¡qÌù0ÇkBX+awkKmÝª|,YKã=Eàm:¶¹YakWÖW¢µ;ôÖ¶¶ô>½½õ§Ü¢¥öJ÷w.ì
¼õ	m2ð°¢D#ìÐÍG[ÌG[z5lÐzÀº¦¹ÚnUó¥a·ùxÛ¢mnRÔ+JdÞóÑóQ×¹¼z	X{×Qó³GÑ¯½Ú0äMk#¬(AØq/}ìR/ÌG[ÌG[zs7qõ°öª#o£×:Z!ð¶EÛ)¢÷bÉÔ¬Ö¶¶0ç®­ ÕÑgÀÛulS¤ÞWhêlºù0æ£5K«vßÔÑoÑ(÷ý÷ß?½EulS½`  ]KÜËYê ¬hîg­SÇ6Õ ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z   ¤ê  ªw   JªÞ  (©z zóéï¢?üßT» ü¤z z#ðô¥z zs÷ÕóSôý7_NªÝG ~R½ ½xú²éEéÆ>Øûù -K·géeé×µûÀO.~A~Fã\ÍÏ½PkP¯ówùûâïîîN¿úÕ¯Nw/ÿðïëïk÷±e?àÖ~öÖÿã?ýáéÉ?ý'~vúïï-=?øþßÿïìó=<<<z|<ù/_½õþ§sÿuø7|ïááááÑÐcm2giÓ³µá,GtíóÛqêuò3¼÷ÛºÏï»ó,À­­~b`Óðº&ð{>p;ÇåÒK²ÒÀûp¹À»å¸µÕO;S¿»kîùµ#sÓÕú1ÊØ\àÖ.[Ëp+=9ÝHÅðw swêùñ5µ£rÓÕ²¹ Æ%¼§÷ë¯¿>}÷Ýw÷lßÎ³ü·¶éESÔ°ô¶³ ç¹kyÛxÍñZ6uêýÏ^ütpZ»µÌmßB¼©_þò?<×'ÒÌ²ü·¶éEsoó]xí~"ðn/w7]M[Ú¶ÅÀí_ýñ§o_z8>Oèµüm¸øqõ÷ý÷Ò}¼7"á¹óç0ù|;7ÇÕM×ÜX¯7¹éjÝr5wpßzA6_½©³»¯þÍ_[»¶Ú,@M¿ ÿ«ii±ü:¬x&$Þ|ÞåqàÖÀ{ù¹éjyÌæïC`ËÎÞÆñÌ/e_y[gùZrÑCxÍoVË¯ÁÊ¯ÃÊBoºó¨= ­p×ò¶ñ«£ï4ÝtuÝr5w¹VpBn"é=ò%\? 5=y)ìN]uîùµo»¯¯±:ràuÓÕöq3õ)3qñ_<òÆ[õÛæYþ]ôä<¼NnÔÀ{îùµo»·×Ã2öâñrV»5Ì½7]MÛÔ|¼V7¼¹|¶{GGËÐ¢ÕO#o.Ðæg6¦_»ø¸kù¼ü-å¹±:òx-]^ê¦«Çc6w Þ¥ÐoºÍc®×µkµüGµêIé¥°;uÖÜ¯vá-
pïº^¦Æê¨ãÇl.p<¬nº\Æ¦þMÙ\èá6Þ4ä¦g1|-@«Î>!Kojã}î:¬ð}ÜiØp½i.ðNYÛ^º#©]ßÖ1Üqf× ^3N#Z:[!wÓÕOËÙ\0ÍÏB.gxó³GzËò´êìÞ¸jbg°æ:¬ð¼ÚÅ¶jÍ]ËAüH·øÆy;qG¾ÍÚcàÛaNÝô2ùÎÂAoð[Oóå"={yô®Ò1
ëÔÜ6.5õó©Ëbà:{<âxZþ}ÂÔFzn'7wVíb[ïÖÜµÝôùi±­TíZ/Ù·C¨¥3¼é»µë©±<¥cæ¦«eé¸Äu+ßô =ßÎåË^>vñµùö2|>q´ñ´ü­;û¹ 6bk®Ã²±Z?¦éN"ÿãôò×ÄÏ5íö|wéûñÉÂnþüôíÑ#Ýá½ô6²®¥ëÙÜYÈüle´ñëÔò3Ã¡ý<$¸M´ü=8û¹Ü5×a¹¤áü¦;<ÈåþðýÔ_®KwÞ£ÞG!ùX£ÔÃr¼³pÐ;uV-ý×MWçM$ÎaLîTÍåV}Àkùzqö	s!,=«{î:,¨L;º9+ÝèÇÀ>7?kÒ[à:SÜÜÞG¸Ë;SgÝtµl*M­éØÌm§Ú5ìZþ}ÂÜgÍÛRéN¢v¡­;47¾éYÛôg1ìÎídãºv½[Ç%´Sg½ßxgá«®!×Úu77]m0NéÇ©³¿é:;w©Ä(cgùzqö	yhH7BS¿Ëß²Qz,ß,=
³ùïòkú¼Úµn¼¦¹^Âsòwòñ;BàuÓÕþã¹Tç.c¿:	þ;ÚYþ^}B¾±Ï¼óßO]U»ÈLýÈÏZ¬ùþÜÐ^.eÚù­	¼iùÎ2'#ïÝtUfL®5ÍÏäÎ­ùYÞÚuYþ#[õ¤k®Ãª]`kò°ÞÔqng¿N¯	ÌÏF¥ÿÖ®uíXLÝ¸³\ºf2=Ó×nxqÓÕþã9÷ÉüîoäËéÈa×òôdÕ®¹«v­
y¹©·´ñz¶ì\é8ÌzW!_öÒ ÿµkß®Ê,S×ÂçÑÌq9³ü=»èÉ[¯Ãâ±s7?µ©¾éå¬ÒÔÙ×©À¾t5õ®B¾S=JèuÓÕmÌÜgÏÍªÝgËpt=9ßP-]å(|ÞÔÛxS!xj§0JØú¨±´üüySï*Ä³ISwxOÞÚcPj\ÝtUVtßÿýûP{ôÐkùZvÑ§Îç6`=®ò·÷æ.cº¦wàßÝ/?ùr7u5õ®Bz°ÛQÆÜtUÞ³¼G½? %¿`î-©4h(ö¿Å·tö#íÌ¯ëyóbúqFS7½yØ
³S¡7þ)æQ7]7xÃï^ËÐM/:wÔec8èò³j÷·KÎXO]»æøót§þsí1(%Å®æÎ´ó¦©À5ð? 5^´t&ÒåëÇp)ôáàáÒK4¶¼³Ãn<<Âå ×X8j÷±7éåñgGºkÇÊòÜÚ¦-]ÃGíÂZÜ£<äo_.ÝºÆ/»sc5ÚõÏ×
ùMWµûØôÚÝø3aw~¬,@^tî:¬ va­:³{Äü/5å×Üæc6õÎÌÞÚµ×CEQúóÚ}ìI~³ZøYpÂÛôxYþ6½ÈÛR×û_>ý­S°tÐ~_»¥M}ÑÜMeKwwOä×öýìn¯§ih³î^>ùÙÜâj÷¯U? M/x¯·fþó?sgv§Bé%ï,¤¡xê®ñÚu·²ì¥ß;+yùÎ]º ô;ËpK^4ÐÒ·¦jÖ:?XúÌÎkÆ,ÍyèxaÛcnLxÇÎòÜÚ¦Í]Þ|P»°Ö-¶xàP»·__»t©ÁÚÀ]`??SãZ»=pFòº±³ü·¶ùÒ¯ÕÜCí>ÞB~Ú¹1;÷ÎBz§ÎòÖ®¹6ãzî·³ü5l~¡ë°®7àìHçÇkî aî²©Üj×Q[§?þø~þe.YØÎòÔ°ùÎð^o)ð:hX?^Kg.9|SáBà¸Ð»å¨aó½-u=gx¯³¹q~üë¼³üµl~¡Ðq½|¼ÂÇÃËÆÍò·mìB°HÇiêg°7ËPË¦ÍGéÛÇ1|/ðn»¹q~Ü·bùjÙô"oK]ÏAÃ>ãgùÛ6n5XþZ6½Hà½1¼~ìÂåwz§?c~ìj°üµlzÑ\(Ö.Ã©À+´­;
»ÑJàà,@-^ä(ý:çßºñsýîåæOà,@-^$ð^Çøí?~Æn,@-^$°]Çøí?~Æî:5YþÒ6½H`»ñ»Nú'~ lzQ.æBàaün5K? ¨Þ  (éªúÁ»§àç7fÕ.×ß¥u¸v`W½Xà½1Ügü6cWkü¬»ÆhßÏÞºâñþçÿþÞÿú?ý³<<<Ú|ÄõwiöðððððâqMZ¾ûêù)øþ/gÕNô­3ûßÒÖîc«Ý>ãgÝ5~@û®:Ã¿÷GúÖ¿ý÷ÿñ^úµGë°ÇÐkÒòßýåï?!º»»;ýêW¿:Ý½xþÃ¿¯¿w~^¿ôZ¶ôkc¸nüÆ°v[õhýYk÷±eÖ]ãôãª§;Ì°qºÿúÅã·©jØ:;Ð¶yìÖßl®ÝÇYwÐ«^üÆóÅ;Ka÷1tÐ°yüí@_ük÷±Uù²¯Ãµû×:ë®ñúqñÒ3Aq5µ³´±ZÇAÃ~ã¾Ú¦¥7Í­¿Æî2Ö]ãôãìæî¤ÛaºÃvY84\6vÞzOÁv¶,ÝÞ.¶þ^¾Ü;`°î®CãÔ0ûs;Ì<¬}ýõ×§ï¾ûî^|NíâZ15KgÙËàBà=úø--O÷a×ú»y¹sÀpý? ÉnÙaæ~ùË_>lØjYÓäÙñdüõãßTàMÇðã7u`eýÝg¹»ôá¨×ïuÀuÔñÊxãs/ä¬°Cü«?þtòëv?>ï¨­t\®/Í6øgCÇÁÆnîløÔ3¼ùYÞ8~GÃsëî5ëïÆðÜÁÂØÎÆoÍn9à:ÊØe½ñ¥·6Þ?îÃ+ì4Sáçq'þ=rpËÇð~8~K¡ãhcwÉW>~1ð
lã·uý<|¬9XØzÀðhì¿µcè¨å,Ý¤öH¶1#ß9ÆWl£vÁ·2>bè#1pDGØQ³¥®¹ñËÛ¿s×;?Z7¬¿i{µk½åØ½1F¿µcè¨å¤;À<¨MßÔ;Æ¸aÚÐ¼±ÇÙÀ»"pÄßiÜVÞ+ÛÈã8w9ÈÜÏÖ¬¿KÀµë½Å²×¿ÇÃã·vpµ¼ñ7ÎäfoOmÌ~ñ_<²´³j}sSø7Çø£JÇlíY¶xààëÍå-ÎÍ­»çÖßssP»æã7µÍ¸KrÐàhÕ£o¦6Lñ¬äÒN3>gíÎ²vÑ·0@¦v¨qìRsÏ¯]×­Ælêà`®ÇpjÜâ:y.ð®]§®·e,÷<X:{eÑÐºGß¼k6\SmÞÑ6Ty0ãxiè1`,YÞÖ¶8vé²6uFi´1RùØ­Ywc¨]
¼ùxÖ®ÏenëÁB:~K£.{pÍ­¿ù²9ÊØ·óè|]®¥b¾ÓLòGÛÈ/Ùz¦<nôÓñ;ÒØÛi^sÀ5rXZÖÒõviüòuw*XLýl±Üã`!X:X[G¿½Æpí×(cÔñè|C78ù´sbàÈ>ÚFþ¥µÁcnC_»¶[ÙÔNóÐv.°2s5¥ëmxÞÚu7¯ÜTàíy,÷8XÈÃÚÜrþnîÿímüöÃµ\ù%5GØ ûzôM~"ég.ìÆ×Ìm¨zßÈ¯1x×<L4äãV»¾ãÓ\ùA×(ËàÔÎ?_oãsÏ­»ùAÆÔó¦ÎÀ÷:·<X
»½ß­Çp´àö}oPþþ¯ÿâ^Ü ,mxæn6HÛ6VçÎ4ägwG³©°;uwnÜÎp=ü»fíú·ÈkZ
»ÑÜÁçÜºØÆc¹çÁB¾¼N$:sÙóøÃüyéåtGÚ ûyôM¾!¡7¼1ÈÆ¯çî¯1p³tð°ö a.\¶?wF<>oéÝ¥®ü kjíMúöðÔr5õ8yøJÏ®ås1ÕÆ\Ðée¹Ür°Ósg5§ææ­çe±Æ×HÀí=úfiã=Ôò3¾©°Ñí8ÎY:xÈÂ\èX
#ÛÔxÄgú¼­-=Ëþ7þ]/ùõùÕÔk¦X×¬¿SíLg/c¹å`!Ö/{°QÅ=¸Önã¦¶½PÏ?;»©QzÖl.§g%çÚÌ7òµ¡KæÇ;Æ5Ò1ÉwéóÒ3=¶øó0Aøz?xXsF1·fÝ]ÓÎÜxö0[âØ­YöÎ0°,Ö8àå`¨còùÆ,¯tÃ2õöTÜ!!ln¸òð_Æ[Ü¸Çk×¸¥gþÜüíÍµ-[lûØª-7áÔÙÈ¹õwnùÏ^Æò±[öÎN¸,Ö8à:â¾ØÇì/Ò3Sg§ÄÙÔsükòÐÇ/nØó 8{µôOSÏ
½kÛÒ÷Úc°U¾lÍÏÇanÝ=wvrÍxÖKÇíÒå`iÙ»ä¡÷e±Æ×(Àí-þ2ýÜØ<ðNµôíª¼­6ð[;xH7øyà8Ê¸ÍÕ8Þ¶¶ÚÒ².Wù²5õ©·ówjÖüßSãÙÓr¹å`áåoÄe±Æ×Q¶À¾9·ýßýí³béFmüVsSià8ÊÆ}ªÆü/ûÅ/lé285öµkß{¹J§©×\²þNe<·,äËßÔöméa±»f¯=à:ú¾Øfñs°pWü9áyyXaK æv£oÜÓ°;uùGxÎ¥\SmÆïk×[jZZ¿Ö®¿ÌQú}í1Ù2vk.]þR#.·<àí`¸­Å_æGÞñçÞ¸a©`27~[Î<`ÍôÀ=ÏÛ¯]ïÞËÔåäÚÀ;Ên9X¸füF·kÇpËøx° ÜÖÙ'L]5·zÿý÷ïÿ}öìÙ5lü5ò¥þQÇlé²sËßÀiíz÷^¦.9([/¼½éK¿ÇíÚ1¼&ðu»\oÓÒPwÑThi­ô "qLÃ¿G³57]×¶üÒß~_»L]ò@>vÁÓ§OÏÞ¥1íé=Ö0¶,nÃKÇÏ¾¸ÖææGãsGésGæµ¯)=`ÈâÏGÚ)^*ß®yk4?àZÓfOá¬©õöã?¾·×<µl-gÈGZ·áÔØ¿ÑÛÚüÂ©·Î½­<ÂÆ}/sùå é¸iÃ¾vc<;¹´ÃÜnF6÷òÀ{ô1M·µ5·l½,ÄþØbóç6Lsgy¾q?7~ià4·ËÆñ\àåMs¡mmà=º0~scX»o=·sÕØ.[l~áÒÝFÿòñËÏðÖî_/ÞëÄÀ6Új÷­Kãç á¼-`Í/\xmð×°qÝeMà½À[nülÿÎ3(aóç6êéÏmðÏÀ»Ï
¼Û¼û_ø^à½ÀÜÂæ®	¼µkÙÔ8»mcï(ßzs·v¿z!ðn?/_î^ Í/<xm°.?;ÊËÇ/Wzíñ[OàÝgü¦Öcã8/¼é²¯uØÛæ
¼ÛÍx·a»vKCGúÐAí¾µnn³<o.ðº(eóç6ê6öëÇ.4vÛÇ0³»ÛäoÉsùØ	¼[
¼µûióç6PÎm;ýõò¿Êdì¶x÷;ËâyùþÁ¥m~áÒJèÝ6v6úëåË±ÛFàÝì,3f@i_hµÀ»zÝ6ïþcgY¼1JÛüÂ4hÔ.¢GSgÁmô·3vÛx7æúñx÷GctÕí,÷å.ycW{ìj÷¥7ScgYÜo,öR½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @IÕ;   %Uï   T½  PRõ  @Iÿ?ÐÇþði=ë    IEND®B`


function showButtons(show)


	for i, b in ipairs(entities) do	
		if b.action ~= nil then
			if show == true then
				b.visible = true
				moveEntityDirect(nil, b, UI.mousex .. "," .. UI.mousey)

			else
				b.visible = false
			end
		end
		
	end
end



function loadButtons ()

	if  line == "PLAYER ACTION BUTTONS SECTION." then
		local section = "entities"
		logFile:write("Starting to add buttons!\n")
		repeat
			line = scriptFile:read() 
			if line ~= nil then

				if line:startsWith("END PLAYER ACTION BUTTONS") then break end
				
				local words = line:split(" ")

				for i, word in ipairs(words) do
					--finding toplevel commands
					word = word:strip()
					if word == "new"  then
						--processing a new command until another toplevel command is found
						toplevel = "new"
					end
					
				end
				if toplevel == "new" then
					entityDone = loadButton(line)
				end
				
					
			end
		until line == nil
		
	end
	
end


function loadButton(line)
	
	words = line:split(" ")
	
	for i, word in ipairs(words)  do
		--first word should be new
		--logFile:write(word .. "\n")
		word = word:strip()

		if word == "new" then
			setupNewEntity()
			word = nil
		end
		
		if word ~= nil then
			word = word:strip()
			--debug.debug()
			if word:startsWith("button.") then
				word = word:gsub("%.", "|")
				entityWords = split(word, "|")
				-- print (entityWords[2])

				if entityWords[2] == "action" then
					entity.action = words[i + 2]
				end
				if entityWords[2] == "drawType" then
					entity.drawType = words[i + 2]
				end
				if entityWords[2] == "xy" then
					entity.xy = words[i + 2]
				end

				if entityWords[2] == "text" then
					entity.text = words[i + 2]
				end
				if entityWords[2] == "boxes" then
					boxWords = words[i + 2]:split(",")
					
					box = {}
					box.relativexy = boxWords[1] .. "," .. boxWords[2]

					local entityxy = split(entity.xy, ",")

					box.xy = boxWords[1] + entityxy[1] .. "," .. boxWords[2]+ entityxy[2] 

					box.box = boxWords[3] .. "," .. boxWords[4]
					table.insert(entity.boxes, box)
				end
				
			end
		end
		if word == "add" then
			addEntity()
			logFile:flush()
			return true
			
		end
		if word == "new" then
			return true
		end
	end
	return false
	
end


function addButton()

	table.insert(entities, entity)
	logFile:write("~~~button" .. table.getn(entities))
	if entity.name ~= nil then logFile:write("  " .. entity.name) end
	logFile:write("~~\n")
	logFile:write("\tdraw type: " .. entity.drawType .. "\n")
	for i, box in ipairs(entity.boxes) do
		local bxy = box.xy:split(",")
		local bwh = box.box:split(",")
		logFile:write("\tbox " .. i .. ": " .. "x " .. bxy[1] .. " y ".. bxy[2]  .. " w ".. bwh[1]  .. " h ".. bwh[2] .. "\n")
	end	
	
	logFile:write("\n------------------------------------------------------------------\n")			

end

function doButtonPress()

	for i, b in ipairs(entities) do
		if getPointingAt("action") == b.action and b.action ~= nil then 
			-- print(acteeName)
			acteeEntity = getEntity(acteeName)
			-- print(acteeEntity.name)
			local thisPath = moveToEntity(actorEntity, acteeEntity)
			action = actorEntity.name .. ' ' .. b.action .. ' ' .. acteeEntity.name	
			checkEvents(action, thisPath)
			return true
		end		
	end
	return false
end
currChatNode = nil
count = 	0
lines = {}

local theselines = {}

function initChat(id)
	chatBubble = 0

	chatTimer = timer.getTime()
	currChatNode = id
end

function countUnderscores(text)

local currcount = 0

for i in string.gfind(text, "_") do
	currcount = currcount + 1
end
return currcount

end

function initChats()

theselines.items = {}


chatnodes = {}

chatnode = {}
chatnode.id = "noItem"
chatnode.text = "guy:"
chatnode.response = "guy2: You don't have the item!!!"
chatnode.count = countUnderscores(chatnode.id)
table.insert(chatnodes, chatnode)

chatnode = {}
chatnode.id = "hasItem"
chatnode.text = "guy:"
chatnode.response = "guy2: You do have the item!!!"
chatnode.count = countUnderscores(chatnode.id)
table.insert(chatnodes, chatnode)


chatnode = {}
chatnode.id = "hi"
chatnode.text = "guy2: hi how are you"
chatnode.response = "guy: what do you want?|guy:do you want a punch in the nose?|guy2: um, no, no thanks."
chatnode.count = countUnderscores(chatnode.id)
table.insert(chatnodes, chatnode)

chatnode = {}
chatnode.id = "hi_ugly"
chatnode.text = "guy2: ugly day isn't it?"
chatnode.response = "guy: i mean yeah i guess"
chatnode.count = countUnderscores(chatnode.id)
table.insert(chatnodes, chatnode)

chatnode = {}
chatnode.id = "hi_ugly_punchguy"
chatnode.text = "guy2: i mean i could punch a guy"
chatnode.response = "guy: yeah we should punch a guy"
chatnode.count = countUnderscores(chatnode.id)

table.insert(chatnodes, chatnode)

chatnode = {}
chatnode.id = "hi_ugly_punchguy_doyouknow"
chatnode.text = "guy2: do you know a guy we can punch?"
chatnode.response = "guy: how about that guy over there?|guy: I bet we could punch him.|guy: does that sound good?"
chatnode.count = countUnderscores(chatnode.id)

table.insert(chatnodes, chatnode)

chatnode = {}
chatnode.id = "hi_ugly_punchguy_dictator"
chatnode.text = "guy2: do you know a dictator we can punch?"
chatnode.response = "guy: heil hitler!"
chatnode.count = countUnderscores(chatnode.id)

table.insert(chatnodes, chatnode)

chatnode = {}
chatnode.id = "hi_ugly_punchguy_cat"
chatnode.text = "guy2: do you know a cat we can punch?"
chatnode.response = "guy: um, mo!!!"
chatnode.count = countUnderscores(chatnode.id)

table.insert(chatnodes, chatnode)


chatnode = {}
chatnode.id = "hi_ugly_punchguy_cat_mo"
chatnode.text = "guy2: dude that's my cat.."
chatnode.response = "guy: oh.  we shouldn't hit him!!!"
chatnode.count = countUnderscores(chatnode.id)

table.insert(chatnodes, chatnode)


chatnode = {}
chatnode.id = "hi_ugly_punchguy_cat_mo_deserves"
chatnode.text = "guy2: he totally deserves it.."
chatnode.response = "guy: oh.  that's great!"
chatnode.count = countUnderscores(chatnode.id)

table.insert(chatnodes, chatnode)

chatnode = {}
chatnode.id = "hi_ugly_punchguy_dictator_hitler"
chatnode.text = "guy2: i kinda think we should punch hitler."
chatnode.response = "guy: heil hitler!?"
chatnode.count = countUnderscores(chatnode.id)

table.insert(chatnodes, chatnode)

chatnode = {}
chatnode.id = "hi_ugly_punchguy_dictator_hitler_heart"
chatnode.text = "guy2: do you <3 <3 <3 hitler?"
chatnode.response = "guy: you might be confused"
chatnode.count = countUnderscores(chatnode.id)

table.insert(chatnodes, chatnode)

chatnode = {}
chatnode.id = "hi_ugly_punchguy_doyouknow_greatidea"
chatnode.text = "guy2: that's a great idea, you first?"
chatnode.response = "guy: ok sure why not?"

chatnode.count = countUnderscores(chatnode.id)
table.insert(chatnodes, chatnode)

chatnode = {}
chatnode.id = "hi_ugly_punchgirl"
chatnode.text = "guy2: i mean i could punch a girl"
chatnode.response = "guy: I don't think I'm that mad.  wow, relax."
chatnode.count = countUnderscores(chatnode.id)
table.insert(chatnodes, chatnode)

chatnode = {}
chatnode.id = "hi_nice"
chatnode.text = "guy2: nice day isn't it?"
chatnode.response = "guy: never!!! never a nice day!!!"
chatnode.count = countUnderscores(chatnode.id)
chatnode.events = 3
table.insert(chatnodes, chatnode)

chatnode = {}
chatnode.id = "hi_nice_sunny"
chatnode.text = "guy2: what do you mean?  it's so sunny!"
chatnode.response = "guy: wtf man wtf i hate the sun so burny"
chatnode.count = countUnderscores(chatnode.id)
chatnode.events = 3
table.insert(chatnodes, chatnode)

chatnode = {}
chatnode.id = "hi_nice_shining"
chatnode.text = "guy2: what do you mean the sun is so shiny?"
chatnode.response = "guy: it isn't the sun, that's actually hell moon"
chatnode.count = countUnderscores(chatnode.id)
chatnode.events = 3
table.insert(chatnodes, chatnode)

chatnode = {}
chatnode.id = "hi_nice_shining_hellmoon"
chatnode.text = "guy2: hell moon?  you're making stuff up now."
chatnode.response = "guy: no seriously, I read it  in american scientist.  hell mean is totes real."
chatnode.count = countUnderscores(chatnode.id)
chatnode.events = 3
table.insert(chatnodes, chatnode)

end

function testChatNodes()
	
	--startChatNode("hi", 0)
end


function setupChat()

	if currChatNode ~= nil then
		lines = {}
		thisChatIDs = {}
		optionsCount =  0
		theselines.value = 1
		for i, cn in ipairs(chatnodes) do
			if (cn.id:startsWith(currChatNode) and cn.count <= count + 1) then
				if cn.id == currChatNode then
					line = {}
					line.text = cn.text
					line.response = cn.response
					if cn.events ~= nil then
						checkChatEvent(cn.events)
					end 
					table.insert(lines, line)
				else
					segs = cn.id:split("_")
					line = {}
					line.text = cn.text
					line.id = segs[cn.count + 1]
					optionsCount = optionsCount + 1
					line.optionNum = optionsCount
					table.insert(lines, line) 
				end
			end
		end
			chatBubble = 1
			if lines[1].response ~= nil then
				if lines[1].response:includes("|", true) then
					chatResponses = lines[1].response:split("|")
				else
					chatResponses = {}
					table.insert(chatResponses, lines[1].response)
				end
			end
			chatTimer = timer.getTime()
		 if #lines <= 1 then
		 currChatNode = nil
		 end
	end
	
end

function drawChat ()
	if currChatNode ~= nil then
		theselines.items = {}
		theselines.text = {}
		theselines.value = 1

		local labelWords = ""
		table.insert(theselines.items, "Select One")
		for i, line in ipairs(lines) do
			if i > 1 then
				table.insert(theselines.items, line.id)
				labelWords = labelWords .. line.text .. "\n"
			end
		end
		if nk.windowBegin('Chat window', 300, 100, 300, 200,
				'border', 'title', 'movable') then
			nk.layoutRow('dynamic', 100, 1)
			nk.label(labelWords, "top left")
			nk.layoutRow('dynamic', 30, 2)
			if nk.combobox(theselines, theselines.items,40,200) then
				currChatNode = currChatNode .. "_" .. theselines.items[theselines.value]
				count = count + 1
				setupChat()
			end

		end
		nk.windowEnd()
	end
	bubbleTimer()
end


function drawBubbles()

	-- chatBubble 1 = the line the player picked (line.text)
	-- 2 - x = split line.response on ".", each sentence is a bubble,
	-- on each sentence, split on ":" and the entity will be index 1 and
	-- the sentence will be index 2.
	
	if lines[1] ~= nil then
		if chatBubble == 1 then
			local line = lines[1]
			local words = line.text:split(":")
			entity = getEntity(words[1])
			local thisXY = entity.xy:split(",")
			love.graphics.setColor(255,0,0,255)
			love.graphics.rectangle("fill", thisXY[1],thisXY[2], 200, 30,10,10,20)
			love.graphics.setColor(0,0,0,255)
			love.graphics.printf(line.text, thisXY[1], thisXY[2],200, "center")
			love.graphics.setColor(255,255,255,255)
		end 
		if chatBubble >= 2 and chatResponses [chatBubble - 1] ~= nil then 
			local line = chatResponses[chatBubble - 1]
			if line ~= nil then
				local words = line:split(":")
				entity = getEntity(words[1])
				local thisXY = entity.xy:split(",")
				love.graphics.setColor(255,0,0,255)
				love.graphics.rectangle("fill", thisXY[1],thisXY[2], 200, 30,10,10,20)
				love.graphics.setColor(0,0,0,255)
				love.graphics.printf(line, thisXY[1], thisXY[2],200, "center")
				love.graphics.setColor(255,255,255,255)
				end		
		end
	end
end

function bubbleTimer()
	if chatTimer < timer.getTime() - 2 then
		chatBubble = chatBubble + 1
		chatTimer = timer.getTime()
	end
endPNG

   IHDR     X   ­¨rB   sRGB ®Îé   gAMA  ±üa   PLTE      $$$(((,,,000444888<<<@@@DDDHHHLLLPPPTTTXXX\\\```dddhhhlllppptttxxx|||£££§§§«««¯¯¯³³³···»»»¿¿¿ÃÃÃÇÇÇËËËÏÏÏÓÓÓ×××ÛÛÛßßßãããçççëëëïïïóóó÷÷÷ûûûÿÿÿ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ÅÐsR   	pHYs  Ã  ÃÇo¨d   tEXtSoftware paint.net 4.0.5e2e  IDATx^íÛëBÚÌá VEÇR¥h)Ú¢VÈaîÿªöIÕÕî/­Òø>?d Ù|æe&èg  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A ÏÛÿy¥ªtdL<q?EßÝ;j¥c®êéÀñânX6ò¼úô¤óó{QÄÓQÝOk<6U?HÆt«éÀôª³!<oH¿ÖXÿ)Ñ´Y «Ü°õÔYÿT £=YvËÈêc:2é'ók©·n[y9ýoI+í;Éá4ÙfZÓ3>º­¯2ø'­LéÆwí]=vNc/áiûVç#×ÊùµüøÑ±°t-ÞlÁr¿9¾úftÕÜLá9ªÍæ{WdÙÚÚ-'Ãl ÕF´_Ù±)ë{Q%Èêzc'´I%ÉÑühÈXB/Èï\ôÎ9_Ýõ@jfPvSdX9ùMWV@ÆtB{¥V«Uªµ{;­hdîW3Æì­»¡ä&¸5£Ò½¥óüÎEoo¶`é»VzöÄyl?ÿ%Ò_ä^o²6J^úE¸reoÍ¥»Úvìª½éÐ´*½^OUùßÄòøÎ¡<¸xòÕøär¤Ö4çå±aé¼F O^ô¦zvÁäã¹(ÉGöYä¶½4÷z÷3ôKáì{ÙÌb«È2]bÉÿÆéÌqUô2´£IÃF%ô²(½©^ðÑÏ%;c¸@Æ+_ÙÇ^AÝþg×Ý;	dww£ao­L ò6úöÇ3lÛ=·2T&vén×~xU²êXB/vÑrU<7Ó¡9Ú³ïÛöÒêawÒµ/¥o6ã¹*÷odåR»5jÒr|\ËKnEö7ó@>n'íPv?I®ÁºÁîc¼v$×4ñiÛk½NÇ2zÑ@´Þ«ÂVÓ@nþÙ;·éÅÕOjAùÌ¾ëpÉK?Òáôëè8èê­ávë3w;0kìÌÒ3ãý Üÿ(TuTwë0¶%ºÛQ¹Ü%ô²K,ûÃ}ò&KÙEï\¤së,I ¦vºå._Ã$ùÛ_þâ/Fî;Ay¶Ì~ÙãÜÚ7¥ôâ<wÑ{!k!é£÷2eã·`1íjP¿Xj>{%u´°t^4í¢÷@Vñâ:Ëú½Nnýa/ m·åwóìl´~°t^4å¢w²6û[áü¯c­QùK:^Ü¢\ôvç¾ ë¾ó^ÅK¢]ôÞû­_/èeþ1(P  @ñ*¸¯y"}O(&É+}O(¦W
$üû¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8ÉçÕßÊþçt`nÇéègê M~<¸ÛXôÝhî¨¹ª§3ºyLGoäóêo¥Ôwï`å<ÿ,âdðy56d|XÃäÁ©úA:0¦[Mn'¥ Ø$wÞ"Égié'ûå9d4-`H³gâh×Vç@æ[8¥ÞÉg	¹muÒEPO2hßI§É}ÓñqðÐm}MïÈòiH7¾kwF2xìÆ^ ÃÓömz§Ú2ç×rû£s*û^}O~ÞP ¿X­Ï7÷Åü¢×d3:jÉLqÍQul6?¸»^ [[»åãäN#3TÑ~eÇ^¤¬ïEL «ë0Mjå³9ZÛÆÎ°Ò4wáMòððùÅj}ºù~#ÊÏ.æ½~ µG3('SF}OÖD/Ñte	¤iL'tWêqél	«ÕjG©ÜÄÓFæ~5HxiÌÞº_¬ÌMpkF¥sÞm¹Gß7È«õùæÓ±\þî77¯}ÙÉÚè¬b_õE¸reïKw´íØ]Çò³Uéõzò¬dcÏìØ¯A¾º7÷°j?.jMsnÚÎêêÂ¥}±½©@ÕºÝ|÷iºù.èÚv|ù«ÕÄr²oÏìË÷bû¥pöõmf±é6Éîýl-±Ò@29.}sÚGû@;4lD§Á½ûf¼¥@´ÕºÝ\9¨EÉ¯¾è|Ú/Üýç½~ öô]¥äaww£á"|ôåÇd79lÛ=·2T&Æ¯Ú>dÝ&úáUI.Ôû+­Òo¯?à-¢­Öíæ¾­ºy/­Ç² ¿úy%¶àõ	»npc¾§qå%÷odåR»5j2×Tnd·\sØßÎù\º´CÙý$ù®¢ì>ÆkGfTÛzH~£¸Sq×é[æ¤òÖXo)ù*baµî¸Í»îãò¢,§Î}ðÃìÍ?RñúÔò¼rwÁq8äà(J»¦KFi S
ª·öõZ×æÌÝÌÌ}	d¼ûåíVí:JÙ:m{oòÈE è*¼3ãª[s½o-çVëéæ:d±b/fÍæñ¨ôËoü_=¹ª	á7ÿ°dÁÐþ6D¦Xûg0­+q$£òÆ¼¥@´Õzºy[>?/KîNt¹f	ù£ÏÎGoëâ|ê-òôj}ø>ù±lËbã[ºÙK¿±(Z 7ÏÎFëoêÚ|æ-òôj=ù¤~¼dE~ä6ÛØ\üJÑÁ7È3«õ³w³oªbÿ;«æ»t  {S<e=7MLÒï|URpo>á³Ë¨ëÚ/¾÷±¤àÞ| 9HÁH>RpøÜw¼E¾/üGâKO«âHßþ#ñý¿/mÉÏ@É@|øñ<â#xÄG ð@à!ÀC >@|øñ<â#xÄG ð@à!ÀC >@|øñ<â#xÄG ð@à!ÀC >@|øñ<â#xÄG ð@à!ÀC >@|øñ<â#xÄG ð@à!ÀC >@|øñ<â#xÄG ð@ày¥@
$}OË@ò"¼Ò÷´$/ ¯`gäÅô<@ÀÃô<@ÀÃô<@ÀÃô<ï îNÆ<ÒAFvó0<á§gyÅØ=0óý]:È@àù{°ÞJãp:Ìm´Âtøìnv8p¿½î&MuÿÜ» xþ~ ýZc]	d¸¾³þs ýôv¶Û@v³Ã8è%d½B ¿Sê É+¸böæRGóÃsUOò¹²¸[Fg;3rÿq»{$¯¿Èm«ó(çú·ä,oßÉéqlõÖÝ'»yøÕÔ%Q[Ææò&ÙÏ^ÖìYd·l ·W£}Fc¾¶¾¿B ÓpSq0=oãºº	paIißª[M¦WÖmû¹á<kåÂ=xHäõÙ¢;ÜÙtTÍö®Sß¬Ô"÷ñgOIôIN¶rúo	dáY¦´Öß½ß*?ÈÓ®ì­¯½^ OÎ£i³@.V?¸áüÌÎx*ÑÞÏ»¦×^³§ùPÝqCy9ÍýIµ©@òúÔÍ ì¦w6+'_¢ùgg½Ö7£Õ¶Úäx]åôÈRxÏjuGNðÒLª-¹ÿÍL¯2?¶¦g|<t[_eð-NZÙÝø®Ý±K³ÇÎiì2<mßÊà|äZ9¿?:vX^{µf»g´¯!ìÎßÛ§2÷µîÜ#¼þb ö¼IþíÝÐ\+öß,åÛÝsC»Ó}ðÃì%gJèÖ!57Nv?Kõzrj¸óBþç¹}%6?fÙÚÚ-'Ãl ÕF´_ÎÕõ½¨2Ý]ÞÉêzc'´I%ÉÑühÈNuìV¿»á,²»·z´¶Mç]åÀþg	$¯¿ÈþüÔ6ýR¹ît¸ú¤¢ÍãQÉýì5üÈ<ËlòÉÞ¾F Úü	¤)WÔ¡]H¦ÕjU&ªL=y¤Ìýj&ÍL¦i 7Á­¦ó@Bù¨ÙÝrÃ$j}#89¸$«Î³Ò%Öòù(?Öí4ÝÝ½M¸ÍÛnèNNtÙ[+ÈÂ³,r^ÊWÄ¾ä'ïn6?^ºù/pGWÅÈ½ä4J¯×,Ý[Ù± yÇUñÕ½är¤Ö·èÉóº/&Ü»ÿRM½ÑíìËÌóÑ~âôe­E Èß;õ°;é²îÇÍx$ýàÊßÛµ³Û<>·§lÞÍfXªº¬L Ïq,·Ó@KÇÛèÏ½ÿ+çæÇÌb«ÈâNçy ÎWEÏ½$v4i¸Ok>ØmÉ¼bgwÃìËíD@þ¿w ë'µ |fÏëpÉzä(Ç[aúñFPú$]¸ÍvjÙ«ÔÄLNý¸ævKEp·móÉ.ÎítQjî]üv 37?fü¾ûÔ:m»çV&ÊD®¼WÝÐíÚ¯JöÚÛbçÚS·[&fÕ4íêìGð`ÚöaÉíoÀIò»1ßÙ»Ùß,üÅHóé?,þaÉÉüwqÀoòôüÈR»5jöy×ÁµÒìo
ç|.ÝNÚö/	N_<vÝÇxíH>7âÓ(¶ïl§b?
ó@qU®oqÓíVoÆñÕÊG¹féNwdö8ö@òzé8fÓÄIòï+ûí@Ãé/$â S
ªöK7·[Ï¹ÛYI±/÷ÇûA¸ÿQ©&ë¨î\jlÛ3Þí(\nrf¿ùTÝ².}g÷k÷r}Ï£N9ÞËÿ~XìdB y½ô>×¹®)[ñb~ÿzr~üÙðïjèþPeP­£_÷[Y/=ÅMO±×sîÖÖD yq }¯tF5gßO,:r_æþWÐ÷JgÔÍ³³Ñúy:øO$/ ¯`gäÅô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃôE¾/üG@_zZGú¾ðq  
(P  @A @  
(P  bØÿÌÃí8ýlP¤£Éw¾ÍµÒ1Wõt`F7éè	ít`×n·q»»ÿ>)zzRß½ódü³8HÏÛÏ«A°!ãS÷ÿ&NÕÒ1Ýjr;9,ÁÞ$¹ó³VºÛø CÙmGµr<è<ôÒÁ¿@aH÷l<Ù//Ì!£i³@=G»ó3ÛóD ÃÃó-ÍR©Áô¿3}ÁÑÀ\Ò§¼Çf)3ç´fSÑ?@¡ÞºmuÒ²'´ï$Óä¾iMÏø8xè¶¾¦wäÙÝø®ÝÉà±s{OÛ·éjË_ËíNrß¬uÓAka7×kØ¿·Ooä%5jÝ«dó?¦Hüb>ßÜWé?ïö+«ïeQß¢Z2S\CsTÍî®ÈÖÖnù8¹ÓÈÌ ÕF´_Ù±)ë{Q%Èêzc'LZùlÖä¶!;:ÕY ²[=üîÆ/I e9n{«G{aÛtÞUÒÿì?¦Hüb>Ý|¿ågéógÝì³ì*½\Ò&¾/áh½öhådÊ¨ïÉ¨rò%®¬24å:tWêqél	«ÕªLÕÚÀM<­hdîW3r¯»ñÅÊÀÜ·fT^\Ì	ezØÝrã/+ÒE½Zß°K­«¸³Ò%Ö2ÚO®Ãç/NÇrÍ¹8+Ì¾ÊÉ>Ë<KôÌÝúìka×ËÆ½êdmtV±ïí"\IÖ46ð hÛ±»ÉëéÍCùÙªôz=yÌ¾%ûFwì× _ÝIò°j?TjMsÚÃäye)'OcwûR²Ã{÷ÑTot;û2ó|´M_ÖZ²Ôu¸Ý|÷iºù.èÚv|)d+Åg±çMrÎÝîj£ëNeâÙ·göå{KýR8k>3ØÉÏ¾¡Éî=ÍgK¬4Lg¤gÍ öÑ>Ð&3Aìn]·[ÅíægwÃìËíD@º·+µ(ùEÀ÷àa}ÏÑrº\È²ð,ö¼¼UK\Ûhn¬Þò»¥»à¬Ûór]~\+ÝÝL Rv_~Lvw¸È¶Ýs+HebÌùªíCèW%{ííÌäÇif7H³jvuö#x0í÷ø¿§Phëp»¹oF«n©aÞËÔ,ÿxWÓX&Yg%ÞÕ×*²Þ¯OÌdSþK¹Ä
»npc¾§qåõoiÆ@j÷£FMÞKåFvÈmS8äsévÒe÷ä«n°û¯Qmë!ùâNÅ^§'æãjÓÝnòToÆñÕÊG¹féNwdö8óI¡±'îëp'öÝ'ÜEYNûàÙKNÐ-§åÄÉnógãîézu`V¿ÈCÊrRÊgòÂÝ;9ERøQÖ?LWò^:¥ z+ÿìÎµ9s·³&³i_ïáþGyóÕdÕÝKm{oòÈE0÷³ß|ªËnQz½#»½è£Ì>r¼bµ ¹Ôÿ×.çÖáéæ{ÕxYr¿×Ý<¯&í©~zw2ÛÆ~+cºååDVú2!üáâ,ÚßÈ:[G¦u%ne½ôg'Ø=¡ÜNkú·*mnÞOÆËÒ¥{ Ûµ³	dáY\ f¥e*ò)kN6©-e TÓ'%_æ¾
äéuøð}ò;^Ù<>³ý[ºÙKÕÙy	$}énqpÇ'á­iV~ëYvoïÿÍõôï»yv6Z·óèR¨@^ÇA2Ô7ÌGn³]CíÉUHjb¿ÿtêÇ5·Û¾ÛíÐ<Úy¡<oùDÎ«R`'¼E
äuøÙ»ÙêwaÜ||çË£´¢Ñ/Öñ(bòq4&LÒï|g?ás}ë3~¡ø 9  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A À³ùEûv    IEND®B`PNG

   IHDR     X   ­¨rB   sRGB ®Îé   gAMA  ±üa   PLTE      $$$(((,,,000444888<<<@@@DDDHHHLLLPPPTTTXXX\\\```dddhhhlllppptttxxx|||£££§§§«««¯¯¯³³³···»»»¿¿¿ÃÃÃÇÇÇËËËÏÏÏÓÓÓ×××ÛÛÛßßßãããçççëëëïïïóóó÷÷÷ûûûÿÿÿ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ÅÐsR   	pHYs  Ã  ÃÇo¨d   tEXtSoftware paint.net 4.0.5e2e  IDATx^íÛëBÚÌá VEÇR¥h)Ú¢VÈaîÿªöIÕÕî/­Òø>?d Ù|æe&èg  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A ÏÛÿy¥ªtdL<q?EßÝ;j¥c®êéÀñânX6ò¼úô¤óó{QÄÓQÝOk<6U?HÆt«éÀôª³!<oH¿ÖXÿ)Ñ´Y «Ü°õÔYÿT £=YvËÈêc:2é'ók©·n[y9ýoI+í;Éá4ÙfZÓ3>º­¯2ø'­LéÆwí]=vNc/áiûVç#×ÊùµüøÑ±°t-ÞlÁr¿9¾úftÕÜLá9ªÍæ{WdÙÚÚ-'Ãl ÕF´_Ù±)ë{Q%Èêzc'´I%ÉÑühÈXB/Èï\ôÎ9_Ýõ@jfPvSdX9ùMWV@ÆtB{¥V«Uªµ{;­hdîW3Æì­»¡ä&¸5£Ò½¥óüÎEoo¶`é»VzöÄyl?ÿ%Ò_ä^o²6J^úE¸reoÍ¥»Úvìª½éÐ´*½^OUùßÄòøÎ¡<¸xòÕøär¤Ö4çå±aé¼F O^ô¦zvÁäã¹(ÉGöYä¶½4÷z÷3ôKáì{ÙÌb«È2]bÉÿÆéÌqUô2´£IÃF%ô²(½©^ðÑÏ%;c¸@Æ+_ÙÇ^AÝþg×Ý;	dww£ao­L ò6úöÇ3lÛ=·2T&vén×~xU²êXB/vÑrU<7Ó¡9Ú³ïÛöÒêawÒµ/¥o6ã¹*÷odåR»5jÒr|\ËKnEö7ó@>n'íPv?I®ÁºÁîc¼v$×4ñiÛk½NÇ2zÑ@´Þ«ÂVÓ@nþÙ;·éÅÕOjAùÌ¾ëpÉK?Òáôëè8èê­ávë3w;0kìÌÒ3ãý Üÿ(TuTwë0¶%ºÛQ¹Ü%ô²K,ûÃ}ò&KÙEï\¤së,I ¦vºå._Ã$ùÛ_þâ/Fî;Ay¶Ì~ÙãÜÚ7¥ôâ<wÑ{!k!é£÷2eã·`1íjP¿Xj>{%u´°t^4í¢÷@Vñâ:Ëú½Nnýa/ m·åwóìl´~°t^4å¢w²6û[áü¯c­QùK:^Ü¢\ôvç¾ ë¾ó^ÅK¢]ôÞû­_/èeþ1(P  @ñ*¸¯y"}O(&É+}O(¦W
$üû¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8É@
@ò!#|¤à$)8ÉçÕßÊþçt`nÇéègê M~<¸ÛXôÝhî¨¹ª§3ºyLGoäóêo¥Ôwï`å<ÿ,âdðy56d|XÃäÁ©úA:0¦[Mn'¥ Ø$wÞ"Égié'ûå9d4-`H³gâh×Vç@æ[8¥ÞÉg	¹muÒEPO2hßI§É}ÓñqðÐm}MïÈòiH7¾kwF2xìÆ^ ÃÓömz§Ú2ç×rû£s*û^}O~ÞP ¿X­Ï7÷Åü¢×d3:jÉLqÍQul6?¸»^ [[»åãäN#3TÑ~eÇ^¤¬ïEL «ë0Mjå³9ZÛÆÎ°Ò4wáMòððùÅj}ºù~#ÊÏ.æ½~ µG3('SF}OÖD/Ñte	¤iL'tWêqél	«ÕjG©ÜÄÓFæ~5HxiÌÞº_¬ÌMpkF¥sÞm¹Gß7È«õùæÓ±\þî77¯}ÙÉÚè¬b_õE¸reïKw´íØ]Çò³Uéõzò¬dcÏìØ¯A¾º7÷°j?.jMsnÚÎêêÂ¥}±½©@ÕºÝ|÷iºù.èÚv|ù«ÕÄr²oÏìË÷bû¥pöõmf±é6Éîýl-±Ò@29.}sÚGû@;4lD§Á½ûf¼¥@´ÕºÝ\9¨EÉ¯¾è|Ú/Üýç½~ öô]¥äaww£á"|ôåÇd79lÛ=·2T&Æ¯Ú>dÝ&úáUI.Ôû+­Òo¯?à-¢­Öíæ¾­ºy/­Ç² ¿úy%¶àõ	»npc¾§qå%÷odåR»5j2×Tnd·\sØßÎù\º´CÙý$ù®¢ì>ÆkGfTÛzH~£¸Sq×é[æ¤òÖXo)ù*baµî¸Í»îãò¢,§Î}ðÃìÍ?RñúÔò¼rwÁq8äà(J»¦KFi S
ª·öõZ×æÌÝÌÌ}	d¼ûåíVí:JÙ:m{oòÈE è*¼3ãª[s½o-çVëéæ:d±b/fÍæñ¨ôËoü_=¹ª	á7ÿ°dÁÐþ6D¦Xûg0­+q$£òÆ¼¥@´Õzºy[>?/KîNt¹f	ù£ÏÎGoëâ|ê-òôj}ø>ù±lËbã[ºÙK¿±(Z 7ÏÎFëoêÚ|æ-òôj=ù¤~¼dE~ä6ÛØ\üJÑÁ7È3«õ³w³oªbÿ;«æ»t  {S<e=7MLÒï|URpo>á³Ë¨ëÚ/¾÷±¤àÞ| 9HÁH>RpøÜw¼E¾/üGâKO«âHßþ#ñý¿/mÉÏ@É@|øñ<â#xÄG ð@à!ÀC >@|øñ<â#xÄG ð@à!ÀC >@|øñ<â#xÄG ð@à!ÀC >@|øñ<â#xÄG ð@à!ÀC >@|øñ<â#xÄG ð@à!ÀC >@|øñ<â#xÄG ð@ày¥@
$}OË@ò"¼Ò÷´$/ ¯`gäÅô<@ÀÃô<@ÀÃô<@ÀÃô<ï îNÆ<ÒAFvó0<á§gyÅØ=0óý]:È@àù{°ÞJãp:Ìm´Âtøìnv8p¿½î&MuÿÜ» xþ~ ýZc]	d¸¾³þs ýôv¶Û@v³Ã8è%d½B ¿Sê É+¸böæRGóÃsUOò¹²¸[Fg;3rÿq»{$¯¿Èm«ó(çú·ä,oßÉéqlõÖÝ'»yøÕÔ%Q[Ææò&ÙÏ^ÖìYd·l ·W£}Fc¾¶¾¿B ÓpSq0=oãºº	paIißª[M¦WÖmû¹á<kåÂ=xHäõÙ¢;ÜÙtTÍö®Sß¬Ô"÷ñgOIôIN¶rúo	dáY¦´Öß½ß*?ÈÓ®ì­¯½^ OÎ£i³@.V?¸áüÌÎx*ÑÞÏ»¦×^³§ùPÝqCy9ÍýIµ©@òúÔÍ ì¦w6+'_¢ùgg½Ö7£Õ¶Úäx]åôÈRxÏjuGNðÒLª-¹ÿÍL¯2?¶¦g|<t[_eð-NZÙÝø®Ý±K³ÇÎiì2<mßÊà|äZ9¿?:vX^{µf»g´¯!ìÎßÛ§2÷µîÜ#¼þb ö¼IþíÝÐ\+öß,åÛÝsC»Ó}ðÃì%gJèÖ!57Nv?Kõzrj¸óBþç¹}%6?fÙÚÚ-'Ãl ÕF´_ÎÕõ½¨2Ý]ÞÉêzc'´I%ÉÑühÈNuìV¿»á,²»·z´¶Mç]åÀþg	$¯¿ÈþüÔ6ýR¹ît¸ú¤¢ÍãQÉýì5üÈ<ËlòÉÞ¾F Úü	¤)WÔ¡]H¦ÕjU&ªL=y¤Ìýj&ÍL¦i 7Á­¦ó@Bù¨ÙÝrÃ$j}#89¸$«Î³Ò%Öòù(?Öí4ÝÝ½M¸ÍÛnèNNtÙ[+ÈÂ³,r^ÊWÄ¾ä'ïn6?^ºù/pGWÅÈ½ä4J¯×,Ý[Ù± yÇUñÕ½är¤Ö·èÉóº/&Ü»ÿRM½ÑíìËÌóÑ~âôe­E Èß;õ°;é²îÇÍx$ýàÊßÛµ³Û<>·§lÞÍfXªº¬L Ïq,·Ó@KÇÛèÏ½ÿ+çæÇÌb«ÈâNçy ÎWEÏ½$v4i¸Ok>ØmÉ¼bgwÃìËíD@þ¿w ë'µ |fÏëpÉzä(Ç[aúñFPú$]¸ÍvjÙ«ÔÄLNý¸ævKEp·móÉ.ÎítQjî]üv 37?fü¾ûÔ:m»çV&ÊD®¼WÝÐíÚ¯JöÚÛbçÚS·[&fÕ4íêìGð`ÚöaÉíoÀIò»1ßÙ»Ùß,üÅHóé?,þaÉÉüwqÀoòôüÈR»5jöy×ÁµÒìo
ç|.ÝNÚö/	N_<vÝÇxíH>7âÓ(¶ïl§b?
ó@qU®oqÓíVoÆñÕÊG¹féNwdö8ö@òzé8fÓÄIòï+ûí@Ãé/$â S
ªöK7·[Ï¹ÛYI±/÷ÇûA¸ÿQ©&ë¨î\jlÛ3Þí(\nrf¿ùTÝ².}g÷k÷r}Ï£N9ÞËÿ~XìdB y½ô>×¹®)[ñb~ÿzr~üÙðïjèþPeP­£_÷[Y/=ÅMO±×sîÖÖD yq }¯tF5gßO,:r_æþWÐ÷JgÔÍ³³Ñúy:øO$/ ¯`gäÅô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃô<@ÀÃôE¾/üG@_zZGú¾ðq  
(P  @A @  
(P  bØÿÌÃí8ýlP¤£Éw¾ÍµÒ1Wõt`F7éè	ít`×n·q»»ÿ>)zzRß½ódü³8HÏÛÏ«A°!ãS÷ÿ&NÕÒ1Ýjr;9,ÁÞ$¹ó³VºÛø CÙmGµr<è<ôÒÁ¿@aH÷l<Ù//Ì!£i³@=G»ó3ÛóD ÃÃó-ÍR©Áô¿3}ÁÑÀ\Ò§¼Çf)3ç´fSÑ?@¡ÞºmuÒ²'´ï$Óä¾iMÏø8xè¶¾¦wäÙÝø®ÝÉà±s{OÛ·éjË_ËíNrß¬uÓAka7×kØ¿·Ooä%5jÝ«dó?¦Hüb>ßÜWé?ïö+«ïeQß¢Z2S\CsTÍî®ÈÖÖnù8¹ÓÈÌ ÕF´_Ù±)ë{Q%Èêzc'LZùlÖä¶!;:ÕY ²[=üîÆ/I e9n{«G{aÛtÞUÒÿì?¦Hüb>Ý|¿ågéógÝì³ì*½\Ò&¾/áh½öhådÊ¨ïÉ¨rò%®¬24å:tWêqél	«ÕªLÕÚÀM<­hdîW3r¯»ñÅÊÀÜ·fT^\Ì	ezØÝrã/+ÒE½Zß°K­«¸³Ò%Ö2ÚO®Ãç/NÇrÍ¹8+Ì¾ÊÉ>Ë<KôÌÝúìka×ËÆ½êdmtV±ïí"\IÖ46ð hÛ±»ÉëéÍCùÙªôz=yÌ¾%ûFwì× _ÝIò°j?TjMsÚÃäye)'OcwûR²Ã{÷ÑTot;û2ó|´M_ÖZ²Ôu¸Ý|÷iºù.èÚv|)d+Åg±çMrÎÝîj£ëNeâÙ·göå{KýR8k>3ØÉÏ¾¡Éî=ÍgK¬4Lg¤gÍ öÑ>Ð&3Aìn]·[ÅíægwÃìËíD@º·+µ(ùEÀ÷àa}ÏÑrº\È²ð,ö¼¼UK\Ûhn¬Þò»¥»à¬Ûór]~\+ÝÝL Rv_~Lvw¸È¶Ýs+HebÌùªíCèW%{ííÌäÇif7H³jvuö#x0í÷ø¿§Phëp»¹oF«n©aÞËÔ,ÿxWÓX&Yg%ÞÕ×*²Þ¯OÌdSþK¹Ä
»npc¾§qåõoiÆ@j÷£FMÞKåFvÈmS8äsévÒe÷ä«n°û¯Qmë!ùâNÅ^§'æãjÓÝnòToÆñÕÊG¹féNwdö8óI¡±'îëp'öÝ'ÜEYNûàÙKNÐ-§åÄÉnógãîézu`V¿ÈCÊrRÊgòÂÝ;9ERøQÖ?LWò^:¥ z+ÿìÎµ9s·³&³i_ïáþGyóÕdÕÝKm{oòÈE0÷³ß|ªËnQz½#»½è£Ì>r¼bµ ¹Ôÿ×.çÖáéæ{ÕxYr¿×Ý<¯&í©~zw2ÛÆ~+cºååDVú2!üáâ,ÚßÈ:[G¦u%ne½ôg'Ø=¡ÜNkú·*mnÞOÆËÒ¥{ Ûµ³	dáY\ f¥e*ò)kN6©-e TÓ'%_æ¾
äéuøð}ò;^Ù<>³ý[ºÙKÕÙy	$}énqpÇ'á­iV~ëYvoïÿÍõôï»yv6Z·óèR¨@^ÇA2Ô7ÌGn³]CíÉUHjb¿ÿtêÇ5·Û¾ÛíÐ<Úy¡<oùDÎ«R`'¼E
äuøÙ»ÙêwaÜ||çË£´¢Ñ/Öñ(bòq4&LÒï|g?ás}ë3~¡ø 9  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A @  
(P  @A À³ùEûv    IEND®B`function love.conf(t)
    -- require("cupid");
    t.title = "groupthink"        		-- The title of the window the game is in (string)
    t.author = "/u/daveyeah"  	-- The author of the game (string)
    t.identity = "adventureplusplus"            	-- The name of the save directory (string)    
    t.console = true	-- Attach a console (boolean, Windows only)
    --t.screen.width = 1600        	-- The window width (number)
    -- t.screen.height = 900      		-- The window height (number)
    -- t.screen.fullscreen = false 	-- Enable fullscreen (boolean)
    -- t.screen.vsync = true       	-- Enable vertical sync (boolean)
    -- t.screen.fsaa = 10           	-- The number of FSAA-buffers (number)
    t.modules.joystick = true   	-- Enable the joystick module (boolean)
    t.modules.audio = true      	-- Enable the audio module (boolean)
    t.modules.keyboard = true   	-- Enable the keyboard module (boolean)
    t.modules.event = true      	-- Enable the event module (boolean)
    t.modules.image = true      	-- Enable the image module (boolean)
    t.modules.graphics = true   	-- Enable the graphics module (boolean)
    t.modules.timer = true      	-- Enable the timer module (boolean)
    t.modules.mouse = true      	-- Enable the mouse module (boolean)
    t.modules.sound = true      	-- Enable the sound module (boolean)
    t.modules.physics = false    	-- Enable the physics module (boolean)
    t.modules.thread = true   
end
function initEntities ()

	entities = {}


	entity = {}
	entity.name = "square2"
	entity.boxes = {}
	box = {}
	box.xy = "280,140"
	box.box = "100,100"
	table.insert(entity.boxes, box)
	entity.xy = "200,200"
	entity.drawType = "anim8"
	entity.animate = anim8.newAnimation(g('2-7',2), 0.10)
	entity.zCalc = true
	entity.z = 160
	entity.visible = false
	table.insert(entities, entity)	
	
end


function loadEntities ()

	if  line == "ENTITIES SECTION." then
		local section = "entities"
		logFile:write("Starting to add entities!\n")
		repeat
			line = scriptFile:read() 
			if line ~= nil then

				if line:startsWith("END ENTITIES") then break end
				
				local words = line:split(" ")

				for i, word in ipairs(words) do
					--finding toplevel commands
					word = word:strip()
					if word == "new"  then
						--processing a new command until another toplevel command is found
						toplevel = "new"
					end
					
				end
				if toplevel == "new" then
					entityDone = loadEntity(line)
				end
				
					
			end
		until line == nil
		
	end
	
end


function loadEntity(line)
	
	words = line:split(",")
	
	for i, word in ipairs(words)  do
		--first word should be new
		--logFile:write(word .. "\n")
		word = word:strip()

		if word == "new" then
			setupNewEntity()
			word = nil
		end
		
		if word ~= nil then
			word = word:strip()
			--debug.debug()
			if word:startsWith("entity.") then
				word = word:gsub("%.", "|")
				entityWords = split(word, "|")

				if entityWords[2] == "name" then
					entity.name = words[i + 2]
				end
				if entityWords[2] == "drawType" then
					entity.drawType = words[i + 2]
				end
				if entityWords[2] == "zCalc" then
					entity.drawType = words[i + 2]
				end
				if entityWords[2] == "box" then
					box = {}
					box.xy = boxWords[1] .. "," .. boxWords[2]
					box.box = boxWords[3] .. "," .. boxWords[4]
					table.insert(entity.boxes, box)
				end
				
			end
		end
		if word == "add" then
			addentity()
			logFile:flush()
			return true
			
		end
		if word == "new" then
			return true
		end
	end
	return false

	
end


function setupNewEntity ()

	entity = {}
	
	entity.name = "none"
	entity.boxes = {}	
	entity.drawType = "lovedraw"
	entity.zCalc = false
	entity.z = 0
	entity.visible = false
	table.insert(entities, entity)

end

function checkPointingAt(entity)

	for i, box in ipairs(entity.boxes) do
		xy = split(box.xy, ",")
		boxx = tonumber(xy[1])
		boxy = tonumber(xy[2])
		boxbox = split(box.box, ",")
		width = tonumber(boxbox[1])
		height = tonumber(boxbox[2])
		boxEnd = boxx + width
		boxBottom = boxy + height

		if (UI.mousex > boxx) and (UI.mousex < boxEnd) and (UI.mousey > boxy) and (UI.mousey < boxBottom) then
			return true

		end
	end
	return false	
end

function getEntity(name)

	for i, entity  in ipairs (entities) do
	
		if entity.name == name then
			return entity
		end
	end
	
	return "none"

end


function moveEntityTo(name, xy)
	entity = getEntity(name)
	--local box = split(entity.boxes[1].box, ",")
	--local xy = split(entity.boxes[1].xy, ",")
	--entity.boxes[1].xy = (tonumber(xy[1])- tonumber(box[1] / 2)) .. (tonumber(xy[2]) - tonumber(box[2] / 2))
	entity.boxes[1].xy = xy
end


function moveEntity(name, xy1)
	entity = getEntity(name)
	--local box = split(entity.boxes[1].box, ",")
	local xy2 = split(entity.boxes[1].xy, ",")
	local xy3 = split(xy1, ",")

	x = xy2[1] + xy3[1]
	y = xy2[2] + xy3[2] 
	--entity.boxes[1].xy = (tonumber(xy[1])- tonumber(box[1] / 2)) .. (tonumber(xy[2]) - tonumber(box[2] / 2))
	entity.boxes[1].xy = x .. "," .. y
end


function getPointingAt(value)

	retValue = ""
	
	for i, entity in ipairs(entities) do
		for i, box in ipairs(entity.boxes) do
			xy = split(box.xy, ",")
			boxx = tonumber(xy[1])
			boxbox = split(box.box, ",")
			boxy = tonumber(xy[2])
			width = tonumber(boxbox[1])
			height = tonumber(boxbox[2])
			boxEnd = boxx + width
			boxBottom = boxy + height
	
			if (UI.mousex > boxx) and (UI.mousex < boxEnd) and (UI.mousey > boxy) and (UI.mousey < boxBottom) then
				
				if value == "name" then
					retValue = entity.name

				end

			end
		end
	end	
	return retValue	
end
	local Grid = require ("jumper.grid") -- The grid class
local Pathfinder = require ("jumper.pathfinder") -- The pathfinder lass			

function initEntities ()

	entities = {}
	collisionBoxes = {}
	actorEntity = {}
	actorEntityNote = false
	entity = {}
	entity.name = "square2"
	entity.boxes = {}
	box = {}
	box.xy = "280,140"
	box.box = "100,100"
	table.insert(entity.boxes, box)
	entity.xy = "200,200"
	entity.drawtype = "lovedraw"
--	entity.animate = anim8.newanimation(g('2-7',2), 0.10)
	entity.zcalc = true
	entity.z = 160
	entity.visible = false
	table.insert(entities, entity)	
	
end


function loadEntities ()

	if  line == "ENTITIES SECTION." then
		local section = "entities"
		logFile:write("Starting to add entities!\n")
		repeat
			line = scriptFile:read() 
			if line ~= nil then

				if line:startsWith("END ENTITIES") then break end
				
				local words = line:split(" ")

				for i, word in ipairs(words) do
					--finding toplevel commands
					word = word:strip()
					if word == "new"  then
						--processing a new command until another toplevel command is found
						toplevel = "new"
					end
					
				end
				if toplevel == "new" then
					entityDone = loadEntity(line)
				end
				
					
			end
		until line == nil
		
		findActor()
		
	end
	
end


function findActor()

	for i, e in ipairs(entities)  do
		if e.actor == "true" then
			actorEntity = e
			break
		end
	end
end


function loadEntity(line)
	
	words = line:split(" ")
	
	for i, word in ipairs(words)  do
		--first word should be new
		--logFile:write(word .. "\n")
		word = word:strip()

		if word == "new" then
			setupNewEntity()
			word = nil
		end
		
		if word ~= nil then
			word = word:strip()
			--debug.debug()
			if word:startsWith("entity.") then
				word = word:gsub("%.", "|")
				entityWords = split(word, "|")
				-- print (entityWords[2])

				if entityWords[2] == "name" then
					entity.name = words[i + 2]
				end
				if entityWords[2] == "drawType" then
					entity.drawType = words[i + 2]
				end
				if entityWords[2] == "zCalc" then
					entity.zCalc = words[i + 2]
				end
				if entityWords[2] == "xy" then
					entity.xy = words[i + 2]
				end
				if entityWords[2] == "visible" then
					entity.visible = words[i + 2]
				end

				if entityWords[2] == "speed" then
					entity.speed = words[i + 2]
				end
				if entityWords[2] == "actor" then
					for i, e in ipairs(entities) do
						e.actor = nil
					end
					entity.actor = words[i + 2]
				end

				if entityWords[2] == "boxes" then

					boxWords = words[i + 2]:split(",")
					
					box = {}
					box.relativexy = boxWords[1] .. "," .. boxWords[2]

					local entityxy = split(entity.xy, ",")

					box.xy = boxWords[1] + entityxy[1] .. "," .. boxWords[2]+ entityxy[2] 

					box.box = boxWords[3] .. "," .. boxWords[4]
					if boxWords[5] == "collision" then
						box.collision = true
						box.entity = table.getn(entities) + 1
						table.insert(collisionBoxes, box)
					end
					table.insert(entity.boxes, box)
				end
				
			end
		end
		if word == "add" then
			addEntity()
			logFile:flush()
			return true
			
		end
		if word == "new" then
			return true
		end
	end
	return false

	
end


function addEntity()

	table.insert(entities, entity)
	logFile:write("~~~entity" .. table.getn(entities))
	if entity.name ~= nil then logFile:write("  " .. entity.name) end
	logFile:write("~~\n")
	logFile:write("\tat " .. entity.xy .. "\n")
	logFile:write("\tdraw type: " .. entity.drawType .. "\n")
	for i, box in ipairs(entity.boxes) do
		local bxy = box.xy:split(",")
		local bwh = box.box:split(",")
		logFile:write("\tbox " .. i .. ": " .. "x " .. bxy[1] .. " y ".. bxy[2]  .. " w ".. bwh[1]  .. " h ".. bwh[2] .. "\n")
	end	
	
	logFile:write("\n------------------------------------------------------------------\n")			

end


function setupNewEntity ()

	entity = {}
	
	entity.name = "none"
	entity.boxes = {}	
	entity.drawType = "lovedraw"
	entity.zCalc = false
	entity.z = 0
	entity.xy = "0,0"
	entity.visible = false
	entity.inventory = "_"

end

function checkPointingAt(entity, x ,y)

	for i, box in ipairs(entity.boxes) do
		xy = split(box.xy, ",")
		boxx = tonumber(xy[1])
		boxy = tonumber(xy[2])
		boxbox = split(box.box, ",")
		width = tonumber(boxbox[1])
		height = tonumber(boxbox[2])
		boxEnd = boxx + width
		boxBottom = boxy + height
		x = x or UI.mousex
		y = y or UI.mousey
		if (x > boxx) and (x < boxEnd) and (y > boxy) and (y < boxBottom) then
			return true

		end
	end
	return false	
end

function getEntity(name)

	for i, entity  in ipairs (entities) do
	
		if entity.name == name then
			return entity
		end
	end
	
	return "none"

end

function analyzemap (ignore)
	ignore = ignore or "_"
	--topmost = 9999
	--leftmost = 9999
	-- bottommost = -9999

	-- for i, e in ipairs(entities) do
		-- for i , b in ipairs(e.boxes) do
			-- xy = b.box:split(",")
			-- exy = e.xy:split(",")
			-- box = b.box:split(",")
			-- if tonumber(xy[1])  < leftmost then leftmost = (exy[1] + xy[1]) end
			-- if tonumber(xy[1])  > rightmost then rightmost = (exy[1] + xy[1]) + box[1] end
			-- if tonumber(xy[2])  > bottommost then botv  ï¿½ï¿½ï¿½J;ï¿½  ï¿½EWDINO ZIP j-ï¿½ï¿½Jï¿½J  3ï¿½ï¿½J      ï¿½TILITY LUA qBï¿½ï¿½Jï¿½J  Cï¿½ï¿½J      ttommost = (xy[2] + exy[2]) + box[2] end
			-- if tonumber(event[2])  < topmost then topmost = (xy[2] + exy[2]) end
			-- if b.collision == true then
				
			-- end
		-- end
	-- end
	
	right = love.graphics.getWidth()
	bottom = love.graphics.getHeight()
	
	columnCount = math.floor(right / 30)
	rowCount = math.floor(bottom / 30) 
	map = {}
	for i = 0, rowCount, 1 do
		map[i] = {}
		for j = 0, columnCount, 1 do
			map[i][j] = 1
		end
	end
	print("ignoring " .. ignore)
	for i, e in ipairs(entities) do
		if not ignore:includes("guy") then
		-- if 1 == 0 then
			for j, b in ipairs(e.boxes) do
				if b.collision == true then
					x, y, right, bottom = splitBoxData(e, b)
					x = math.floor(x / 30)
					y = math.floor(y / 30)
					right = math.floor(right / 30)
					bottom = math.floor(bottom / 30)
					
					for k = x, right, 1 do
						for l = y, bottom, 1 do
							map[l][k] = 0
						end
					end
				end
			end
		end
	end
	
end


function splitBoxData(entity, box)
	local exy = entity.xy:split(",")
	local xy = box.relativexy:split(",")
	local thisbox = box.box:split(",")
	return xy[1] + exy[1], xy[2] + exy[2], xy[1] + exy[1] + thisbox[1], xy[2] + exy[2] + thisbox[2]

end


function moveToEntity(entity, toEntity)
	local xy  = toEntity.xy:split(",")
	entity.walkingToEntity = toEntity
	return	pathFinding("move" .. " " .. entity.name .. " " .. math.floor(xy[1] / 30) .. "," .. math.floor(xy[2] / 30 ), "_" .. entity.name .. "_" .. toEntity.name ..  "_", true)	

end


function pathFinding (command, ignore, retPlease)

	local pathEntity = {}
	if command == nil then
		if  actorEntity.name ~= nil then
			pathEntity = actorEntity
			endx = math.floor(UI.mousex / 30)
			endy = math.floor(UI.mousey / 30)
		else
			if actorEntityNote == false then
				logFile:write("\nNo actor entity selected; proceeding to use left click as action menu since this game doesn't seem to have an actor in it")
				actorEntityNote = true
				checkEvents("click")
			else
				checkEvents("click")
			end
		end
	else
		commandWords = command:split(" ")
		actor = commandWords[2]
		tempxy = commandWords[3]
		tempxy = tempxy:split(",")
		endx = tonumber(tempxy[1])
		endy = tonumber(tempxy[2])
		pathEntity = getEntity(actor)
		
	end
	if pathEntity.name ~= nil then
		analyzemap(ignore)	

	-- Value for walkable tiles
		local walkable = 1

	-- Library setup

	-- Creates a grid object
		local grid = Grid(map)
	-- Creates a pathfinder object using Jump Point Search
		local myFinder = Pathfinder(grid, 'JPS', 1)

	-- Define start and goal locations coordinates
		-- entity =  getEntity("guy2") or 0
		xy =  pathEntity.xy:split(",")
		startx =  math.floor(xy[1]/30)
		starty =  math.floor(xy[2]/30)	
		print(xy[1], xy[2], endx, endy)
	-- Calculates the path, and its length
		local path, length = myFinder:getPath(startx, starty, endx, endy)
		entityPath = ""
		checkActionQueue({"moveTo", pathEntity.name}, true)
		if path then

		  -- print(('Path found! Length: %.2f'):format(length))
			for node, count in path:iter() do
				print(('Step: %d - x: %d - y: %d'):format(count, node.x, node.y))
				entityPath = entityPath .. "moveTo " .. pathEntity.name .. " " ..  math.floor(node.x * 30) .. "," .. math.floor(node.y * 30) .. "/"
			end
			
			if retPlease == true then
				return entityPath
			else
				local event = {}
			
				event.id = 1
				event.onClick = false
				event.onKeyPress = false
				event.always = true
				event.time = nil
				event.logic = nil
				event.trueactions = string.sub(entityPath, 1, -2)
				event.delete = true
				table.insert(events, event)
			end
		end
	end
end


function moveEntityTo(name, xy, actionWords)
	local entity = getEntity(name)
	local stop = nil
	if entity ~= "none" then
	-- local box = split(entity.boxes[1].box, ",")
	-- local xy = split(entity.boxes[1].xy, ",")
	-- entity.boxes[1].xy = (tonumber(xy[1])- tonumber(box[1] / 2)) .. (tonumber(xy[2]) - tonumber(box[2] / 2))
		entity.currAction = actionWords
		local newxy = split(xy, ",")
		local entityxy = split(entity.xy, ",")
			--first let's see if we're close enough to target entity
			entity.x = tonumber(entityxy[1])
			entity.y = tonumber(entityxy[2])
			
				dist = distanceFrom(entity.x, entity.y, newxy[1], newxy[2])
				dist = dist / (entity.speed or 200)
				if entity.flux ~= nil then
					entity.flux:stop()
				end
				entity.flux = flux.to(entity,dist, {x = tonumber(newxy[1]), y = tonumber(newxy[2])})
				:ease("linear")
				:oncomplete(function() 
					entity.flux:stop() 
					checkActionQueue(entity.currAction)
				end)
	end
end


function distanceFrom(x1,y1,x2,y2) 
	return math.sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2)
end


function moveEntityDirect(name, entity, xy)

	entity = entity or getEntity(name)
	entity.xy = xy
	for i, b in ipairs(entity.boxes) do
		local xy1 = split(xy, ",") 
		local xy2 = split(b.relativexy, ",")
		b.xy = xy1[1] + xy2[1] .. "," .. xy1[2] + xy2[2]
	
	end


end

function moveEntity(name, xy1, entity, xy2)
	--local box = split(entity.boxes[1].box, ",")
	if name ~= nil then 
		entity = getEntity(name)
	end

	if entity ~= "none" then
		--entity.boxes[1].xy = (tonumber(xy[1])- tonumber(box[1] / 2)) .. (tonumber(xy[2]) - tonumber(box[2] / 2))

		local entityxy = split(entity.xy, ",")
		local xyIn = split(xy1, ",")
		for i, box in ipairs(entity.boxes) do
			if box.collision == true then
				--if any of the collision boxes collide, don't move! 
				cantMove = false
				cantMove = collisionCheck(box,xyIn[1], xyIn[2])
				if cantMove == true then break end
			end
		end
		if cantMove ~= true then 
			y = entityxy[2] + xyIn[2] 
			x = entityxy[1] + xyIn[1]		
			entity.xy = x .. "," .. y
			for i, box in ipairs(entity.boxes) do
	
				local xy2 = split(box.relativexy, ",")
				box.xy = xy2[1] + x .."," ..  xy2[2] + y
			end
		end	
	end
end


function updateXYtoFlux()

	for i, e in ipairs(entities) do

		if e.flux ~= nil then
			e.xy = e.x .. "," .. e.y 
			
			for i, box in ipairs(e.boxes) do
				
				local xy2 = split(box.relativexy, ",")
				box.xy = e.x + xy2[1] .."," ..  e.y + xy2[2]
				
			end

			if e.walkingToEntity ~= nil then
				local tempxy = e.walkingToEntity.xy
				dist = distanceFrom(e.x, e.y, tonumber(tempxy[1]), tonumber(tempxy[2]))
				if dist < 350 then 
					e.flux:stop()
					checkActionQueue(e.currAction)
				end
				
				--TO DO-
				--Check all corners and maybe midpoints to make sure
				--moving entities doesn't merge into target.
			end	

		end

	end

end

function getPointingAt(value)

	retValue = ""
	local e
	for i, entity in ipairs(entities) do
		if entity.visible ~= false then
			for i, box in ipairs(entity.boxes) do
				entityxy = entity.xy:split(",")
				xy = split(box.relativexy, ",")
				
				boxx = tonumber(xy[1]) + entityxy[1]
				boxbox = split(box.box, ",")
				boxy = tonumber(xy[2])+ entityxy[2]
				width = tonumber(boxbox[1])
				height = tonumber(boxbox[2])
				boxEnd = boxx + width
				boxBottom = boxy + height
		
				if (UI.mousex > boxx) and (UI.mousex < boxEnd) and (UI.mousey > boxy) and (UI.mousey < boxBottom) then
					
					if value == "name" then
						retValue = entity.name
						e = entity
						break
					end
				if value == "action" then
						retValue = entity.action
						e = entity
						break
					end

				end
			end
		end
	end	
	return retValue, e
end
	
	
function collisionCheck(box1, x, y, box2 )

	x = x or 0
	y = y or 0
	if box2 == nil then
		for i, box3 in ipairs(collisionBoxes) do
			if box3.entity ~= box1.entity then
				test = collisionMath(box1, box3, x, y)
				if test == true then return true end
			end
		end
	else
		collisionMath(box1, box2, x, y)
	end
end


function collisionMath (box1, box2, x, y)

	--parse box data
	local entity = entities[box1.entity]
	local entityxy = entity.xy:split(",")
	local xy = split(box1.relativexy, ",")
	local boxbox = split(box1.box, ",")
	local boxwidth = tonumber(boxbox[1])
	local boxheight = tonumber(boxbox[2])
	
	local b1x = tonumber(xy[1]) + entityxy[1] + x
	local b1y = tonumber(xy[2])+ entityxy[2] + y
	local b1End = b1x + boxwidth
	local b1Bot = b1y + boxheight

	entity = entities[box2.entity]
	entityxy = entity.xy:split(",")
	xy = split(box2.relativexy, ",")
	boxbox = split(box2.box, ",")
	boxwidth = tonumber(boxbox[1])
	boxheight = tonumber(boxbox[2])		
		
	b2x = tonumber(xy[1]) + entityxy[1]
	b2y = tonumber(xy[2])+ entityxy[2]
	b2End = b2x + boxwidth
	b2Bot = b2y + boxheight
	
	if 
	((b1x > b2x) and (b1x < b2End) or 
	((b1End > b2x) and b1End < b2End)) and
	((b1y > b2y) and (b1y < b2Bot) or 
	((b1Bot > b2y) and b1Bot < b2Bot))
	or
	((b2x > b1x) and (b2x < b1End) or 
	((b2End > b1x) and b2End < b1End)) and
	((b2y > b1y) and (b2y < b1Bot) or 
	((b2Bot > b1y) and b2Bot < b1Bot))
	then
		return true

	end


end


function removeInventory(itemID, name)
	
	local haveItem = false
	local thisEntity = getEntity(name)	
	if thisEntity.inventory:includes("_" .. itemID .. "_") then
		thisEntity.inventory = thisEntity.inventory:gsub(itemID .. "_", "")				
	end	
end


function addInventory(itemID, name)
	
	local haveItem = false
	local thisEntity = getEntity(name)	
	if thisEntity.inventory:includes("_" .. itemID .. "_") then
		haveItem = true
	end
	
	if haveItem == false then
		for i, entity in ipairs(entities) do
			if entity.inventory:includes("_" .. itemID .. "_") then
				entity.inventory = entity.inventory:gsub(itemID .. "_", "")				
			end

		end
		
		thisEntity.inventory = thisEntity.inventory .. itemID .. "_"
	end
	
	
end
events = {}



function initPlayerEventsListeners()

	local event = {}

	event.id = 1
	event.onClick = true
	event.onKeyPress = false
	event.always = false
	event.time = nil
	event.logic = loadLogic("pointing at talkTo")
	event.action = loadActions("event ")
	
	addEvent(event)

	local event = {}

	event.id = 1
	event.onClick = true
	event.onKeyPress = false
	event.always = false
	event.time = nil
	event.logic = loadLogic("pointing at talkTo")
	event.action = loadActions("start chat hasItem")
	
	addEvent(event)

	
	
end


function loadEvents()

	if  line == "EVENTS SECTION." then
		
		local section = "events"
		logFile:write("Starting to add events!\n")
		repeat
		line = scriptFile:read() 
		if line ~= nil then

			if line:startsWith("END EVENTS") then break end
			
			local words = line:split(" ")

			for i, word in ipairs(words) do
				--finding toplevel commands
				word = word:strip()
				if word == "new"  then
					--processing a new command until another toplevel command is found
					toplevel = "new"
				end
				
			end
			if toplevel == "new" then
				eventDone = loadEvent(line)
			end
			
				
		end
		until line == nil

	end

end


function loadEvent(line)
	
	local words = line:split(" ")

	for i, word in ipairs(words)  do
		--first word should be new
		--logFile:write(word .. "\n")
		word = word:strip()

		if word == "new" then
			setupNewEvent()
			word = nil
		end
		if word == "as" then
			local asWords = words[i + 1]:split(",")
			asWord = word:strip()
			for j, asWord in ipairs(asWords) do
				if asWord:upper() == "ONCLICK" then
					event.onClick = true
				end
				if asWord:upper() == "ONKEYPRESS" then
					event.onKeyPress = true
				end
				if asWord:upper() == "ALWAYS" then
					event.always = true
				end
				if asWord:upper():startsWith("PLAYERACTION") then
					local playerAction = line:split("(", true)
					event.playerAction = string.sub(playerAction[2], 1, -2)
					
				end
				if asWord:upper() == "TIMER" then
					--event.time = true
				end
				
			end

		end
		
		if word ~= nil then
			word = word:strip()
			--debug.debug()
			if word:startsWith("event.") then
				word = word:gsub("%.", "|")
				eventWords = split(word, "|")

				if eventWords[2] == "name" then
					event.name = words[i + 2]
				end
				if eventWords[2] == "deleteAfterRun" then
					event.delete = words[i + 2]
				end
				if eventWords[2] == "resetAfterRun" then
					event.reset = words[i + 2]
				end
				if eventWords[2] == "time" then
					event.time = words[i + 2]
					event.timeStart = timer.getTime()
				end
				if eventWords[2] == "logic" then
					event.logic = tostring(loadLogic(line))
				end
				if eventWords[2] == "actions" then
					local trueactions = line:split("=")
					event.trueactions = trueactions[2]
				end
				if eventWords[2] == "falseactions" then
					local falseactions = line:split("=")
					event.falseactions = falseactions[2]
				end

			end
		end
		if word == "add" then
			addEvent()
			logFile:flush()
			return true
			
		end
		if word == "new" then
			return true
		end
	end
	return false
	
end


function setupNewEvent ()

	event = {}

	event.id = nil
	event.onClick = false
	event.onKeyPress = false
	event.always = false
	event.time = nil
	event.active = false
	event.logic = nil
	event.inventoryClick = false
	event.trueactions = nil
	event.falseactions = nil

end
	
function addEvent()

	table.insert(events, event)
	logFile:write("~~~event" .. table.getn(events))
	if event.name ~= nil then logFile:write("  " .. event.name) end
	logFile:write("~~\n")
	if event.onClick == true then logFile:write("\ton click \n") end
	if event.onKeyPress == true then logFile:write("\ton key press\n") end		
	if event.always == true then logFile:write("\talways\n") end		
	if event.logic ~= nil then 
		local logics = split(event.logic, ",") 
		for j, logicID in ipairs(logics) do
			logicString = logic[tonumber(logicID)].ifString
			if j == 1 then logFile:write("\t\tif  ") else logFile:write("\t\t\tand ") end
		
			logFile:write(logicString ..  " [" .. logicID .. "]\n")			
		
		end
	end
	if event.trueactions ~= nil then
	
		logFile:write("\t\t")
		logFile:write(event.trueactions)
		logFile:write("\n")
	end
	
	if event.falseactions ~= nil then
		local actionIDs	= split(event.falseactions, ",")
		for j, actionID in ipairs(actionIDs) do
			actionString = actions[tonumber(actionID)].command
			logFile:write("\t\t")
			if j == 1 then logFile:write("else ") else logFile:write("\t ") end
			logFile:write(actionString .. " [" .. actionID .. "]\n")		
		end			
	end
	logFile:write("------------------------------------------------------------------\n")			

end

function checkEvents (eventType, thisPath)

	for i, event in ipairs(events) do

		if event.onClick == true and eventType == "click" then
			if event.logic ~= nil then
				checkLogic(event.logic, event.trueactions, event.falseactions, event.delete)
				
			else
				doAction(event.trueactions)
				if event.delete == true then event.deleted = true end
			end
		end
		
		if event.onKeyPress == true and eventType == "keyreleased" then
			
			
			if event.logic ~= nil and  event.logic ~= "" then
				checkLogic(event.logic, event.trueactions, event.falseactions, event.delete)
			
			else
				doAction(event.trueactions)
				if event.delete == true then event.deleted = true end
				end			
		end
		if event.always == true and eventType == "always" then
		
			if event.logic ~= nil then
				checkLogic(event.logic, event.trueactions, event.falseactions, event.delete)

			else
				doAction(event.trueactions)
				if event.delete == true then event.deleted = true end

			end			
		end
		
		if event.playerAction == eventType then
			if event.logic ~= nil then
				checkLogic(event.logic, thisPath .. event.trueactions,event.falseactions, event.delete)
			else
				print(thisPath .. event.trueactions)
				doAction(thisPath .. event.trueactions)
				if event.delete == true then event.deleted = true end

			end			
				
		end
		
	end
	deleteEvents()
end


function deleteEvents()

	i = 1
	while i <= #events do
		if events[i].deleted == true then
			table.remove(events, i)
		else
			i=i+1
		end
	end


end

function checkTimers()

	for i, event in ipairs(events) do
	
		if event.time ~= nil and event.timeStart ~= nil then
			if timer.getTime() > (event.timeStart + event.time) then
				if event.logic ~= nil and event.logic ~= "" then
					checkLogic(event.logic, event.trueactions, event.falseactions)
					
						if event.delete == "true" then event.remove = true  end
						if event.reset == "true" then event.timeStart = timer.getTime() end

					else
						doAction(event.trueactions)
						if event.delete == "true" then event.remove = true end
						if event.reset == "true" then event.timeStart = timer.getTime() end
				end	
			end
		
		end
	
	end
	for i, event in ipairs(events) do
		if event.remove == true then table.remove(events, i) end
	end
	
end


function checkChatEvent(eventID)

	event = events[eventID]
	if event.logic ~= nil and event.logic ~= "" then
		
		checkLogic(event.logic, event.trueactions, event.falseactions)
		
		else
			doAction(event.trueactions)
	end	

endfunction OpenLogFile()    
	
	mydir = love.filesystem.getAppdataDirectory( )
	print(mydir .. "/adventureplusplus/logfile.txt")
    logFile = io.open("logfile.txt", "w")
    logFile:write("Opening LogFile\n")

end

function OpenScriptFile()    
	
    scriptFile = io.open("scriptfile.txt", "r")
    logFile:write("Opening LogFile\n")	

	
end--
-- flux
--
-- Copyright (c) 2014, rxi
--
-- This library is free software; you can redistribute it and/or modify it
-- under the terms of the MIT license. See LICENSE for details.
--

local flux = { _version = "0.1.4" }
flux.__index = flux

flux.tweens = {}
flux.easing = { linear = function(p) return p end }

local easing = {
  quad    = "p * p",
  cubic   = "p * p * p",
  quart   = "p * p * p * p",
  quint   = "p * p * p * p * p",
  expo    = "2 ^ (10 * (p - 1))",
  sine    = "-math.cos(p * (math.pi * .5)) + 1",
  circ    = "-(math.sqrt(1 - (p * p)) - 1)",
  back    = "p * p * (2.7 * p - 1.7)",
  elastic = "-(2^(10 * (p - 1)) * math.sin((p - 1.075) * (math.pi * 2) / .3))"
}

local makefunc = function(str, expr)
  local load = loadstring or load
  return load("return function(p) " .. str:gsub("%$e", expr) .. " end")()
end

for k, v in pairs(easing) do
  flux.easing[k .. "in"] = makefunc("return $e", v)
  flux.easing[k .. "out"] = makefunc([[
    p = 1 - p
    return 1 - ($e)
  ]], v)
  flux.easing[k .. "inout"] = makefunc([[
    p = p * 2 
    if p < 1 then
      return .5 * ($e)
    else
      p = 2 - p
      return .5 * (1 - ($e)) + .5
    end 
  ]], v)
end



local tween = {}
tween.__index = tween

local function makefsetter(field)
  return function(self, x)
    local mt = getmetatable(x)
    if type(x) ~= "function" and not (mt and mt.__call) then
      error("expected function or callable", 2)
    end
    local old = self[field]
    self[field] = old and function() old() x() end or x
    return self
  end
end

local function makesetter(field, checkfn, errmsg)
  return function(self, x)
    if checkfn and not checkfn(x) then
      error(errmsg:gsub("%$x", tostring(x)), 2)
    end
    self[field] = x
    return self
  end
end

tween.ease  = makesetter("_ease",
                         function(x) return flux.easing[x] end,
                         "bad easing type '$x'")
tween.delay = makesetter("_delay",
                         function(x) return type(x) == "number" end,
                         "bad delay time; expected number")
tween.onstart     = makefsetter("_onstart")
tween.onupdate    = makefsetter("_onupdate")
tween.oncomplete  = makefsetter("_oncomplete")


function tween.new(obj, time, vars)
  local self = setmetatable({}, tween)
  self.obj = obj
  self.rate = time > 0 and 1 / time or 0
  self.progress = time > 0 and 0 or 1
  self._delay = 0
  self._ease = "quadout"
  self.vars = {}
  for k, v in pairs(vars) do
    if type(v) ~= "number" then
      error("bad value for key '" .. k .. "'; expected number")
    end
    self.vars[k] = v
  end
  return self
end


function tween:init()
  for k, v in pairs(self.vars) do
    local x = self.obj[k]
    if type(x) ~= "number" then
      error("bad value on object key '" .. k .. "'; expected number")
    end
    self.vars[k] = { start = x, diff = v - x }
  end
  self.inited = true
end


function tween:after(...)
  local t
  if select("#", ...) == 2 then
    t = tween.new(self.obj, ...)
  else
    t = tween.new(...)
  end
  t.parent = self.parent
  self:oncomplete(function() flux.add(self.parent, t) end)
  return t
end


function tween:stop()
  flux.remove(self.parent, self)
end



function flux.group()
  return setmetatable({}, flux)
end


function flux:to(obj, time, vars)
  return flux.add(self, tween.new(obj, time, vars))
end


function flux:update(deltatime)
  for i = #self, 1, -1 do
    local t = self[i]
    if t._delay > 0 then
      t._delay = t._delay - deltatime
    else
      if not t.inited then
        flux.clear(self, t.obj, t.vars)
        t:init()
      end
      if t._onstart then
        t._onstart()
        t._onstart = nil
      end
      t.progress = t.progress + t.rate * deltatime 
      local p = t.progress
      local x = p >= 1 and 1 or flux.easing[t._ease](p)
      for k, v in pairs(t.vars) do
        t.obj[k] = v.start + x * v.diff
      end
      if t._onupdate then t._onupdate() end
      if p >= 1 then
        flux.remove(self, i)
        if t._oncomplete then t._oncomplete() end
      end
    end
  end
end


function flux:clear(obj, vars)
  for t in pairs(self[obj]) do
    if t.inited then
      for k in pairs(vars) do t.vars[k] = nil end
    end
  end
end


function flux:add(tween)
  -- Add to object table, create table if it does not exist
  local obj = tween.obj
  self[obj] = self[obj] or {}
  self[obj][tween] = true
  -- Add to array
  table.insert(self, tween)
  tween.parent = self
  return tween
end


function flux:remove(x)
  if type(x) == "number" then
    -- Remove from object table, destroy table if it is empty
    local obj = self[x].obj
    self[obj][self[x]] = nil
    if not next(self[obj]) then self[obj] = nil end
    -- Remove from array
    self[x] = self[#self]
    return table.remove(self)
  end
  for i, v in pairs(self) do
    if v == x then
      return flux.remove(self, i)
    end
  end
end



local bound = {
  to      = function(...) return flux.to(flux.tweens, ...) end,
  update  = function(...) return flux.update(flux.tweens, ...) end,
  remove  = function(...) return flux.remove(flux.tweens, ...) end,
}
setmetatable(bound, flux)

return boundOpening LogFile
logic = {}


function initLogic()

	local aLogic = {}
	aLogic.id = 1
	aLogic.ifString = "pointing at *"
	table.insert(logic, aLogic)

	local aLogic = {}
	aLogic.id = 2
	aLogic.ifString = "pointing at nothing"
	table.insert(logic, aLogic)
	
	local aLogic = {}
	aLogic.id = 3
	aLogic.ifString = "keydown right"
	table.insert(logic, aLogic)
	
	local aLogic = {}
	aLogic.id = 4
	aLogic.ifString = "keydown left"
	table.insert(logic, aLogic)	

	local aLogic = {}
	aLogic.id = 5
	aLogic.ifString = "keydown up"
	table.insert(logic, aLogic)	
	
	local aLogic = {}
	aLogic.id = 6
	aLogic.ifString = "keydown down"
	table.insert(logic, aLogic)	
	end


function loadLogic(line)

	local aLogic = {}
	local thisLogic  = ""

	logicLines = line:split("=")
	line = logicLines[2]:strip()
	logicLines = line:split("and")
	for i, logicLine in ipairs(logicLines) do
		foundLogic = false
		logicLine = logicLine:strip()
		for j, aLogic in ipairs(logic) do
			if aLogic.ifString == logicLine then
				if thisLogic == "" then
					thisLogic = aLogic.id
				else
					thisLogic = thisLogic .. "," .. aLogic.id
				end
				foundLogic = true
				break
			end
		end
		if foundLogic ~= true then
			local aLogic = {}
			
			aLogic.id =  table.getn(logic) + 1
			aLogic.ifString = logicLine
			table.insert(logic, aLogic)
			if thisLogic == "" then
				thisLogic = aLogic.id
			else
				thisLogic = thisLogic .. "," .. aLogic.id
			end

		end
	end
	
	return thisLogic
	
end




function checkLogic(ids, trueactions, falseactions, delete)

	if type(ids) == "string" then
		idList = split(ids, ",")
	else
		idList = {}
		table.insert(idList, ids)
	end
	
	ifWords = {}
	
	for i, logicID in ipairs(idList) do
		
		local aLogic = logic[tonumber(logicID)]
		ifWords = split(aLogic.ifString, " ")
		
		operand1 = trim(ifWords[1])
		operation = trim(ifWords[2])
		if ifWords[3] ~= nil then operand2 = trim(ifWords[3]) end
		operand1 = SystemValues(operand1)
		operand2 = SystemValues(operand2)
		operation = SystemValues(operation)
		operand1 = UserValues2(operand1)
		operand2 = UserValues2(operand2)
		local response
		if operation == "=" or operation == ">" or operation == "<" then
			response = mathLogic(operation, operand1, operand2)
		end	
		if operation == "at" then
			response = entityLogic(aLogic.ifString)
		end		
		if operation == "has" then
			response = inventoryLogic(operand1, operand2)
		end
		if operand1 == "keydown" then
			response = keyDownLogic(operation)
		end
		
		if response == false  then
			if i == #idList then
				if falseactions ~= nil then
					doAction(falseactions)
					if delete == "true" then table.remove(events, i) end

				end 
			end
		return false
		end
	end

	doAction(trueactions)
	
end

function mathLogic(operation, operand1, operand2)

	nOperand1 = tonumber(operand1)
	nOperand2 = tonumber(operand2)
	nOperand1 = operand1
	nOperand2 = operand2
	-- if type(nOperand1) == "number" and type (nOperand2) == "number" then
		if operation == "=" then
			if nOperand1 == nOperand2 then
				return true
			else
				return false
			end
		elseif operation == "<" then
			if nOperand1 < nOperand2 then
				return true
			else
				return false
			end
		elseif operation == ">" then 
			if nOperand1 > nOperand2 then
				return true
			else
				return false
			end
			
		end
		
	-- end

end


function keyDownLogic(key)

    -- if not imgui.GetWantCaptureKeyboard() then
		return keyboard.isDown(key)
	-- end
end


function entityLogic(ifString)

	logicWords = {}
	logicWords = split(ifString, " ")
	
	verb = logicWords[1]
	clarifier = logicWords[2]
	entityname = logicWords[3]
	local splitEntities = {}
	if entityname  == "*" or entityname == "nothing" then
		for i, entity in ipairs(entities) do
			table.insert(splitEntities, entity.name)

		end
	else
		splitEntities = split(entityname,",")
	end
	
	for i, entity in ipairs(splitEntities) do
		local entity = getEntity(entity)
		
		if entity ~= "none" then
			if verb == "pointing" then
				if clarifier == "at" then
					pointingAt = checkPointingAt(entity)
					if pointingAt == true then break end
				end
			end
		end	
	end 
	--print (pointingAt)
	if entityname == "nothing" then
		return not pointingAt
	else
		return pointingAt
	end
end


function inventoryLogic (name, itemID)

	local thisEntity = getEntity(name)	
	if thisEntity.inventory:includes("_" .. itemID .. "_") then

		return true
	end
	
	return false

end


--
-- lovebird
--
-- Copyright (c) 2017 rxi
--
-- This library is free software; you can redistribute it and/or modify it
-- under the terms of the MIT license. See LICENSE for details.
--

local socket = require "socket"

local lovebird = { _version = "0.4.2" }

lovebird.loadstring = loadstring or load
lovebird.inited = false
lovebird.host = "*"
lovebird.buffer = ""
lovebird.lines = {}
lovebird.connections = {}
lovebird.pages = {}

lovebird.wrapprint = true
lovebird.timestamp = true
lovebird.allowhtml = false
lovebird.echoinput = true
lovebird.port = 8000
lovebird.whitelist = { "127.0.0.1" }
lovebird.maxlines = 200
lovebird.updateinterval = .5


lovebird.pages["index"] = [[
<?lua
-- Handle console input
if req.parsedbody.input then
  local str = req.parsedbody.input
  if lovebird.echoinput then
    lovebird.pushline({ type = 'input', str = str })
  end
  if str:find("^=") then
    str = "print(" .. str:sub(2) .. ")"
  end
  xpcall(function() assert(lovebird.loadstring(str, "input"))() end,
         lovebird.onerror)
end
?>

<!doctype html>
<html>
  <head>
  <meta http-equiv="x-ua-compatible" content="IE=Edge"/>
  <title>lovebird</title>
  <style>
    body {
      margin: 0px;
      font-size: 14px;
      font-family: helvetica, verdana, sans;
      background: #FFFFFF;
    }
    form {
      margin-bottom: 0px;
    }
    .timestamp {
      color: #909090;
      padding-right: 4px;
    }
    .repeatcount {
      color: #F0F0F0;
      background: #505050;
      font-size: 11px;
      font-weight: bold;
      text-align: center;
      padding-left: 4px;
      padding-right: 4px;
      padding-top: 0px;
      padding-bottom: 0px;
      border-radius: 7px;
      display: inline-block;
    }
    .errormarker {
      color: #F0F0F0;
      background: #8E0000;
      font-size: 11px;
      font-weight: bold;
      text-align: center;
      border-radius: 8px;
      width: 17px;
      padding-top: 0px;
      padding-bottom: 0px;
      display: inline-block;
    }
    .greybordered {
      margin: 12px;
      background: #F0F0F0;
      border: 1px solid #E0E0E0;
      border-radius: 3px;
    }
    .inputline {
      font-family: mono, courier;
      font-size: 13px;
      color: #606060;
    }
    .inputline:before {
      content: '\00B7\00B7\00B7';
      padding-right: 5px;
    }
    .errorline {
      color: #8E0000;
    }
    #header {
      background: #101010;
      height: 25px;
      color: #F0F0F0;
      padding: 9px
    }
    #title {
      float: left;
      font-size: 20px;
    }
    #title a {
      color: #F0F0F0;
      text-decoration: none;
    }
    #title a:hover {
      color: #FFFFFF;
    }
    #version {
      font-size: 10px;
    }
    #status {
      float: right;
      font-size: 14px;
      padding-top: 4px;
    }
    #main a {
      color: #000000;
      text-decoration: none;
      background: #E0E0E0;
      border: 1px solid #D0D0D0;
      border-radius: 3px;
      padding-left: 2px;
      padding-right: 2px;
      display: inline-block;
    }
    #main a:hover {
      background: #D0D0D0;
      border: 1px solid #C0C0C0;
    }
    #console {
      position: absolute;
      top: 40px; bottom: 0px; left: 0px; right: 312px;
    }
    #input {
      position: absolute;
      margin: 10px;
      bottom: 0px; left: 0px; right: 0px;
    }
    #inputbox {
      width: 100%;
      font-family: mono, courier;
      font-size: 13px;
    }
    #output {
      overflow-y: scroll;
      position: absolute;
      margin: 10px;
      line-height: 17px;
      top: 0px; bottom: 36px; left: 0px; right: 0px;
    }
    #env {
      position: absolute;
      top: 40px; bottom: 0px; right: 0px;
      width: 300px;
    }
    #envheader {
      padding: 5px;
      background: #E0E0E0;
    }
    #envvars {
      position: absolute;
      left: 0px; right: 0px; top: 25px; bottom: 0px;
      margin: 10px;
      overflow-y: scroll;
      font-size: 12px;
    }
  </style>
  </head>
  <body>
    <div id="header">
      <div id="title">
        <a href="https://github.com/rxi/lovebird">lovebird</a>
        <span id="version"><?lua echo(lovebird._version) ?></span>
      </div>
      <div id="status"></div>
    </div>
    <div id="main">
      <div id="console" class="greybordered">
        <div id="output"> <?lua echo(lovebird.buffer) ?> </div>
        <div id="input">
          <form method="post"
                onkeydown="return onInputKeyDown(event);"
                onsubmit="onInputSubmit(); return false;">
            <input id="inputbox" name="input" type="text"
                autocomplete="off"></input>
          </form>
        </div>
      </div>
      <div id="env" class="greybordered">
        <div id="envheader"></div>
        <div id="envvars"></div>
      </div>
    </div>
    <script>
      document.getElementById("inputbox").focus();

      var changeFavicon = function(href) {
        var old = document.getElementById("favicon");
        if (old) document.head.removeChild(old);
        var link = document.createElement("link");
        link.id = "favicon";
        link.rel = "shortcut icon";
        link.href = href;
        document.head.appendChild(link);
      }

      var truncate = function(str, len) {
        if (str.length <= len) return str;
        return str.substring(0, len - 3) + "...";
      }

      var geturl = function(url, onComplete, onFail) {
        var req = new XMLHttpRequest();
        req.onreadystatechange = function() {
          if (req.readyState != 4) return;
          if (req.status == 200) {
            if (onComplete) onComplete(req.responseText);
          } else {
            if (onFail) onFail(req.responseText);
          }
        }
        url += (url.indexOf("?") > -1 ? "&_=" : "?_=") + Math.random();
        req.open("GET", url, true);
        req.send();
      }

      var divContentCache = {}
      var updateDivContent = function(id, content) {
        if (divContentCache[id] != content) {
          document.getElementById(id).innerHTML = content;
          divContentCache[id] = content
          return true;
        }
        return false;
      }

      var onInputSubmit = function() {
        var b = document.getElementById("inputbox");
        var req = new XMLHttpRequest();
        req.open("POST", "/", true);
        req.send("input=" + encodeURIComponent(b.value));
        /* Do input history */
        if (b.value && inputHistory[0] != b.value) {
          inputHistory.unshift(b.value);
        }
        inputHistory.index = -1;
        /* Reset */
        b.value = "";
        refreshOutput();
      }

      /* Input box history */
      var inputHistory = [];
      inputHistory.index = 0;
      var onInputKeyDown = function(e) {
        var key = e.which || e.keyCode;
        if (key != 38 && key != 40) return true;
        var b = document.getElementById("inputbox");
        if (key == 38 && inputHistory.index < inputHistory.length - 1) {
          /* Up key */
          inputHistory.index++;
        }
        if (key == 40 && inputHistory.index >= 0) {
          /* Down key */
          inputHistory.index--;
        }
        b.value = inputHistory[inputHistory.index] || "";
        b.selectionStart = b.value.length;
        return false;
      }

      /* Output buffer and status */
      var refreshOutput = function() {
        geturl("/buffer", function(text) {
          updateDivContent("status", "connected &#9679;");
          if (updateDivContent("output", text)) {
            var div = document.getElementById("output");
            div.scrollTop = div.scrollHeight;
          }
          /* Update favicon */
          changeFavicon("data:image/png;base64," +
"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAP1BMVEUAAAAAAAAAAAD////19fUO"+
"Dg7v7+/h4eGzs7MlJSUeHh7n5+fY2NjJycnGxsa3t7eioqKfn5+QkJCHh4d+fn7zU+b5AAAAAnRS"+
"TlPlAFWaypEAAABRSURBVBjTfc9HDoAwDERRQ+w0ern/WQkZaUBC4e/mrWzppH9VJjbjZg1Ii2rM"+
"DyR1JZ8J0dVWggIGggcEwgbYCRbuPRqgyjHNpzUP+39GPu9fgloC5L9DO0sAAAAASUVORK5CYII="
          );
        },
        function(text) {
          updateDivContent("status", "disconnected &#9675;");
          /* Update favicon */
          changeFavicon("data:image/png;base64," +
"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAYFBMVEUAAAAAAAAAAADZ2dm4uLgM"+
"DAz29vbz8/Pv7+/h4eHIyMiwsLBtbW0lJSUeHh4QEBDn5+fS0tLDw8O0tLSioqKfn5+QkJCHh4d+"+
"fn5ycnJmZmZgYGBXV1dLS0tFRUUGBgZ0He44AAAAAnRSTlPlAFWaypEAAABeSURBVBjTfY9HDoAw"+
"DAQD6Z3ey/9/iXMxkVDYw0g7F3tJReosUKHnwY4pCM+EtOEVXrb7wVRA0dMbaAcUwiVeDQq1Jp4a"+
"xUg5kE0ooqZu68Di2Tgbs/DiY/9jyGf+AyFKBAK7KD2TAAAAAElFTkSuQmCC"
          );
        });
      }
      setInterval(refreshOutput,
                  <?lua echo(lovebird.updateinterval) ?> * 1000);

      /* Environment variable view */
      var envPath = "";
      var refreshEnv = function() {
        geturl("/env.json?p=" + envPath, function(text) {
          var json = eval("(" + text + ")");

          /* Header */
          var html = "<a href='#' onclick=\"setEnvPath('')\">env</a>";
          var acc = "";
          var p = json.path != "" ? json.path.split(".") : [];
          for (var i = 0; i < p.length; i++) {
            acc += "." + p[i];
            html += " <a href='#' onclick=\"setEnvPath('" + acc + "')\">" +
                    truncate(p[i], 10) + "</a>";
          }
          updateDivContent("envheader", html);

          /* Handle invalid table path */
          if (!json.valid) {
            updateDivContent("envvars", "Bad path");
            return;
          }

          /* Variables */
          var html = "<table>";
          for (var i = 0; json.vars[i]; i++) {
            var x = json.vars[i];
            var fullpath = (json.path + "." + x.key).replace(/^\./, "");
            var k = truncate(x.key, 15);
            if (x.type == "table") {
              k = "<a href='#' onclick=\"setEnvPath('" + fullpath + "')\">" +
                  k + "</a>";
            }
            var v = "<a href='#' onclick=\"insertVar('" +
                    fullpath.replace(/\.(-?[0-9]+)/g, "[$1]") +
                    "');\">" + x.value + "</a>"
            html += "<tr><td>" + k + "</td><td>" + v + "</td></tr>";
          }
          html += "</table>";
          updateDivContent("envvars", html);
        });
      }
      var setEnvPath = function(p) {
        envPath = p;
        refreshEnv();
      }
      var insertVar = function(p) {
        var b = document.getElementById("inputbox");
        b.value += p;
        b.focus();
      }
      setInterval(refreshEnv, <?lua echo(lovebird.updateinterval) ?> * 1000);
    </script>
  </body>
</html>
]]


lovebird.pages["buffer"] = [[ <?lua echo(lovebird.buffer) ?> ]]


lovebird.pages["env.json"] = [[
<?lua
  local t = _G
  local p = req.parsedurl.query.p or ""
  p = p:gsub("%.+", "."):match("^[%.]*(.*)[%.]*$")
  if p ~= "" then
    for x in p:gmatch("[^%.]+") do
      t = t[x] or t[tonumber(x)]
      -- Return early if path does not exist
      if type(t) ~= "table" then
        echo('{ "valid": false, "path": ' .. string.format("%q", p) .. ' }')
        return
      end
    end
  end
?>
{
  "valid": true,
  "path": "<?lua echo(p) ?>",
  "vars": [
    <?lua
      local keys = {}
      for k in pairs(t) do
        if type(k) == "number" or type(k) == "string" then
          table.insert(keys, k)
        end
      end
      table.sort(keys, lovebird.compare)
      for _, k in pairs(keys) do
        local v = t[k]
    ?>
      {
        "key": "<?lua echo(k) ?>",
        "value": <?lua echo(
                          string.format("%q",
                            lovebird.truncate(
                              lovebird.htmlescape(
                                tostring(v)), 26))) ?>,
        "type": "<?lua echo(type(v)) ?>",
      },
    <?lua end ?>
  ]
}
]]



function lovebird.init()
  -- Init server
  lovebird.server = assert(socket.bind(lovebird.host, lovebird.port))
  lovebird.addr, lovebird.port = lovebird.server:getsockname()
  lovebird.server:settimeout(0)
  -- Wrap print
  lovebird.origprint = print
  if lovebird.wrapprint then
    local oldprint = print
    print = function(...)
      oldprint(...)
      lovebird.print(...)
    end
  end
  -- Compile page templates
  for k, page in pairs(lovebird.pages) do
    lovebird.pages[k] = lovebird.template(page, "lovebird, req",
                                          "pages." .. k)
  end
  lovebird.inited = true
end


function lovebird.template(str, params, chunkname)
  params = params and ("," .. params) or ""
  local f = function(x) return string.format(" echo(%q)", x) end
  str = ("?>"..str.."<?lua"):gsub("%?>(.-)<%?lua", f)
  str = "local echo " .. params .. " = ..." .. str
  local fn = assert(lovebird.loadstring(str, chunkname))
  return function(...)
    local output = {}
    local echo = function(str) table.insert(output, str) end
    fn(echo, ...)
    return table.concat(lovebird.map(output, tostring))
  end
end


function lovebird.map(t, fn)
  local res = {}
  for k, v in pairs(t) do res[k] = fn(v) end
  return res
end


function lovebird.trace(...)
  local str = "[lovebird] " .. table.concat(lovebird.map({...}, tostring), " ")
  print(str)
  if not lovebird.wrapprint then lovebird.print(str) end
end


function lovebird.unescape(str)
  local f = function(x) return string.char(tonumber("0x"..x)) end
  return (str:gsub("%+", " "):gsub("%%(..)", f))
end


function lovebird.parseurl(url)
  local res = {}
  res.path, res.search = url:match("/([^%?]*)%??(.*)")
  res.query = {}
  for k, v in res.search:gmatch("([^&^?]-)=([^&^#]*)") do
    res.query[k] = lovebird.unescape(v)
  end
  return res
end


function lovebird.htmlescape(str)
  return str:gsub("<", "&lt;")
end


function lovebird.truncate(str, len)
  if #str <= len then
    return str
  end
  return str:sub(1, len - 3) .. "..."
end


function lovebird.compare(a, b)
  local na, nb = tonumber(a), tonumber(b)
  if na then
    if nb then return na < nb end
    return false
  elseif nb then
    return true
  end
  return tostring(a) < tostring(b)
end


function lovebird.checkwhitelist(addr)
  if lovebird.whitelist == nil then return true end
  for _, a in pairs(lovebird.whitelist) do
    local ptn = "^" .. a:gsub("%.", "%%."):gsub("%*", "%%d*") .. "$"
    if addr:match(ptn) then return true end
  end
  return false
end


function lovebird.clear()
  lovebird.lines = {}
  lovebird.buffer = ""
end


function lovebird.pushline(line)
  line.time = os.time()
  line.count = 1
  table.insert(lovebird.lines, line)
  if #lovebird.lines > lovebird.maxlines then
    table.remove(lovebird.lines, 1)
  end
  lovebird.recalcbuffer()
end


function lovebird.recalcbuffer()
  local function doline(line)
    local str = line.str
    if not lovebird.allowhtml then
      str = lovebird.htmlescape(line.str):gsub("\n", "<br>")
    end
    if line.type == "input" then
      str = '<span class="inputline">' .. str .. '</span>'
    else
      if line.type == "error" then
        str = '<span class="errormarker">!</span> ' .. str
        str = '<span class="errorline">' .. str .. '</span>'
      end
      if line.count > 1 then
        str = '<span class="repeatcount">' .. line.count .. '</span> ' .. str
      end
      if lovebird.timestamp then
        str = os.date('<span class="timestamp">%H:%M:%S</span> ', line.time) ..
              str
      end
    end
    return str
  end
  lovebird.buffer = table.concat(lovebird.map(lovebird.lines, doline), "<br>")
end


function lovebird.print(...)
  local t = {}
  for i = 1, select("#", ...) do
    table.insert(t, tostring(select(i, ...)))
  end
  local str = table.concat(t, " ")
  local last = lovebird.lines[#lovebird.lines]
  if last and str == last.str then
    -- Update last line if this line is a duplicate of it
    last.time = os.time()
    last.count = last.count + 1
    lovebird.recalcbuffer()
  else
    -- Create new line
    lovebird.pushline({ type = "output", str = str })
  end
end


function lovebird.onerror(err)
  lovebird.pushline({ type = "error", str = err })
  if lovebird.wrapprint then
    lovebird.origprint("[lovebird] ERROR: " .. err)
  end
end


function lovebird.onrequest(req, client)
  local page = req.parsedurl.path
  page = page ~= "" and page or "index"
  -- Handle "page not found"
  if not lovebird.pages[page] then
    return "HTTP/1.1 404\r\nContent-Length: 8\r\n\r\nBad page"
  end
  -- Handle page
  local str
  xpcall(function()
    local data = lovebird.pages[page](lovebird, req)
    str = "HTTP/1.1 200 OK\r\n" ..
          "Content-Length: " .. #data .. "\r\n" ..
          "\r\n" .. data
  end, lovebird.onerror)
  return str
end


function lovebird.receive(client, pattern)
  while 1 do
    local data, msg = client:receive(pattern)
    if not data then
      if msg == "timeout" then
        -- Wait for more data
        coroutine.yield(true)
      else
        -- Disconnected -- yielding nil means we're done
        coroutine.yield(nil)
      end
    else
      return data
    end
  end
end


function lovebird.send(client, data)
  local idx = 1
  while idx < #data do
    local res, msg = client:send(data, idx)
    if not res and msg == "closed" then
      -- Handle disconnect
      coroutine.yield(nil)
    else
      idx = idx + res
      coroutine.yield(true)
    end
  end
end


function lovebird.onconnect(client)
  -- Create request table
  local requestptn = "(%S*)%s*(%S*)%s*(%S*)"
  local req = {}
  req.socket = client
  req.addr, req.port = client:getsockname()
  req.request = lovebird.receive(client, "*l")
  req.method, req.url, req.proto = req.request:match(requestptn)
  req.headers = {}
  while 1 do
    local line, msg = lovebird.receive(client, "*l")
    if not line or #line == 0 then break end
    local k, v = line:match("(.-):%s*(.*)$")
    req.headers[k] = v
  end
  if req.headers["Content-Length"] then
    req.body = lovebird.receive(client, req.headers["Content-Length"])
  end
  -- Parse body
  req.parsedbody = {}
  if req.body then
    for k, v in req.body:gmatch("([^&]-)=([^&^#]*)") do
      req.parsedbody[k] = lovebird.unescape(v)
    end
  end
  -- Parse request line's url
  req.parsedurl = lovebird.parseurl(req.url)
  -- Handle request; get data to send and send
  local data = lovebird.onrequest(req)
  lovebird.send(client, data)
  -- Clear up
  client:close()
end


function lovebird.update()
  if not lovebird.inited then lovebird.init() end
  -- Handle new connections
  while 1 do
    -- Accept new connections
    local client = lovebird.server:accept()
    if not client then break end
    client:settimeout(0)
    local addr = client:getsockname()
    if lovebird.checkwhitelist(addr) then
      -- Connection okay -- create and add coroutine to set
      local conn = coroutine.wrap(function()
        xpcall(function() lovebird.onconnect(client) end, function() end)
      end)
      lovebird.connections[conn] = true
    else
      -- Reject connection not on whitelist
      lovebird.trace("got non-whitelisted connection attempt: ", addr)
      client:close()
    end
  end
  -- Handle existing connections
  for conn in pairs(lovebird.connections) do
    -- Resume coroutine, remove if it has finished
    local status = conn()
    if status == nil then
      lovebird.connections[conn] = nil
    end
  end
end


return lovebird
require 'actions'
require 'events'
require 'logic'
require 'variables'
require 'entities'
require 'art'
require 'utility'
require 'fileutility'
require 'strong'
anim8 = require 'anim8'
--nk = require 'nuklear'
flux = require 'flux'
require 'ui'
require 'chats'
require 'buttons'

function love.load()
--  if arg and arg[#arg] == "-debug" then require("mobdebug").start() end

	require("love.screen") -- load the love.module
	love.screen.init() -- Mandatory : it create the main screen.
    screen = love.screen.getScreen()
	OpenLogFile()    
	 OpenScriptFile()   
	initLove2D()
	initDraw()
	initChat()
	initChats()
	testChatNodes()
	-- initLogic()
	--initEvents()
	initUIObject()	
	-- initVariables()
	initEntities()
	logFile:flush()	
--	nk.init()
	 loadScript()
	initActions()
	setupChat()
end


function loadScript ()

	repeat  
		line = scriptFile:read() 
		loadVariables() 
		loadEvents()
		loadEntities()
		loadButtons()
	until line == nil
end


function love.keypressed(key,scancode, isrepeat)
	nk.keypressed(key, scancode, isrepeat)
	UI.keypressed = key
        -- Pass event to the game
    
end


function love.keyreleased(key,scancode, isrepeat)
-- nk.keyreleased(key, scancode)
    	UI.keyreleased = key
		checkEvents("keyreleased")
	if key == "f12" then love.system.openURL( "http://localhost:8000" ) end
    
end

function love.wheelmoved(x, y)
--	nk.wheelmoved(x, y)
    end

function love.textinput(t)
--nk.textinput(text)
end

function love.mousereleased(x, y, button, istouch)
--nk.mousereleased(x, y, button, istouch)
	if button == 1 then
		absorbed = doButtonPress()
			if not absorbed then
				analyzemap()
				pathFinding(nil, "_" .. actorEntity.name .. "_", nil)	
			end
		showButtons(false)
	end
	if button == 2  then
	
		acteeName = getPointingAt("name")
		if acteeName ~= "" then
			showButtons(true)
		else
			showButtons(false)
		end
	end
end

function love.mousemoved(x, y, dx, dy, istouch)
--nk.mousemoved(x, y, dx, dy, istouch)
end
 
function love.mousepressed(x, y, button, istouch)
--nk.mousepressed(x, y, button, istouch)

end

function love.update(dt)
	-- require("lovebird").update()
--	nk.frameBegin()
	flux.update(dt)
	UI.mousex = love.mouse.getX()
	UI.mousey = love.mouse.getY()
	checkEvents("always")
	checkTimers()
	updateAnimate(dt)
	drawChat()
	updateXYtoFlux()
--	nk.frameEnd()
end

function love.draw()
--	nk.draw()
	drawUI()
	drawEntities()
	drawBubbles()
	drawInformation()
	
	
endPNG

   IHDR    à   ,Ö   PLTE     ª ª  ªªª  ª ªªU ªªªUUUUUÿUÿUUÿÿÿUUÿ ÿÿÿUÿÿÿïïïßßßÓÓÓÃÃÃ···«««sssgggWWWKKK;;;///###ÿ  ï  ã  ×  Ë  ¿  ³  §        s  g  [  O  @  ÿÚÚÿººÿÿÿ__ÿ@@ÿ  ÿ  ü¨\ü@ü üx äl Ì` ´T L ÿÿ÷ûûÛûû¿û÷£ûóûïkûçOûã7ãË+Ë³³oo[WG C3 Ðü\Äü@´ü  ü ä Ì t´ ` ØüØ¼ü¸üü|`ü\@ü@ ü  ü  ÿ  ï  ã  × Ë ¿ ³ §    s g [ O @ Úÿÿ¸üüüü|üø\üü@üü üü üü ää ÌÌ ´´   pp XX @@\¼ü@°ü ¨ü ü ä |Ì g« SÚÚÿ··ë×{{Ãcc³KO7;'+{  ÿ  ï  ã  ×  Ë  ¿  ³  §        s  g  [  O  @óÛÿã¿÷×£ïËç¿sß³_×§KÏ7Ë+»§sgWsKc? S3 CÿÚÿÿºÿÿÿÿÿÿ_ÿÿ@ÿÿ ÿÿÿà åÊ Ïµ µ  o pZ Z@ @ÿêßÿàÐÿÚÅÿÕ¿ÿÏ°ÿÅ¥ÿ¿ÿºÿ°ÿ¥pÿ`ð_êZßUÐPÊO¿zJ«sCg;_3sS+_G#K;;/ÿ·wã[Ë{C³_/G3gO                         Ç++ÇO+Çw+Ç+ÇÇ+Ç+wÇ+OÇ++Ç3+Ç_+Ç+Ç·+«Ç+Ç+SÇ/+Ç[+Ç+Ç³+ÇÇ+¯Ç+Ç+WÇ++×ÿÿÃû¯   	pHYs  bl  IÑnÆX   	vpAg    à ÃA!#  q;IDATxÚí½Mo\Ç±ðÏ/0cÓ$o£È|æFEðØ
¼¾#Hzyý.-ü7ÁH,rÌ·m®`x{¯-AìFäúP¤Hà§ÈZÿªêîsú¥ºëPsÒ§lñeªºººë7Õ}^8g¦aK{¾ÙÌÏlÎç/6×Öq´xvM#íökIïÅßNÛ&¸©DÒ¯ëÿMØ?cðjL±|-,,ÌÍ"ê×@PÍµÛí>¼hûAÃ¶×³(s À EÁüÛsÚ¢ ÔHÒ»ñÏÆã¸¹yë·(·")2zÑ ¢ü¿i@ÅþYê D8ææÞn "¯¹·ç);ÇÛíöÜ¡xûe×Ï	Àù92p mXIz/~ä',=@ýþMfÿþ¥Ëà ­®ÐÞÄ7¨ÀÊâ2ªòª87_æ2äÇh1Ð¥ì³óðºæ ²¥W<@Â$½?Ô¸µ57~U!ÓéÿòÿH"T£Bp),á ¡ÖøhRoÇ3¨
@Àãmþw
&æU/ò¡Úm2ðh1h4Þnj~æ¿Y2ÐÎÏãï 9aÞVáµ5;þæâ/1ÀÍ[i@?Eßæúß~Ä &8H«± Mëøùð#8ûö[0ÿ°ESu ymÝÙÜ<$PP~f ãí#m(ZMÅü½eØlä5pa´ LÐ{ñSÿmûP£©ÖðÔ )ÿÿn2 9ü­zQçCBSd5¬}¤>:? ¢Þ?nP:}ú¡Ù(öAðS37ü¼$(Ý30 j~Ê·ó]s òSÆ*éÝøUÿ6`rôþ§ÐGGÜ9B=äç#J¯¶dõ¿+«þ: %ôyü\ø	ª Ub
²ñSfºÏ~Ò¤¢@¸ ®¥Ûs4q¦5ø1/Z Î%°ýo, ¥õnüºâ=ßLPòfà#J¥Ã¥0ê@R6þ£ó*ìÄÿ`Ô  Û>ÿ3Ýÿ[»¡vXÖ
eçgMhÏ ÌÏÍ/4@Vo$½¿	0?ÛØ\ i¦¨vïªJ}¤ÊÈ¦zé#Úc½BÁ¬Æå/Ñ¿¨¤·ãgÂW ò [róþ¡òÿoÕ{ÇNà»pHy~ÖÖÚíd{04@YXü¥ônü¦ÿ¶)Í,k¦¨ YWG¿¥½<ÃÙÀå{uß`3ê@ð¯öo¾¾< 2ÀVü\ø)* DôIÊÀ%´CÛøv°Ü@¥(ÎAëv#Õ^ÈP2[8¿À¢D
z/~ÓÿB£m èTó¿®Ï2G·³ùhW< 7lÿëÞõ. Ö³ñß*gPkÌ7M»ÊüB{¸ëØÅuµ2øe!ç
\¼½®¡¬ÑØX8çáí¶´ 0©÷â7ýcü@¨ñªÞÚ¼uk]qqëÖ¦úa]¥¾3ù¹åhµóþ×}õú­@k}³ð.Ô³ñÛá'ª¨mÚ¢ÍáVò£Îä Îiv[ü%©ö®Ñ
À\ÐlÈ ÚÐÞßô¿ßQ ÆÙ¤¯ëØ\_GlQÎ¯^/Ô ßôô` ?Ð¸ß?mP³' ô¥9Ë¨»0g(ÀhûFÜ £* Øm>Å×Í¹Bf·u - Lêýø¢&xZ¢¤
4ÌÌÌl®ÏàWüu@ÊBÿSr0?ë¥HjZQ+¨¯ß4­÷âÃOT `Ûðqå¥+Ã+³ÿ{% ¶s­ª]ði/¨o¾>0¨< v)½¿:ÄÐñ·µ>>@U `¶g®Ü½rwþ]ÙT| Qn1²YÊ¤V.²BaªÑ­²&õñø ø¿_\Y(ø¸® ¼î%P%o0Ð ^' @k!Í/£ ` 6	}¿ ;@EÈúf6ºrwéî þ]eë´fnìR¬©tmt ©I²BñÛ[z,hRÆï4¨b	6|g?ÏsR'pÎÊdÈ½j70 Âü>Ç×  i½ÿ¬»Âæ ÆHI[ÏFÃ»þÝ!r°iÕøQ	U)t²,¤É¿O²uS¾Ü)Ò;ñ3á'ª²²0áà_Á	ÞK W Äöqë9?¨ãl£APIÆ/Hl/xó¯BÄ&ÃªOzR)º¥~
	9ý¹ÂT!ß@ 4¡·ãgÂOT T¨¹Ñào°úÛ`DWiÛ6m+AÀ¶w¯_º=o ×^eÑë	À$@ãz.~[KKt#5@5ÿÙÿÃ÷áßÿfëny²3dd3 4ê@öOãIð¹Õ­ >ß»o0jPP²!P ;ù®Î3 Î;¬¶`ª=o ×hmGÏÝ=!,K*ê¹øm¾
 £ì¢ !Åÿ=¦ß®2´¯>I$ÿ0÷À'ªa¯hZïÄÏ7¨l	Æÿ²¿ÿvgÕx7J`n²¥é/Á©ö^üÏ¹Y£]ö·Ñ(+:±nåú©TÒñã4èvÿô`»»{!Ç»ÝírAýæ¦©ð}s34H8ü+dÙ ãC4­wâgÂOT`{M]©ÈPè2í\óúOæDp»ýÓõæ\Ó¹ûowÒí5xvWàu¶PÛ¡ÆêÀòþSÖN*èÅø¡B2Ö!d`k«»»Ó»»»ø_|ik[ÝòßxÉ?Mà=yÅ¨Á¨ ]P¥ïÆ ¶âgÃTà5u;ÂÜ¾5×l_>Ôµ`HÐõv~	U®]³ðJ¶G¹Þn7]5³Fçvh1üÍ1HÔËñ#ÁuÀ¬»ÝÝùÝä¿nw3/FÔo}ñà ¾Ø$HþÕ*½+é0ë2t@ JÿdØeõEü|øQJ l¯]»Ö^ýÅÛ0ïúùö5â£MÿC®µõ-ïxký/fÚ×®ul¯ù¶8¸ÞÎ$»æ¨×A<§ë)@Óúñgíë×ÚAÛF0u»¿3Òí¾@ÿÇ\"	ÿFwçË/¿ÜÎðHç¯»¢æ ³j'~®ÿA% Î?×pÞgé¾` èÚµ"øðûÝJÀÑu-ÿ¡}£el,\o5ÚØ5¿v»íØ\x{¶Ù*éÙø¯cü&¼öO+`âðZÛF9 6)Ùé¾FÝ/L~¾$HþÝ/A£ ãùC@wñ`õ»qíø¹ð£U ²Ð @Âæ ¨¿	YCÂk×®«ÖÕõtÒKím:	xýºm@ ÒÒióÓ¤RÙv¿æÛ³VPIÏÇ½ßïKôÚ£ÚÄ]áEà®»¸BÂÏa~~èB¾xð ¾t»?0 
5W÷»/S " 
À¨~7Þ>Ãçú§ø5¾J \XYY¹¾ÿQ® ÀÏ[ú@²9×¾¦öåúB®Sí¹Àt{ ô-\{¯Û¦D*~×ñ
xÍÕ@VPAÏÇâ×MÚz¼/ÛGÒ?@öPºøcÁFÝ\F¬Á åÀö?`;»É
¦ ÜIèÄÏöñsã«Àk×®­¬Ðæ{NÝ.ÜTw0[ R~òKUÓíñâèwÛ`ÁHÅÏþÒ,U0Ù­pêÞª8 >¿ÒCq¦[°<8²Ï"êtÝ\qÚÞ~ðàÁöö6·àÀR8HPõd0xÂ$JúnÀ"þ.Û?ÄOÞøª ·h×V:BXQ×Îr ±4°fèô¬4®_»û:³Ä&Û+ðæ¶Á)¦>
]Aþf
0èJã|úhüZÂvóºkk¹à@ÈömúÎf°ù£² 	$ÿîuÜ ¨¤/âïvùUº«ÜñU³)_l`æVæVTò%÷PXTV,i4 ê]kç¥ÚÓUàÏ5ÈK¤®` !`Áü¹fA¾~½ t¥y.=â·¼~Ý Å¹ÛT¨QÀGlû§Y¡þ9Ov ©?¼óJzÿnÌ3¾
 Ô[4µ[X2	tÕ&;øçAu½^lOJÔhxyl* ð½»8\.\Àð<á¡m{RÔsñ/ñ¹Tî¼.x'tºTvè+¡î?a{!ð%Pp ¨³îÙpümmGðÎ}=}?hðÇÑÔA;¾* Ô[´yëÓ}L^uì?éD%j¾ÑÀ{fb{á\nÑ´J¤¶#þð ºíèS+Ðvs®y.=ÿB?TH<wã0ÈÏñàðwx4øG0Ì¡P_9»Rlÿ Ù°Ks³­-@Ðín÷üz;þÜø*©j6on×åÏgçÛ®NûN¦Â ÕÇ4ýXcÐ´=Þ?¯?¤¸aðOÜÊ²ßídÙÖÿÄ øà<à¾H9°ý3%ùQü=xÀhÊHz7þìû5¨fH[´ynèx Õi] æóÓ^{sì ¨2t` Ô×PóÈ9`ÐëçÔ»ñk ­øµ^8ÇVÀî?u¦xø	*X÷.L wvb
ÿ;;Ý/w¡e[°~ñ¹Rlú1ônü2ÿ¬ôZ°Ú¢Í£XWR ¾å\ûë ¯»j= ×ÙkÁódqN½¿éÝ_¨?âÒÐþ?ýé¶<øã
ÖÅÍ$þÇ­R`°G¸q¶ÿm<ÐZoocmDÙÚÞ l=ç ¿r@üJé¯ µüêÚÿù?¿¢/@:A¸o¿^=BGj?u@ÿv¸çåSoÇoÅèýøùßÂ+¡[[_lmáµPæf¨p_Ð	<è25f[guûW øn)rðKÓ[èI}?°»LµÞø*þñW¿¢o.@*Atàx½8zô¶¯çÂ%m¿ÀfÀfS,n·¯_?§Þß/PÅÇ°ÛÚ_ô÷¨>a°Û0z[Ç% ÀÔeë¾5¾ ·I/ö¿: áá°£o´;ò ãF+D{!Pµ·îb T»;çv`ìè:¸-ÐÇö¶ig÷)½¿`lxìÉü¿ËÈÐú¸A£;uãzÓ­"îG7VHhç7¥·û/Vrµí B ÕÝRú[°­ ló RCõYgX(¥ßà,FáTÇÇ,¢Þÿúõù(ó¨°qüÃ?Ð?>?ã' 'QÑpp@*4µ>bZunHe/uHú<þ'ObýcOøã«´Îª
8©°EjâH4Ó\pá¹'àõ* Ü(DçÓÛñû§½/:@ d08â AÃ8£QÂùGXóãQÜy6ÞÓÏH?_,Vñ?¦ >ñÇWõPÉ« RÌ7s½/¤hMÎ0½døÐ{<ý9¦á-§Þ¿évz¡â@ FóCúÐÖcûHo¬µºÍ {p8¡> ê?` Îª%X/!¨iÒ'Üò Î)ý|Àyü<û·çæx Ô=¥~+Ø~C½TÒø½ø|½8ðÉñ$¸G¾þúxøuÊúÿzxüõ×1=À$@ØhÄ¨ lÄK¤ÿë4_ûã«À9@Ô7âùÑæåøð;( ¤M `sÖ\9öþ¦²Þ}¶ Pñ{  J X%G¬þ~ù©ô-T©û@1*ß$ô79ù§Ó@¯|ýÄS p6úæì¿y½SÙìýdýà×O A?ÄøøÖ?XÂ1¯¿îR£ú'@7 8bÕÀU¦ {Pcp@ûtß ø½ñUàÂ>
~;vü *Ì/Ø-xµ'
à,¿«ÏIÖOõ	æc#é+ðë_ø: ¯¯ã¢Äÿd=bõ° g_[Qz¨F?Fz0ñÇdÆW%Dþ£Ä êÕ§HñGÁ¿([¹Ó0zñc*`SßD÷O+0Io¿Ê {}½Mó¿çk{[ýkD%å@ùO6Ôe*Ô×Ù0oÉ!ôu6²ôOb 
±³6U.Áêè/}×/ÌÍÎFìH!Üìÿ4F~Bg"éÅø| ùw ÿbÉÙV n'ëUûhK  dù³¡û:DTÒê? +ñÓ%ìì%7LúD|Y9;a2úd¥%.í¼ÁZ82HúRýGl*¥} âf®n_Âà>T_48QíAÒKbû7,¯ nnÞÆ­¹~öÒâ§ÚÜÆ¯·c¦ÚË¤¿õßëy¤bü¢ÁÉÉ3%¿ÄR(8üô¿)BËÅïT Êþí[·>¾uû¶ÿéJ·o£âÖ²bd·I MßÇó/Ôñ8ûÇÇøïK$4''hòLpVk>Q¤MêÅø#ÉûXÍ?1à¢Râçc&A^ûÐ"Ù¡OµåZ
z1~ÑøÈør¦èÙÈOÈÍ ì ¥Vü+ï¼Ð´^?fPêýkC'Ñ-a&=8/A~ûÀ"Ù)üÂ
**èÅøEþ"ê4øRÂAB­ùË2àùMëÅø£HåécúèÌ[*NÊó«>]óã DíE»MMÏÇ9Aë$ eôRüI½$?ÙOÉPÚè_ 2åD TÐ7¨
@=ûù2æð±^]Â>ö'ë·Nt µ
Û
@·K¦õbüL;ò! D!ÌîO æ 9öK:ýãü£o@	PA_"þA5 êýÙíõ|£õÛÖµ~+Ø%íÝÃU¡¢èúSÐã(*êÅøJ<æ+Ê¢(ANp?Eæ&0í@öBüütèñTÖKñG*Po6T%PÌ~NÄíüõ[ÈÐ-÷9,l{ÀD·òÅ3'ÐL4­ãO<ÃÌã¼CâÑü»üÀæ'{+ýtü[á$ÿ­ E	{@£z1þFÜ  õ	Í¿mlÊ nü)fÛ;Klº<-:Ð 9© ôvü·Ãø¥â²øââäîß@0³üÏ©pIÿ{;1ò J&ôrüqª ¼xümóoðãÊ¡ $6üÏäÊ0ÝÚÄ6ÑÑ¼ãwÛ}N¨ âNhù!>Ã§c@Ø©
q¬ËÃO>)¬QQd,` I½Ü " ×7 á¹}{R°±¾a´±¾¾aÈ¸¥ó³nÈ´÷*hªM|`$¡Yè (*éø%½í99y: "êl±ªÙ±!	ÿÙ	L;ü¹; ôrüqj \GÃáÆæ8ØÜÜØß7
6×á<CTÎ¼
´ß°®¶AÚHwÐ :×TÃhZ/Ä/àÆ[á¡Ç < T»,J²·L:ü£I+"I&ôrüq l!éø0È%þTäGUP#jµa?ëkï<©lTÔ3AéI(Ïm¿}PYß2Ø`Ná zúôÄÍ`:Kqì 8H«Qfr{&O 4­ãOT =	,^ÙÁÇù¾Ó½2éßpðØÀþÛÐiÚX5æ·wÜHw÷ìît×*ýëáÃúÒ {ñßÎ<ÿÒ aõÊf®\Áð¯üçæ< :¬=tVãüä
þÐ´^?nPHH6ºÒ¥ÇùYø0¾MU#ðfÊç#hïê¥Ù`©{e0Ì>-	¨ ÷â_Ï6ønÄ®ü'¿ôWf'. úF;=áµ¬I ¢âiN ï_4©ãT $`t{ø=¯öáí?	Þ&§3£¾AûM¿}²ìùðó+ÃáóõÁs¢ïü&õyüÅ³ýø7©lÇxïáRøÿ9|m°âÙ3ö4\iu#ËHñt# hJ/Æ5¨
ÀÆfåóÍ²àYw¸HQÁÜlp÷JíÓô8ÑÁðùóçju</ "ÀRüÁ­ëy¾·ù
ñ,~Ñ¤V[}H ôbüQÊ n°zAÉ¸îLXÇLqz¡}Ú »µ>@vÝ ¨ ·âßØÜ/9À(Qêy¾£,¼§ÎMÇ]Ò &:ÀìïATÐñÇ*°×ëe·nÃÛëü ¯©Vl/d· |­gÙ:7µ¨ /â'þøøle#Dd4ÊØROÒüI5þA9ð÷TßÌ¨Ó
z9þAU öö÷ö|{F?ûéÁ×6)7ûû¼>oêôb¢DhêWì{PI/Å/fôùÙ!ütpxt#F/9üÓöfO<ÜÓ, *êKÄ_Ó¿»·×£³<»=øÙKÖ«äìíïEôº=þâ%|îÇ;À)ÂÂÈOMXÐ´Þ/9ÀÃïnAôGGû"½¾ãýû££Ç!`i'OÎ£ÈøÓ
z7~¦ÿÃÇø1¨
@ÌLúîÎà±$Hë÷DôØ~§GfAs=Ûì`Ü4©÷ãßÛu»Q1'xøíwGßûèèhãûï¾û6õ@ÇÑ!~û6L`ÚäVèCÇß=>x% MëÝø¿cã?Ì¾«@à¢·óåN~r+ êBy¢½nÿ%þ¼&xW5úï Mvw¨NE	 MèÃøwwÝø þ¥óÿ-$èûÛðò!È&2D_|½ì ­þÈñwß~ûmÀ£ïPlÉ¨ è½ø¿å üö07  M¸·«¡øR³äV ø½§ó³OÕ¡èMûõó®c ~GÅßÆgí"I*ý«â§ÙÖïå ²ÄÌc>¾½óÿm T0ÌÍ!}aK9ü(ï øö»ï9Â
@yþqD_ÄOcÆGæÖø*JÊ*n Bz¬0@·'ý>Úä=l¼¯v~l?ÔG	³ Mê÷öØ0~ÀÔ JÐáÆ¡ÿo=~(Tà&È#LpV#@äþÛ8`9ß[oÇÿ=ÕÉp ýæÖøªg{vá¸@î,ûv
=¥9è±=ééÄèáÇ2eí \àòíøfº'èCt.~<$Òáa×{©âèñ£#µ=zü éµ 6;ÔáÛ/äçñÑ#°¼DÂbÊë5vüG¹=êãÃ#f|U HÙXÅß¥<Áü¯î[gJl=¥'¡ïi}?ÿDDýáýUU¿¸³¼îG TîïÅÙÀ|ü`¦?²q[Ç~bHÝw¾9RòÍ#üÕÊPFÇ¹ðëgÀÁãÀÿcG­ô´üð Õk0£oh~¿}| ìÅÿüêõBÇÌøªdA ðÛêª½·õj×÷´¾&3	Æûd&ì é}% m@ÙE60¯70ñ û~blxïÿGßü7Ê7P*Zòe#(ÐðåÑdìpd-£¡2øïo8¶ÿoþ[5?fòèâ¤. ÇQ ÈßØÿ&<+ÀoüñU`oueuuµrßWV{`J¯8éEõE{ºô'$è ?Ö
^\Å¥;Å,Ä-bÃ@£ïÅ âþ¬øz½,1@´Àsà±AñTq ?ÊÖ?E>37_ðó#QúÄI@<9÷@\ý	z2|¢ >xD	p§±?.Âç©é*@Û _ ÂÔÃ9_^^Çîâ0ÿ=½BzüO´­Dôyû pä8¯D: YÁGõfÏ?ç Ì «
@Ô¾aüFUlðG/2@õàG±|«vaxe+P¥"ß*BtZuñcqÁÁw¬Ï?,vGtáÂ©¨Ï2 Ògã+é<{e éw5?¶"ßÏÈo| ÑÓ¨}Bxpú¿Êz#ý.ô¨Þn&8Ú¸üÁ¨3×ñ`6Ðx}¯§äã§#£"7ðctô²øS ¬áù£syÌ;tÆ Èw1®ÿï âkÎ"}ôï&æ x=!GÐ[£qôÄçxdÇ¯	ô+tæñU  ºè«°0b Ï¿Ò¯êé3z%q}ÑIp¬@\ª¢`Q¨Ð>/X!¢Ôïÿï, ¿sK ïÈð§2tdMÎðãÂëÀ÷¯J ûi÷Ùðâ<Äå8 0{j·ö	tãK`Q ÃñUR±ÚõðáÃÕfsi©¹
?}¥_m4½¸¾hÏ%8ÒÊ.¡à¹QæùP¨!ë1G)¾^ß|üø¸Ò#6èä!~mzQ óágØÐqàû' í70ùW9b¼SÊûÑá÷
|{'~ú)³ÇGÏñ*öp+äÃ??ÄÇ/~K¨óêÿë¿¸übAÃ90éGÐgLc0DBWdÌi¥ß ýØñe0ý ³Hâe{(£ò *@ßïõaszÈaÄ=yÇø=¡>f97þÌEÆW"þ?ÿæý+ý]½§Pé5^Npà@øoyÈ7Ö*È8½Á÷!ðxñá=*x!:èg¿@ù!¢Û3ÿ¤gZ*+¼x?¢ó×QM{½,ÐgÔú0]¿Zíñ©ÆñP	:Á4ï*Qa´þ«¸Þ ü_¹//Ê"<(L ¨!cõßxûqâ£ËTt/Ñó=CÀ÷6ßó)>9°ýñv	 Ñ;ªñ¶«ÃÐ}®WíSñ3ÑÃñU "ï+óÏ`Bo ÆÃÈ%>ÁK¨.hd1ýC-QÇï¨ K§ Là÷ßA(æàÈQEZÇ½ëÐH`ö=`®üý÷åüþ ¸¤¯óïAz½!sy©¹´¼Ê%xT)Óð+°´~Ìø< ½ ÁïãlÿéÖ\ë4ÿeÞÌÄHÕ¸¤Jùî¨7¢DL&F0-¿tAÛ3ø·üú±ãsdäÊfÐ%¬ Í¿þd}È4bÿ±ø«°§H°%øLÒk0é\`¥«®
°j{¶¼¼|~ýøñå)âo*.ôFÚí¿òÏ^è8²qn	ôrÿø«Ûª÷ñÝO£3h ¥Kr&NðR,÷Ø)ÂB#åóê+OÝEÂç§ÐG	ú\ýHÐG´ IÀ#z¹6þê \Õa¯«10â\~ Z!KÑ5õú¸L«çÕ[o rñ±&Çïÿýøïï'ú¸Á£oþò¿<J9ÀöÀèÇýñ_bº¿ÿåÑ¹õvÿ1 ¹ø+0¯!écà7T°¹W«%½[^õÛKúõ*gùèïï¿üþûäô?z1xô¼)áüã=Q´þQ\§d ôyüÐl|Ôùã«
@Äª !lÕÑ' -`Ö?	{zY0má¢$é+çÿÑÿ}ÿÑûÿ÷Q@(ê_Lw@þI"jlÊkµ~üËÿüO ¤·âOÀ_u ®XK,@[Ïæ÷	L5¨4h®;]ÅßÜ $½1;_|%d¦ÿÑ£ÿ.Qÿ©ôþO*qÚ¼%ÒÁÓmtô3óôVüØuîøª[ó½Ñ*¿KrôLÖVÎ³Äù¦X³Tó4w¨(¾Vþ½cW>>@HP"IT[þNâ£¸GI@êTÓ\1IoÅ_À¿¼ ÇÕøæ¾éª-1M3ôaùøØÉ7Í ÏmÎ­*¼_WF_X×¦j OAâ½§µ¥,ä¤.Æ1£k)ym½d ¶Ãò:ñW Îý)~ ,§JÛ$©D{Ñ@}øM	Ð¤^_2hµÔóDR$é%ÙëúzñWàéÉÉÉéIÓ\^h_¢õÀ\Ò³3 ÔKñK8ûÇê!\TvÁ	à@òONJù4­ãTà©zõ!ÖaNõç[kB½Ð^î@}
{@	Ð´^_2häïýI©>Á2j¥<VQÿìü
z1þAU 'ÃK¡ªÇ)Aä'Hj_¢z²ù÷óÖKñKjþÕ't´è	Y"²¤ZÑc(*èÅø£xJtÓ{_?ÛMáéy¢·6:v$µ;xf=Cå³J¦õRüáÃx÷R¤Õ]Ár¢êgjdÇ¦ùI
z1þ¸A5 ª²¤vAúSÐ= U1,Ü^08Í÷?êýTÐñKz¦æJüîós¬ã¢uìePp ú¦´z|L®ë^ TÔ?bPÇ´B)'^¡úpBY99ÕµÆ0Õ^2P¯æïÿ @	PA/Å/´ôÓÆi}TXjh|³XHjGð4 hJ/Æ0¨ÀÓóÞÏÔ`¡1FAöiâð¡ Ðå#¨¬OÆ/ä¨¸{Ro¥ÖÉ©È©y®bÏ¼"8ýã±)ß' ¢^?nPjcvª÷\ÔS³YrÚ§Nåóä´ NÆ/PB"áí¦ §ùöâ8 $é@ôO5¢Çúd hZ/Æ7¨
@zÇd§EÃ¡¹99ÑG_Rû´Á©Þxøy J
útüAKÏ{KýS§ê\ ½ç¸0 &þñmñL#jFê&ÖñÇ*«8ÆÓìo:Ë$ðÄJ®*ÁNÚK§§CEN ÇG	@útüAê¢'	¢+#Räº ôbüqÊ* 8Â<BNÙ¼æ¹r* Ð^0hÀ« :-ðóÔi@EÓñKè?ã <I&0í@ô¯úàäq/ÔñÇ*ðªÓè)ÈðééÓ§§þÕ(;?¦FØ ÊíÓMxñ)"x÷åæ¦ôBü¦¬ÕjáOÕÄÀÐ<Å%ßx!	²ÿÓS|ýD]I ôbüqJ ùÕq¤W{|eD¤óãéÓíeF6|ëøéàî<	Ð´^_2hAÙÈç{|e¦H8ä	Ê[{çAÒÒj¼¯Ï<iÇ ¨¬OÇ0¨
Àäãïô8_à#
*	q åöi|ÜêñEw¦Y TÐñKxbÂ?¦çùbø.&Aø'rS$ÿf~CO HPY/Æ5¨@¬P°AÑójá;V(gø§fUæÏmÏå7ÙyÜêéó§á± I½¿d@)üãaÀGë4LPp%$é ðïeÃÏápÐbÜK ñ{J¢Uxzâ<Î×¿£É©©Û
½ß Ù~ãðùÓìåO TÐKñvëy¾A}2	*ÖÿðZpÚç?,j~3@	PAïÇïw7¨@"?vH'ÜQç×bÝölJu=Ê,ËØú'ÖËñK!}ÜsJÐ©Êí»a:Ðç[ÕÃ  ¨ /âçÃT`¿ßW	MN¬sµ!¡~û P¡ðy©RÄT@PA/Å/´º]ý9£Ý.{¿Ýi!üy[êõãVd§§ " Þ½e5bPýýýúäóQv Ò÷ºïÛ æ¶w©=¤ðãëéán ôRühp2¸ßÝêÞ£O)½?Ýòs¿*;­mÖ é@ò¯·zïÞý[ $@E½?¾2ÇWÇ(ù þ@]ìí3úT{Ù ?+c¿ÏV0Ð¤Þÿïàà41ÀûÅî]ñn÷ âgõÛ]u£»1@Ä"
ÿÊ#0»wÿþ} ¿§^ TÐÛñsá+f|Ux =Èáá¦õø¿ñúX{H0=0n6Di¯ÏÿM hZoÅ;ðþï»[_<èþþ÷¿ï>øb«ûû/ÔoCj Û1 ïnÄAîÿ.Í.Ð·uÿÞÝ{÷·º i}?ücû§øµ5 BÚà-¿| %xÅACé÷)K{ 
¯Çöð¸Æ¸¯e;Ð6ê9\!¦ )½,>zÜ aþï8P£èë=/ÔowA¶9ûð
qPøGá7¿îý­ Àßß½ßeÿhHúû iø[lÿ:þV0¾ ÜÛíôñøywÏÿ}£Ç2²¿Oú};n{tàæ~Eý^¬²¡îïD 4¦õûÀvü@?¾@v÷ïRi©XÇîº	2zº5ø=$p	dþ·PÖ>?¾øT÷06×½ÿ@
ì0³Dú­-ìçþý`'~®?©Ýø+poçË/wú¦Barð=+ð;é÷UëÚÊÛ^9Ø±ëïí >ÞAC-Òä>R qBQ¿·Ï©÷óøöt|ý¾Ô¼¾OpÇá}Ì+D|ÜódôtÂ¹ÅÜÖÅ"Æ:(üE÷àð÷àhîÞ§+º­P"Üßu"ÀÈ/xf vãoÝç*ôýÒºñWàföhíHïòCêÝ¢=ìfþÇüg»ª½î`7 °àPï"Ù£ïk|\¯ãÛÙ±ùÚ_wm}ßÒÚèÂáH·«·Ò£ôÛ[êVhKç³¨Ïÿ3ø=\·¨Äi ?¦ú	R	 J  Îã7hÝsû¿ï^K÷»\+þ* D<pþ{ý\vw,²lÇÖ÷(ûù¨¨ùÕ¾güös0êä_!{N@Úr â9ÈéÛGôÔW÷ýÕUïÆ¯ìñíãxl=ÆW¦íðpDÀÈÒ«[ûZ¾ÈÝ¸Ðÿ]l¸¥ Ôdyâºó¥4Çî"®Þî¿¥ÿêÒéÿ¾j#óã¯ @¼@1Êöú=S  {êEÑ`KÒôú°­abs«}Ï}~PT¿ouàô ÔÅ§çXLuë#+¡:;8e^»8°:|'~ nßoxt¬âåâïý®úvÿî½üýëAº*O?Ë Q¬ÿá0 D1 z½®º´ÉÃEvJíJHk´l½7Ýÿýþ,w]eÇ_êÑ¾à^âô3~Õà}ZÞèöÁþþÐèÍíöÙpè8:4ìÈ¦ßÇ2·CeÀß]¸ó TËÔ>øs Tá7LüÔ=|sã£#Ú êã |ê;$µÈÁN
7AùûÇè·þK ý£ØÐïVajà2#þîáAþ3ñâ¦R:­ ½w-)½S#AyV`ý7 ZïÅÿ`K9­Î['ô{-ÿvEp ÒÏC»j½G¯Õ¯ýÈ}"øHu@ûÕ '>ïSSÛ5Àá_ÿ:ÔË#®÷_î»jõ¹ìK<Òé ñÑÃÐñè'¦Ûñé7T&<ý¶úÛÝâý£õ?<}ö[XÞ&þ"p;sV#,¡Yv ÃÊ¤þÐüXÑeHMð8Yÿ´E j+°õwð ÷â7>³ÌÌ+yü¡¿= N?U]hþz-®^©íö°ºû;µIs:pzÀEÔÔ1\
øW¨´ÿSr ¡)Ö?èýÀUñí'ãëé¨¤M|êÉ½÷= ïgC«­§bkUf½i= :ðýS	Ì.09ÝXçÜ¿§ T å ¸E4&´F;Á¡5wÕÁ¥÷ã°¥	´Ôü&Ûf|U ¨³¡G_ïñ3ça¹¾Ïèõz;ÒPÛ0ãÀíTu,äOï^Mé¾¯ÆGÈõ>ìE¾rñ.O<ÐÓÿ /ï¥ïnk¾@ª,Ö[t4z:ÌïÀó¯*àðéÈy\ðóîj#óÎ#«:k $ºð£1)J\±H+Í=ulaë½ø©>sª§rË
°kâ¯@%°ßÝÅíùî~Ò£ì¤ô>^¤d;È:Æ^	Áía¯ *JCµÒïïÇOdËñÑñ8@"ñþº°Ë'évÿpß~ÿ(=Dy 6js´è¸1¸þéD5°7pøj%]ÈÐÉóÑy@cå¨4÷õu[ïÆáåc( ¤"À<þJÄýw¶q^=|Ýª¬¯êØ~/vù pÅôóØcÆ×¸ïú4É¸[ ®>towR¯Â?àyz-C>}+Ð9È +%[Ê¤ÚuLÜt¾á×¢:´þ(ìí ófø%ý&ë¥GÐñE/È~ü­}s"(àñÝÿÃÝ»÷þpÿ÷îÞµæß1¸zÜ~y·ÛÑ+ð29ÈýÃFH1æÃ	Ú**ó§ hêjËûÛË®jw:°úÓ?}. hË4É/X¤¼¿»»O+|Ä»^>q÷#Öµúøðrláá@¹UE%õ­ÓÀ`ÒAî½êÓ5>Ýoé>0¸ÜÀ«i}Ã	Ïé Äø­ s©z	ÞXAÜ'xGðËètw÷p´ãï ¸ñâk¨«\ôoNÐèz½¿»N&Dÿú<Kð÷ÿ É¿kÚ9 Ê uLëÝð÷ôwË^F*ïØ¡5PÐ+@£ØQ&êâï#QºwÕN_µåôÞ¾P¡ÇO]±¿+b<ÉÑzÆüEÏÉ3zâÿ»÷Ô/pG°wx­àC(ïß»wÏB´åÿÝ¤wÂsúÇØò4R%Îi&?^Á_ÕEàÁþ/tð½ß?`¤ûìì*â£
pþñÍ¡ÆÜ»«Ö
î·ÓÉFåÿ-²-æÏ6îc2Ë_ÈÏý»h  wÂsû[^Fª0¿%v*èõeÔ{qóS4r_W8uçÞAx3+@!tcÞRG ÞçoH¦¶NðoBM«¥	ì&ÿ®æ¹mù¾} Ó
ø£Ú¥.sÞ	Ïï_ÅoK 6ÒNÔ+@ûÑ£P<ÓêÁ}s8{é3²ßÕg	?¾Fwû>V{÷·# ©?èv£JãwPè"R M`QÀ¸[ú¸ÆÒýèå\z
AIbú×cëúã«¶ÒÍ*ñ
§õÉ%¬¹]¯¡îwé%øØÝ.`LS×prÛ>ÃñyÇ¡ÁvwþêÝ­¥ÛJ4¿O÷áéÃXïDßFÞ£.IÇ&³áãEí7Uûûúo>ö ÄT K{¬(áýTc0æj¾7-³êÔçË£2 ]âÖ¥¿8ÚJ$ïgÚN¸p@þSîài¶`._x'"ó>l{)}#ª·âO¼èÁí7`¯×;1 ÷5qý~´ºäFÂûÄ_ìBXIÇ~ÉÎ~äzz%¶u'M@Ä«¬p]ºß¹0H8ÐþSÞ»_t»_lùÒ]Û¦²C[ÔI«ÞîAª[\¥X%\?#Ki)Ô=-N/ú%³v3øöÊ¼Abï0þídÉú§¢ÿÄ&N&QXÓ}EÞ;àv0¾
¬à $~§InÄ®Om¿À=;Äjù)_ô dë&`kL £ÿXó®º	î»ïzÍèTrSÛHÒ{áIKðp\IÁ+EÏ2ö¥7g]}|%BÈFð/$Ûq¯z6þ¼1x¯Mµü¥°J`-ÀZ&*5µLTj k¨Ô Ö2Q©ÀØakm©Þ°LK*P}k<ãêeËôLÖ¸ñlÿççø&SW`«µ²ÿW"hÝJBl/XC»Pz)~É ¥?å$Þ^E«1FûqÆ+ä>ºçÕ³¿ó_¹áµeÐi+>½©ö²,c'9J×KñK®gþÃÄC^_¾ýk&õûº* aÞ  $L@K ?ËÊÀ×íeÂ¯ø-ÆNÐKñK4ýY*AÊ ¦/Û~Ð´ÞÓGÕ³¿ðîd¾µ<ð-/Ì-#!`éi6h@æ¹wæ@¯ I½¿d@«	~$ÔêÁä'-^-¶Ï hZ_ÄÏ ®®@õîG0 @a 6ÐÄòBP"ÂöLþ4Äù#ç4©âÔüÓ'¢Ñ6èÙ	 cõ/Ôn70
Ä'î!hZoÇÏ¸O¨« yçÝeØ/ÏAÃ±~x÷ß \û¤^<çå@	Ð´^_2Pf{xÃ|ÚEÿ¸`©}øÍe@}?;º²
¸¸ðÎ"î¾W +Ì
é]AËÅw
(¶Ohþæõ
(*èø%yXøññÉ±~\@cN_¶}Ô å\"D Më-57º éíÿ®ÚÁ^6@>` j«ô®[!JµOÐÞVOàC¨ â¨sÏBÔ@È/ Ô>jÐ*, ¢þYr 	u5 ÒÆG-¸Yï@+xzó³¢m­]Ü^4   eMH	@z!~y4çÇôÙ§Çd²õ í­BLTÐO@=ù+xm%L¿Z ÔÙeh1¨B{É@âµìZÐ¨^_2 ò9ÆÌ´Ñ·V°GJ¬p¥Ú¹H4­gâ·RW úåÿ·¬æ^¥R±¸²âlâJµOhuñ
 Mëø%zËÐ^Ô¿ó(¶;°` iý HKÐ AFVX Wt~Tª< Åöi\$ZÂe(W"£
z!~É>«ì¤UÈùÚ¶­± Iý¤ùÇ N/Ã?,SÌAÄòâÊJ¾UòW°t{Ù ¦øþ_1r>@Óz)~Á õàYÿÜ=Z¡[/·¶P4­çÞ@Vÿ)uU{À,kqåxÿÿ_Ëýl³I§¼¨Con/wbüc¥á MêÓñKX  ü¿5½ nâ(1ú Ô^2Àù!E¾;ñ	K*èíø¤ÔUÀV6Z]y·u<WàgÀµº©ô¸b{É ØÒ:þÅ5_" i½Ú²ÂÿÂÿÂ'>)yvbK«|{ÁÆ§>êËÕ'Mê#ñ}R]¸²á¨5À¿aâÑ2%Âl|½×þÏÏ3¡l4hýB5åü 4©âO`8¡ð?ð?§ y O" ÊíÓ4<TQ¡ <7 q}$þ @N]êzÊ ó1ôtôj¶÷ÜÍ(EûQÆ~}FOwu@­QC7ä1­@%½çÏ¸ÂP%Àç§­TúâíËwÐÐOô2 ¶¼J ÒËo ¸º: ÕCUGøÈ;?|¹ÛLj6 g³G£ÿÇó'*èåøã-M?Ä§*:ZÔþ<(ÌVøÈjÐÿÄ¹ÐWWàO?ÍTýúì3 ;ª"_?åõéöAÑ;wx>D@½$¾ÏâÄÍûú)´7nw«#Ì";-©ýy;PÊ¬S5áü¥ ônüÁ âêÊ ¼óé  (}ú)!ÒÓÀ?"úD{Ù 4w ÒOïðT TÒñÇâÃ×¼qã½6ß~ïÆ®¾hß´¿Ñ:hCÓ7y¥¨¨·âçQWàÈ§ÿiÀ_¼î=X$õØþ³p ðbªFã³Ï:B`Ð´¾T|`t7nÞxï½6Ê{ïÁÏLnÞhkáôVûv´}ºR¼PTÐ[ñ·o|ØÀKmn|Ux&= S;È0¼t  æJ¶<62	ÐÏþãÎÆèùÂñÝxÿÆ{¿|åïÁÏLß¿Ñ&_¶9}Ñ>`²PÝx? 5'BãúÀyü  Ï_E âÂ¸qû· ·nÝº½ñ÷8ÝFvç3­ýgwüçy;í!/wî`Úã·©é­Û!AÙvìþbÄUÀ"þd| ðÆ% &A7sÐí	ÀL{0ÞØNAL¸Ð¯PW`6ÂCÓ¢ÑïNþ!~ñônûÏ|ÀÐÏPdÆTÀyn Å¯Ìâ
üé wBm¿XF/Åx#Ë>¼ñ¡^à§,óôáM{	¾éäµË½êVP°4Y  h# :ñ· é67¾ Ä§¯rçS½Â}åO7	Ý½ÒütgäèµÿÌ~ý,Ñ"¦[q+,ôo §RÅ Hmÿöww6Øö&~ßgwî¸ñÝæ>¹£6Ü á 9zÿ&fðÃÙÈbì~IDùv³ìµÿKðÉ °÷áðøch÷a@`?`ÞûÁø*¬lÞQ²ùIXG~ô4¨þýz'Ñö [)ÌüBAýðÞ§chl;Å ¶ã»sÇ^OÐAö?ÔxÜ ßÝüß@ùP¥eèòë¶ 2ëÕôÔ>ýnC?ì[ÂÁ1­øí MC?<k|Õílljù¤ìmý ÇöLLv /|²If¨eåC-æÌÒ.@I`1¾ÍØ 3:;×¾¡¤Mçë¼nz¿=Oãþu)ÙÁ6¾·9 ÑÃÍ-m~Ææ7> Ì¨âKWàuXß"(=¤ôº}¸; 5E»W|(ÎØ	= áë5ãÛ%;@Zo¼gä-©¡AOï´'²§E5?ëöl?½	G\ÞP¬Í¯Ñ
ßÀEü~~xîø*¶Y	 )CI} ´åñæ 6®~îó ¸f÷ð¿`2Æ@[´C½ÕÔ¿º¡ÄB?ßøÊ0ÛÀ!òGÚü12]ÊËX5*Õ#0ç»wÌÃË`W%ýÍhÊé7ÖS	^ß;øäÕ:àFxøìóäkø _Ò?~SDàD{]a8<Ïé ø¢(À ½¿G;G¾DÒUò¸Q ÈPÇÿ b?A
"ùÑú¤~3àÍDH­7@eþÀBür|ü ó³`êDY,AJÍU¨¼½.Á¯Ú¡sMÇ/ßc:PÞ³¡Y£9½q+¡í¼ÿ_2Bx¿Ìã·W
à&äfs#ÀRz)Á	½ ¶N4öëo(¾,@ cÀ&êK #ýò9ÿïñüA	Ì³@»yÀ÷âññ½÷&än&*H)ýFzL8ø¤DëxS½¯¯§ #>³C{/Â6P	úU,¿ïý2ÚÞ8/±QþìòÊîò¬ò°0¯ýÆ Ä%VàúT¢ 8ÝZï"9¤cÆïf åW±©i:þLµ/pçoK±ïµY­½A-PÿðëÈW)­OP"·kÔ	;ZSé¨J×'©31ãÅéÓ`7~Ý"»Ô_§Õ¾ã=qèÆkèíþ³s¨+°Ñj}ü âzªC¼ÊWÂÐZsyÐÁM
Ð±ãûu!£¾¯¯ý:ªËem$½é??©üøªp|i¥Jd+]?Aâ°O½j tüø~óc	Äädô¥vòZJäc4Ñë"6ÞXý:¦ÕÎSàJäxQÙhé;âcJXäC¶ó|[?ú/>U%Jª×Q6R¾s]ÄFÒUMÔg´§Q¸rU²±ìcÜøÔô§JêAýÚläº¤/§: kùyI`-ÀZ&*5ÿ2YÊ%iÑZäÚ×RÿØHÀÔ þdiid©9ÿî»M>CKKÍwßo*»¥ó:ýx7Àdø1jTÈ¤X£2nûé% ¦_}Dæ»ÉüÒùð¯; "ï4 I½~Ô J 3¼ç%À×¸ís7EpÙþôÀ¬¿óî<Íþ;ïp`~P&óï¾¤PpPÂ¿à`#b4­ÂT`6ü+~Í_CþbÄ×¸ísÑH 8ñHèK÷Ï,éÙoÎGÉó3ßÔKçqPÂ¿6yç@	Ð´^
?nPCÈ×íµÁ_)GÑÏKéKöÏ@azG¢è¥pÉRPÞqkà@ô¯ùyçw4óç4­ÂOTàRÎ~Òpä¿$¾ÆmD	 MëK÷ÏeÈy \æµÍ<SC²äG%^°sÔKá'*p`4ô ð5vû"ÿAa¼¾Dü	¥wUææU)Nkª´XâÀ¤É? °dñ|Ð´^?nPKónÞ;,Í×ØíõLF^{PA/ö2X2¿dvò<fSçÊBDp úG ùN¡óÔKá§*ðÝa¿ ù|gÎÙ~ãë¯zÇ (ÒËñ§Ì¥§ &Vy@õ:%È?!8ýE3? (ÐKá§ªð¯V}
5éç ö	>??àÇßãH
úóÄ óÇ`øT1æ ´ÅÝf	Dÿh©EÏùMé¥ðSUXb½Î­Ï³	L¶Oò©ü- J&õ%âO,>0FHÓ0È»
$ÿxáëç4­ÃT·WédHàÇ`Û'ù$þêðÇ&×Ëñ'pw6Â§> 0CÍs8ýI¦^çýË&õRø	ª DFÄÞÃ{ç!¾ÊíS|ÒÇ;ý5ß¾½ðUÐ^_0%,â)nú2bøYp§IÒDÿ8B<4Z2ú ^
?nP0tk²ðT,de~¾ 0gA¤ö	>Í5ü«è!ä« i½Ú ]é~~epe©{eq 6U´Qo2 &þõrJÖKáÇª«ø¨¨+8_ÁGEùáSVtrØ
íÓ|PÞÃùôRüÁ 2ì~ëüçÝáÓ»ìJx-5é@ôßÈÍ§Oc|É&õRøQê Eg8¢Â%*Ã×òôJí>G_ÁvYÆ_TÐËñ@Hñ #þnd%ÿ,#4.ÅzMë¥ðcHó£ùÁ`Ùâ-,Ñÿ¸9¢Ã öi>çªYá/¨°¿lÂ¾{Êü¸boxJ;Ôô¤£ÁÀ° ¦ÂT d}^"ÇM8àwß·áOlæóÓì %l- *éåøe~6BD Êö¬,¥(9H«3uü$[, ^7¨
@H|/¿'ca©¸³£ÈÐÒñÚí|â"êv$@PTÐñ0ØßÏè³¦³ý} Þc©Ç$ÿÞæó${B§h8uPA/1¨ÀþÁ¤®{A½½Ý]øâñç´c× ³â[üíîú¡>¨ â/aÐëïî"ÙþînË¼ØëÑýÆ½g 8ý8÷#w<Jz)üAU Â÷w©Ðï_¯ý^Ï^ó­N/Yüy4ªãÀ¢¿³CÚ¯\H ôÖ å@òO±û»û}¦84­/âð# H|ÿ%]Àúnëce8ØÕIÚÃlí|Yí÷ú.a¨ïïEùn¨ÁýªAXöü5\ TÐKñ0è! ZúAPo­à¼Á~Üíi¥øë.B`Ð´Þ¿Çõ=f|Ìa	#þÔoyH"±G	Âð«Õ~	iõ{Q¾}Ìå¹ MéËÄ6À%:çõ=+A¯w`û'ÈBþ@³K}ð[4Ð¤Þí^dÆW)HÙÁy î©×¨P¨D3 êöÊÆÓ£:Â·&h¡ßÛÓýÌQÆõeâOäüìF é«´àE©dv£,ÿ»Q êL4­ÏãÇïQ {dà¯ª= U%ô%äÏqQ	ÒðÀÏaÈÛSòX5Ï·"Ï¡ñ0Ô½Z" Ôñ`¯¿Oô~À(q*`û(` 	½Àp|ØÀ²ÙËê{ÓOIÁ«9}n4í@U=-¼Q|ú=Ú|íÑ.×{ZhJ/Æ_Â 
>IÈnñ0=æ,"f3èÇØþÁw¯+~xÀ$@z'~®|_U *`\R¥ <êgx7A/X ö¸ÜOÄõS|k}u¥8Ð´^_6èï¨MÚþÁNãC ª#Eæ4b/íÀõüENÓ	
ú<~Uâ¸ømªOÃ¨Ì{[A0Cô¸§Q=Ó«Ú¸v1§!ú)¾AzúÌ¯A|¦MêÅø%à#Ë,Bá÷¶¥êl¯ö?¶IJú"þßAþsÇW!¸0  ~e}þHÚkööfïbú$J`³d¢èG MëåøÓý|FòßX Ó0,i:ËàU<CÝçù .â<xS RqRùg6É´AQ¹	>È$#Wöâ|çfùi¼þ}4­÷âçß@ö{Ù d1§ù\ 5¬?10ë3p08ØïçÞôüz±Ç,ªÛör wYðEÌÐ[L{:Ý²\Ghä/ó|çNööR¾bÆõ^üÜÔ «B½É?½
F ô^¼ÁÁð@þï3!@ª°0×©ö{úHi¿»çÛP]Ì (Óñïñ%ØèÈ aþM:Mß9¾,þ¸5X9Èb
ÿï·ût0  ×ÛñË ¼1 " ¢6¿ÊE×
ó\¤é÷9Ó>Æ·¾LÓÛñïÆÜPMOoaÃ¹+jïs`ûçvyÄGOí9z
Ð\}^½) ÅpÐºV¿ËT8@SëB²öÒ j~AÜ2¿··0®/âõoâçè¸×ð ×9p
@??ÃÃêõ)â~ßDx~Z ¤b Úîñ îp7`~?
ChLïÝí0>@ëB¯ÞC4<½¿»ä¡uàøï°­ú^_¡ËLéÝøþýøñ½ ÷¢[À½èÍJÊ ¡ôJ¸pw7^ãz;~@&þ]À^×p×?ã @Oïøïp­Sú¨G¤wãgú÷â·ÆWjÂ¾"+Ô-ÜþK÷Ôàß@{q a ¦ôNü±Ó0Âüç9¥,Héóó´}>	®¶uJïÊ¾ARz7~¦Û3¾ê ¤¨³¸ÜZu­*yîà@1Æ¨Wc|[ G!ÌU# ÆôEüÑú[èÝüZè [Ï4vvz«ýîÿ¤¾Ô$¡ûÅ_%ýüR-<EîiìkxÙ+uõz?Ú¼a.×Ä\mNÖ[ñGú,võýz»\
}Ä [°z[Ûo¤õÚ(ýÙåßiÿ1*¤ÓÈ-cÎÝ±«tnàÔZiC /÷9÷ ýóè­ø#ýKÖ0 #üØzi}Ñ>2?éæ6\Þò«\ î5x±k5æÔAÿà Aó~ü0¾_XE$'=Ö³ Od¤õæÐ¯(À*þÈµ¨F4Ñ¿Xó
~é@kãPÕÆMG)mz*³ø©·§8_ jðëÝ±87qê^roÑSõ=Ã7O¢>ú¾	bÝ2G'#õ]Ï©¢F¤|7tÝkekù{)}*úÜà ØèKd~ìT{	 }¼ 
M} ¨;Ò£ [òS FïÑ~Roi#³ÖçñSÔ÷ÇW!	ÿ¬ï±¢Ï2þæðô}ÁyÿÜªÂýëie½Ü?o463»ý´Ç7éöo<¾7À½ì«fÊ··íÁ$&Û~5ñjR;úU«¿7ßErªïÕÂ:×³[bg"ÓîØ'ÀªÒ%çFëgÆïÍO09ÌÏP¿ÍÕ¿ó+c9s«>øPù±¥'8¥ÑzÀsÄwæ'JægLa«°½Äèî¹TK~âg·ÑLt¥a8~3¾K4?|{~Æ=E«©.&3ÛÏÌXï Ý1Òéa¦0¹Æ¤µ3´@Y{Àqã»LóãONUó36Ü3ÅÿÑwxÒ¯íäî"Î?¾óÄWÏÏùçgü %&¿:ñ3ù{KÈÎD'¸D|õü¼ÆüTÀ¿LfJ¾vQÇ÷&pæg*óÜÔTo\¹ìó3ñ â§9ØK®á-|~¦2ø9±2ç¦¦kxcË%ÉGÀMJOpù#³7}!õ_#{~¦ öÓÌëªú<Õ4Èe©¢dPÿ²sSÓ.i~¦2ÈäÿÎMM»\¦ùÊ§2¨)Ë4?S9©jä2ÍÏTe*"¹Ló3cÊ ¦H.ÓüLåX¦2¨)Ë4?S9©jä2ÍÏTe*"¹Ló3cÊ ¦H.ÓüLåX¦2¨)Ë4?S9©jä2ÍÏTe*"¹Ló3cÊ ¦H.ÓüLåX¦2¨)Ë4?S9©jä2ÍÏ´eÊo¸\Úùðg^S÷sË;?ÓýÌÚ\âùà;y.È½oV.ñüLGð3Å¿Ë6ÁÈ%é¾xkÏ0º71NR.ñüLGðÁóz9uiåÏÏtÅ?ã}äÔ%àJåÎÏôÄoÿMë%zW&t~¦(þñ?tïrËå-\j k¨Ô Ö2Q©¬e¢RXËD¥°J`-ÀZ&*5µLTj k¨Ô Ö2Q©¬e¢RXËD¥°J`-ÀZ&*3KÎ4¢«;qµØ>eðÅê¿SR]ÕDsJÏc§dëIVÀ³³/P^Æ~v¶êÎZSíqâÇl¼ºz KLHyfm=iÐD 1ê Ä¦=ûÖ[oÍ..vÖ®v:pÔB{Á@xeñºÃÄAL]5ò4iÔ`·¶ÝO4	ÀÎK|[Ò´¨wg0îzØ0ðÎÚÜVíEiâË Ð[ñs#ª+P*m9¢gçæ¯ñ%¹º  b¼/_êÊIôgÇ=«õ³8j§öíE5ñ/^t"xÊ&õvüÌâêj¦áËµh=;ç8Ðøª¯¢£ES'Z@¯UÙ_ Â`_*Âó¸f[l/©uevñxf'^TÐ[ñs#««Px½x©THaäãÅ5zÜüCû4h) qV ^«²Áoñ¥0¾zÕÚýí%=ñ³¸¤à&x	P`;~f	u ¬ßX³,(Y4s
àW³¬³öþC8iÐÒ âÌ,ZgÆP&7ûª Ð^0(&Þìi<$@EÝøÃ$ÔÕeiÈ2Ã98³Qæ¯Ä`ºÖé¨Ý&xz 1ë®/^RÝÇ:ïHï;¡¢Zä|Ií{âÕÆPTØÿ/¸$ÔPðÓi~ÎÃãÙh 8e@>êìv8í ÂÞÞk]|£ù5æE>rwÇLj6°&^ïi<À$@½?7º: 
vµêýÅËlÀ 8Èø@G!(ùZ=ý ®áâpFS¢Nd@*] _¸âíñ¤öikâõL4®gâ÷FPW @ÁM*Tø:þÓq ²8 5åôoÚÄ5òÆï¦3¼Ó zçÄöIkâõÆL4­g	{ðÅð76'þ{Ñé0{ÀNÆ8Âpînú<ë 0ÑhoÎôs¸ÙãvÚ§§=¨ gã·GRW	 ¬ÁÌ4t:ùðR:{U­ î±\$P?ÕªsuðÝ&¼r |#ÇÏüá:¥ë XÔ@©}ÚÀxÚÓt|ï2 I=ÿ;¸º2 Ù?viXÍÆL|¾Á½
ÆÙéÄõ
 Ìâì[ÐõñrúÏRØgg3;ÿß?àßÎÌÙK¶B¼Ä³µ-j/Xwà4 ô^üÁê
uq1NXË=;ËWîÎeÅ@i6°\ÏÜ½2Ì.Ä*úÙèÊÝ¥?àßQvæhm87»Jµ;0ÿPTÖ[ñ3#Hª«°A¬yÓ Æ k6XBnCuÕ_øqäÂ²>â.ó¤A+àpçóÁ`ðùÎpyê'. L{ÛÁ?Rä?*ô/Õ¥ ôøMiu âj9Ó÷ªlø9À3f` Â8¬ø² ñçÃ Z»^BÌýË^Ú ½ÜÙBí_æg2ÎèÜ}¼bâ1Â@½I Æ¯úÔU¸ÖéàH1#:0±ï&CTÀqmÇ/B Nì ì#/-àÂ ¾?$<^¾t t÷¼Á
ÆµHúTÅÄk ÃXÐ¨Þß ®À3¼hÈAu~ð Î/] 8T×t`gåÆakº"Ë@
vÈê½-â/Há°´·½4§ì#Xo t&>)qøÝêê <;íìC~´¦áGà ´Þ|æ Zu ¨U @|³w.ÀL'æ¡:u®.ÎÂfÍ.ÂNÅÐÚôæ X.Ö ü^¡c?Ù º[DÐ>H³i7z*ÁQµ`u ¾@ ÀN>äï%Þ#èìE<! ­ã°ùC ;ä¦8?3iÐ *~µÅ·f³,}kq­£Ñ3kÜvôÛã]£@U iâ×gÇ=yÀ Ðrúdü_zUMôÙÙ?@(xù<©ßéU{"p¯ØÑ¯¿4GkÒ84ô6ítÜÛ´&  xg¾hàÎHïÓÔÀÏÜçc¶ ´ÛÏæíÑB]y×³LÅÄÃ¾»ãôåÕ8ÐÀ/Òñëøl=3Àê\ËçiMÙq.-ÎÒÝkTÆ¼Òã°ÅâI7eÌ.^ a,°[£±Y¼E¿à^yØ)* ùçÙT@®=}iz_ÑÝ|ÖÄw®ZîóéªSp&êùøÍ ^ÅugW@µ¿¤¿éPÓw¾T¯Ó þÒã¥^ÍDHã°K¤j·¾Î^¿	¯Ò¹¨oÔ]¤óêb¾<{éÜ¾´ÇÛ,ü	~Íð¯¸òïd@Ð5Ð¡rê¹ø½ÂÁª´ºªÆ`½f§³
@?|v] `©qØ/c?p §þqêT'è3õÞíÌª¿9Àr¥ÿÞï¬xû¹µCÏÛ^9è\u¶¡,ÀVgæBït`&·ßQ ÐNÇ×ÛË?²z&~]úL|þVÐ`e 6ð&	ê¦çY@Za*4ù»ÆÑIãÌ*Üê/f/
püÐ¡[4ÔÆrH7iÇPüs[gÔ0ÅæËkÀlÇú{Uüy¶CúH8ñ­ã/­ô+ló:#ò7Qå`ô~üÆ{G)ÃÂR°Z ýy:£3öF£÷êwÔf±àO£s5>³ü÷3`Gyþ%OYvÔHpSëòåg1iºÌ@¿S\@rÛÓ-¿h0äxÏø ÛÓ}©\4ñYÈ 9Éí%õ
ßÅÞß*qtr;ÀÊ ¤?°æéª>ûâýU[@o5o´edV	\#(×ÖlÏ-
 J½¯:¿¡]Ôo3:PÈÔ¯3Àrvv·S®aÁïÀ+êë·ÉøMGa©ÏðÃ*Ô@·ëhñ/iÎ" ÒûåùhnNpÃ?÷µ/ÍâWSWHí°: ó~Ô<¨yj¨?³$6§Î>F×cþÙJàk´©T}L?pð©7ñµÎÚo~£þ¢³e?Hà(kÐ[êL½¯ð"úUM Û¿þ2(|Ë¨=*:Lc¥'>?9RìpÃ³3ÏEÕ|­ÃèÝøMöÔªtZ3R»¬À§' ÊMÜ@#Ö§;m¾Jpaï¦@Ê=~ýÍÍÎ(41ùÞªÎ-½Z8í?ÀéÅ?õ² ÄüÃÀv zëªø\ì²gÇè>_:|ÃÓñ+×z](4{þ «p§5*Ü7Aw4îÚ|UoøqXk8Z@Hþ43ô½cHµÇ}U	&È.ðn{W 2h&¿!0ñ¿ùë@½ï¯.vôÄ¥ÞÏX«6 ÀçbQ9<=?Vjüµc<Òs¬@êÇ'o¥¤yüÀèeeÇa-%¿Ô<_  qfÔ7gôfäWxÓæ´ÇyÕ7£×¿àË¿ùë A·ÛtsTÅ·; ÈçZQ9|	â¿ªø2Å~%`u ~ÜyºzÕÛjv>¸Ú	> jM9àÇQ &\( ñtNUãÆÑ|ttvtB@öü®, TxuøbkøàSñø3{uö*C ¯­uLåðM¼ø¯æ,æIîËÎ +PõÎûñjJ¯áñ>v¨Gi§ð#<iÐR Òi«Pðl	üoÎ«Î}ºLªIþÁN³Ý¾»÷´-¶ÏÒFùfÏÔq7D7½4ÔRà¤v®f¡R}dzèÊá[¸ñkàÐÞ¨õªVèV õÃÌSðfQøÜäå¢ðp! Ä"1~àäÐoî°­5jMýêèóöÙxË¥>´´ôp$ÒÑj¦:fé¨OvñOÑ§ò°ÔftÄÐG[¨Óg¶½¿Î_±³òX!y
ÞO#Ú®Üä>üTG^nÒò>ºwÃèít~Ô þH¿ù	4C_3¿¸¦=LìÙìl§ãm;³³¤â;@Æð-pummÛÈáåd(ut:Þ_Q¨÷±ÞWY Ô­.Ôµ¿7 4Oj8?þ¸ØAþÂq4¤q(«H`gñÇ/xy2ýH þ8ÊðB¥?nul¨Hö0}Ô~Ö­0³Ê d:i§¿`#¨j&iêàÐwàÄ{«µàòZt:á «P'à 	ì\«£82ºJÛE$ü¢ óBj0ÐÓDÃÈÏ?]õ!±ÚÃÄªö!³¨ã;0ß8 #«ê0&&qEüêTÕÿbÇÕ]}C JóT 8§Wã ¥sÀ·Þ¥?ÒÂ¹¥2«ò)s4í3zc£@õ
¼÷3¾â¿FK Sá`¦nfDÙh´¨7sþác¿ÐèÜV`rò¡üH?0> ~ëö'ÆL9j^è­9RõÉdÑÝ£ëÍ¯¥·ÚgyûÂÁâln±äEìÇÅN§sõjÀ,[£Àbf#¥÷pñcrý¢uÚ` Jóä 8ËMñã ç¢¨n:FõÆ´î$kàGyêÂ¢KÞm;k%ÐjÔÄZ-ßÁ ã:°?ñJ·Ü«Px µ~ÎwàÄ_$Î~8¥Å`µ &ç)
.tg´4ónÃ;¡3wj õ­ÐÎÄu½:5a¾ÍZ 9í3µ³õT¯f× ;ñJwÎ@	¤ÖCB8ðâÇ=t¿ºy-.ª»à¯§qV 4OÖX ÀÅà=GÃ·¡áDÛ/O´jgLþO Ò[	úù4t7³º_\¤è¶§?÷rz ßÍ7ñ6`T;VzÏ?@¶ëóýV 4Ov	âÅÈ#Pù¸0 .êIèü8ú±£YÌÕ¨]<^@=ª"×Ûí;¦Mç êaæ;Lù¼ñ^@uë 8Ö ®÷ã×_u|æ×\m°R ódï­Gg5wþ¦@¿~¤NgtuÔÑCm -ªêQùo_Vû+Ë`QýNLö´w,tÃAC¸ ½¿*lj ê]¡RJÈë^1ÀÊ çÉÔ/ZlÂ`¡Éì¢ç`1ýì\ã,gö/nïÌDÃoï¸3ßÑ'ÓóßèÖØÝÍr)½¿YwMæ>-uÑ°B ¥yr&iÅ§öOÖO´8Îð;Î(ÌhÓê§)DfT{Æ­7k éS¿ÊÄk:â<ÊÝ¹  N:Z~ÞRø/	OôÔæyj»lòz=¾0óZ¦6ÏSØe |]OSç©ì²ÉëaånF7§Úå¯°××bï^zgÔ*ü:¾¦S¦6°ZPl Í+ek4NtÕyUXË$¤°ZÞ¨Ô Ö2Q©¬e¢RXËD¥°J`-ÀZ&*5µLTj k¨Ô Ö2Q©¬e¢RXËD¥°J`-ÀZ&*5µLTj k¨Ô Ö2Q©¬e¢RXËD¥°J`-ÀZ&*5µLTj k¨Ô Ö2Q©¬e¢RXËD¥°ÊÅpÕúújuÕütN'~«ÕW)G«¥;yÝ~¶rÁ|õzù^å^Y=yÊõêkµû¹ÊÅR©¥²´Z ³/¨WÍËê¥ÂÚ²T:ýµ(^°_ù
eky3_VËWÍµ\` uÙZµkâjN@ô±µð3¿¬¾ÇÕÂ´ðTÓWR.0««Cªî¬úü_µV¹xe½üêÕ+*ãeÕ¦Óª²«««ñêXN. &Ý^|Uðc¼àWýRÀücîT>w¯ÇT`^p^Y¿{ÀbKXì­uôU®Ë_±¨r÷
h¯ßA@õ°¤\D KHý"5µLT.)µ\¹° :OcÞTÂ= Yz®óòWK9¹ )·o¡Ü¶	íÊU¿ZÊÉEPÓòñÇ+dÆ«2µ ¡EñbãÚ«:µ B`á$ä(8veÁªÐ_-åä¨)ø8ç¦,Xú«¥\h Û
CmW¬*ýÕRN.:HBAA²`Ué¯rr±Ü¼/91ãU¡¿ZÊÉðö­Û/·×7_¬
ýÕRN.6Pnc9ºãr{¦$Xú«¥\t ×7ÿ4lÄ¬Vþj)'@$áoÃ!P³^p0XUú«¥\l uDd¾!·××Ç«Jµ`#ît×Äá²¾9Xú«¥\| KÝ+áºÍuîÄqy°*óWK9¹è fÏ_¯-q`ÊU¿ZÊÉp2|þüyFE(¿3Ê·+	Veþj)'À[ëd@óÇãU¿ZÊÉE2´eù&l<°*óWK9¹ð "
ëP\\^¬ÊüÕRN.>,ë¤)VUþj)' ÀÞÞNo¤WXù«¥\| {»ÀËÞîGL`W¬üÕRN.<ÁÞÞ.Ó«¬súÛù«¥\t ¤* Ë³³ÁJÙÛßÞ^à8ráÄeJoWµ´;¿?Þ®rrÁìíeu_ Fk¦k8¿8¨µ ìÀØ`¹%p|5ãÈ°ÙÄÊÍ²,8µíð	?4ñkÖëøS À1å¸Ò\YYÉ?&{>T`¡øÈ¼?*aZ)À%äe811 k«m¯áOcZ8\
 ñÆ!vÞ.Ñ¯m¯áìxLk Ï+À%\
	a/zXQjhzñRþÀÓ¯j Ç`ã«"`Ï³_EÉZ5Ð$N¯ò¤æ>¬G.°ìaM¦°?éÃÀ±ä¢HÄ5% ÔÐveüLk Ç 
Ôrþj©G.<HL¹
øUªýÕRN._=üóÓÀógø·,X¿ZÊÉÅppXy\ýù!Ø§ ¬È_-åä ¸´´¼,¥Y^ÆRû6²\NX¿ZÊÉÅYn6Ki`XØ²\M X¿ZÊÉ% puYÉjÐ'KËm¹² °µ ºÇî4CjU±´åJAÌòWK9¹è j^£À¬bE£[VÉ\ý°2µ ÖUbÀ¬®A^V=^oÊ_-åä¢h¥çLß¿ZÊÉ°Ë!ÀÕÒå,Kú[-é®\ ÏÃAÓòþj ÇË à98¨´ÖüU ?/ Ë®­w\KL.å÷bå,Ëú«·Èe °,5µLTj k¨Ô Ö2Q©¬e¢rÁ±pþ¡Ì°/EýÌ\ðÉJ¹às:3ó¯ðOÕÊÕúOq¨aÒ¼_g^¹V¹iþnßfòf¯ãâeeé5¯åÜrÁçm&GÐÅü70ú_^½²¾ÏÙffªg3n?|')|êT9r 4JÿXf}1õN;±É²ÑÑÐôaj7¯å¼rÁ'°×Ì«W¯x ­Öv9|åèÌÐLèÍõUËkÈ7k³£g±c×Åü×¢`p­Î0RåÊ	ÉÏfÖ~6½`ò3ÉK½GV©SËD¥°J`-ÀZ&*5µLT¦ÀáÚêßªt¤²ì	%­g"¯ÔGåF¦t"fÎ¯>ÏH ½#¦D3 ëÓÖ¹Lé<ä2^qWlók¼¯Ü×¢7«¨vù}+3î.V¹ÕT¬'VÃ0ñîë¯«)ø¹Lé<ä÷¢ïnáÐ#7«X/¹W|_9&®Ê»)ÆS¥;t®»½Ï¸½LéD0y7··j@õSp³Ê+üòq^·ììëÅÎ½4ê<wÇxzÿZ¦u&B ÃÂ2ãX	7«¸·½Ì¦¯sãð|wÇxzÇm-(S:öÐº]Å),3Õ« àX[ÄüÆbOfÝËbUÀâhØ­¥ïyÅéó¯§tâÿåRÏz"&#õ¼+©çaBRO|-ÀZ&*5µLTj k¨Ô Ö2Q©¬e¢òÿEøwÑ¨   %tEXtcreate-date 2009-03-28T15:13:00-04:00Û'Ó   %tEXtmodify-date 1999-11-02T10:27:04-05:00¶6    IEND®B`'entity with 8 boxes
'each box has an action associated with it
	'open
	'close
	'pull
	'push
	'get
	'use
	'lookAt
	'talkTo
'detect right click
'if pointing at an entity
'add actions entity to screen
'after player clicks on one, add an always/deleteAfter event to the game that has an action that reflects the action the player performs.  this can hit listeners the scriptwriter can code into events

'new event as playerAction([listener])
'new event as playerAction(entity1 open entity2)
'new ev1 give entity2 to entity3)
'new event as playerAction(entity1 use entity2)
'new event as playerAction(entity1 talkTo entity3)
'new event as playerAction(entity1 lookAt entity2)
'new event as playerAction(entity1 pull entity2)
'new event as playerAction(entity1 push entity2)
'new event as playerAction(entity1 get entity2)
'new event as playerAction(entity1 get entity3)

'these actions will only have any effect if the script writer has an event to catch the action.
        &Ä c  Z  ( 2 ) . Jumper
======

[![Build Status](http://travis-ci.org/Yonaba/Jumper.png)](http://travis-ci.org/Yonaba/Jumper)

__Jumper__ is a pathfinding library designed for grid-based games. It aims to be __fast__ and __lightweight__.
It features a wide range of search algorithms, built within a clean interface with 
chaining features which makes it __very friendly and easy to use__.<br/>

__Jumper__ is written in pure [Lua][]. Thus, it is not __framework-related__ and can be used in any project embedding [Lua][] code.

<center><img src="http://ompldr.org/vZjltNQ" alt="" width="500" height="391" border="0" /></center>

###Contents
* [Installation](http://github.com/Yonaba/Jumper#installation)
* [Example of Use](http://github.com/Yonaba/Jumper#example-of-use)
* [API & Docs](http://github.com/Yonaba/Jumper#api--docs)
* [Usage](http://github.com/Yonaba/Jumper#usage)
* [The Grid](http://github.com/Yonaba/Jumper#the-grid)
* [Handling paths](http://github.com/Yonaba/Jumper#handling-paths)
* [Chaining](http://github.com/Yonaba/Jumper#chaining)
* [Specs](http://github.com/Yonaba/Jumper#specs)
* [Credits and Thanks](http://github.com/Yonaba/Jumper#credits-and-thanks)
* [License](http://github.com/Yonaba/Jumper#license)

##Installation
The current repository can be retrieved locally on your computer via:

###Bash
```bash
git clone git://github.com/Yonaba/Jumper.git
````

###Download (latest)
* __Development release__: [zip](http://github.com/Yonaba/Jumper/zipball/master) | [tar.gz](http://github.com/Yonaba/Jumper/tarball/master)
* __Stable release (1.8.1)__: [zip](http://github.com/Yonaba/Jumper/archive/jumper-1.8.1-1.zip) | [tar.gz](http://github.com/Yonaba/Jumper/archive/jumper-1.8.1-1.tar.gz)
* __All releases__: [tags](http://github.com/Yonaba/Jumper/tags)


###LuaRocks
```bash
luarocks install jumper
````

###MoonRocks
```bash
luarocks install --server=http://rocks.moonscript.org/manifests/Yonaba jumper
````

##Example of Use
Here is a simple example explaining how to use Jumper:

```lua
-- Usage Example
-- First, set a collision map
local map = {
	{0,1,0,1,0},
	{0,1,0,1,0},
	{0,1,1,1,0},
	{0,0,0,0,0},
}
-- Value for walkable tiles
local walkable = 0

-- Library setup
local Grid = require ("jumper.grid") -- The grid class
local Pathfinder = require ("jumper.pathfinder") -- The pathfinder lass

-- Creates a grid object
local grid = Grid(map) 
-- Creates a pathfinder object using Jump Point Search
local myFinder = Pathfinder(grid, 'JPS', walkable) 

-- Define start and goal locations coordinates
local startx, starty = 1,1
local endx, endy = 5,1

-- Calculates the path, and its length
local path, length = myFinder:getPath(startx, starty, endx, endy)
if path then
  print(('Path found! Length: %.2f'):format(length))
	for node, count in path:iter() do
	  print(('Step: %d - x: %d - y: %d'):format(count, node.x, node.y))
	end
end

--> Output:
--> Path found! Length: 8.83
--> Step: 1 - x: 1 - y: 1
--> Step: 2 - x: 1 - y: 3
--> Step: 3 - x: 2 - y: 4
--> Step: 4 - x: 4 - y: 4
--> Step: 5 - x: 5 - y: 3
--> Step: 6 - x: 5 - y: 1
````

Find some other examples of use for __Jumper__, made with various Lua-based frameworks and game engines in this separated repository: [Jumper-Examples](http://github.com/Yonaba/Jumper-Examples)

##API & Docs##
Find a complete documentation and API description online here: [docs](http://yonaba.github.com/Jumper)

##Usage##
###Adding Jumper to your project###
Copy the contents of the folder named [jumper](http://github.com/Yonaba/Jumper/blob/master/jumper) and its contents and place it inside your projet. Use *require* function to import any module of the library.

###Setting your collision map
The collision map is a regular Lua table where each cell holds a value, representing whether or not the corresponding tile in the 2D world is walkable
or not.<br/>
__Caution__ : *All cells in your collision maps must be indexed with consecutive integers* __starting at 0__ or __1__.

```lua
local map = {
  {0,0,0,0,0,0},
  {0,1,2,3,4,0},
  {0,0,0,0,5,0},
  {0,1,2,3,6,0},
  {0,0,0,0,0,0},
}
```

__Note__: Lua array lists starts __indexing at 1__, by default. Using some dedicated *librairies/map designing tools* to export your collisions maps to Lua,
the resulting tables might __start indexing at 0__ or whatever else integer. This is fairly legit in Lua, but not common, though.
__Jumper__ will accomodate such maps without any problem.

Jumper also supports string maps. Therefore, you can also use a string to define your collision map. Line break characters ('\n' or '\r') will be used to delimit rows,
as shown below:

```lua
local stringMap = "xxxxxxxxxxxxxx\n"..
				  "x  r         x\n"..
				  "x       .... x\n"..
				  "x            x\n"..
				  "x   J  $$$   x\n"..
				  "x            x\n"..
				  "xxxxxxxxxxxxxx\n"
]]
```

Optionally, you can also use *square brackets* :

```lua
local stringMap = [[
xxxxxxxxxxxxxx
x  r         x
x       .... x
x            x
x   J  $$$   x
x            x
xxxxxxxxxxxxxx
]]
```

###Initializing Jumper###
Once your collision map is set, you have to init a `grid` object.
This is fairly simple, you just have to require the [grid](http://github.com/Yonaba/Jumper/blob/master/jumper/grid.lua) module, and then pass it two arguments.

```lua
local Grid = require 'jumper.grid'
local grid = Grid(map,processOnDemand)
```

Only the first arg `map` is __mandatory__. It refers to the [collision map](http://github.com/Yonaba/Jumper#setting-your-collision-map) previously defined.
The second arg `processOnDemand` is optional. See [here](http://github.com/Yonaba/Jumper#the-grid-object) for more details.<br/>
 
Next, to init a `pathfinder`, you have specify what value in this collision map matches a __walkable__ tile. If you choose for instance *0* for *walkable tiles*, 
and you happen to assign that value to the `pathfinder`, it will consider __any other value__ as *non walkable*.<br/>
To initialize a `pathfinder`, you will have to require the [pathfinder](http://github.com/Yonaba/Jumper/blob/master/jumper/pathfinder.lua) module, and then pass it __three arguments__.

```lua
local myFinder = Pathfinder(grid, finderName, walkable)
```

The first arg is __mandatory__. The others are optional.
* `grid` refers to the grid object.
* `finderName` refers to the search algorithm to be used by the pathfinder. See [finders](http://github.com/Yonaba/Jumper#finders) for more details.
* `walkable` (optional) refers to the value representing walkable tiles. If not given, any tile will be considered *fully walkable* on the grid.

You might want to have __multiple values designing a walkable tile__. 
In this case, argument <tt>walkable</tt> can be a function, prototyped as <tt>f(value)</tt>, returning a boolean.

```lua
local map = {
  {0,0,0,0,0,0},
  {0,1,2,3,4,0},
  {0,0,0,0,5,0},
  {0,1,2,3,6,0},
  {0,0,0,0,0,0},
}
-- We want all values greater than 0 to be walkable
local function walkable(value)
  if value > 0 then return true end
  return false
end

local Grid = require ('jumper.grid')
local Pathfinder = require('jumper.pathfinder')
local myFinder = Pathfinder(Grid(map), 'ASTAR', walkable)
```

###Finders
Jumper uses search algorithm to perform a path search from one location to another.
Actually, there are dozens of search algorithms, each one having its strengths and weaknesses, and this library implements some of these algorithms.
[Since v1.8.0](http://github.com/Yonaba/Jumper/blob/master/version_history.md#180-01262013), Jumper implements a wide range of search algorithms: 
* [A-star](http://en.wikipedia.org/wiki/A-star)
* [Dijkstra](http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
* [Breadth-First search](http://en.wikipedia.org/wiki/Breadth-first_search)
* [Depth First search](http://en.wikipedia.org/wiki/Depth-first_search)
* [Jump Point Search](http://harablog.wordpress.com/2011/09/07/jump-point-search/) (which is one of the fastest available for grid maps).

```lua
local Grid = require ('jumper.grid')
local Pathfinder = require ('jumper.pathfinder')
local myFinder = Pathfinder(Grid(map), 'JPS', 0)
print(myFinder:getFinder()) --> 'JPS'
````

Use `pathfinder:getFinders` to get the list of all available finders, and `pathfinder:setFinder` to switch to another search algorithm.
See the [`pathfinder` class documentation](http://yonaba.github.com/Jumper/modules/jumper.pathfinder.html) for more details.

###Distance heuristics###
`Heuristics` are functions used by the search algorithm to evaluate the optimal path while processing.

####Built-in heuristics
Jumper features four (4) types of distance heuristics.

* MANHATTAN distance : *|dx| + |dy|*
* EUCLIDIAN distance : *sqrt(dx*dx + dy*dy)*
* DIAGONAL distance : *max(|dx|, |dy|)*
* CARDINAL/INTERCARDINAL distance: *min(|dx|,|dy|)*sqrt(2) + max(|dx|,|dy|) - min(|dx|,|dy|)*

By default, when you init Jumper, __MANHATTAN__ distance will be used.<br/>
If you want to use __another heuristic__, you just have to pass one of the following predefined strings to <tt>pathfinder:setHeuristic(Name)</tt>:

```lua
"MANHATTAN" -- for MANHATTAN Distance
"EUCLIDIAN" -- for EUCLIDIAN Distance
"DIAGONAL" -- for DIAGONAL Distance
"CARDINTCARD" -- for CARDINAL/INTERCARDINAL Distance
```

As an example :

```lua
local Grid = require ('jumper.grid')
local Pathfinder = require('jumper.pathfinder')
local myFinder = Pathfinder(Grid(map),'ASTAR')
myFinder:setHeuristic('CARDINTCARD')
```
See [docs](http://yonaba.github.com/Jumper/modules/jumper.core.heuristics.html) for more details on how to deal with distance heuristics.

####Custom heuristics
You can also cook __your own heuristic__. This custom heuristic should be passed to <tt>Pathfinder:setHeuristic()</tt> as a function 
prototyped for two parameters, to be *dx* and *dy* (being respecitvely the distance *in tile units* from a target location to the current on x and y axis).<br/>
__Note__: When writing *your own heuristic*, take into account that values passed as *dx* and *dy* __can be negative__.

As an example:

```lua
-- A custom heuristic
local function myDistance(dx, dy)
  return (math.abs(dx) + 1.4 * math.abs(dy))
end
local Grid = require ('jumper.grid')
local Pathfinder = require('jumper.pathfinder')
local myFinder = Pathfinder(Grid(map), 'ASTAR')
myFinder:setHeuristic(myDistance)
````

##The Grid
###Map access
When you init a `grid` object, passing it a 2D map (2-dimensional array), __Jumper__ keeps track of this map.<br/>
Therefore, you can access it via <tt>(Grid()):getMap()</tt>

###The Grid Object
When creating the `grid` object, the map passed as argument is __pre-preprocessed by default__. It just means that __Jumper__ caches all nodes and create some internal data needed for pathfinding operations.
This will make further pathfinding requests being answered faster, but will __have a drawback in terms of memory consumed__.<br/>
*As an example, a __500 x 650__ sized map will consume around __55 Mb__ of memory right after initializing Jumper, when using the pre-preprocesed mode.*

You can __optionally__ choose to __process nodes on-demand__, setting the relevant argument to <tt>true</tt> when initializing __Jumper__.

```lua

local map = {
  {0,0,0},
  {0,0,0},
  {0,0,0},
}
local Grid = require 'jumper.grid'
local Pathfinder = require 'jumper.pathfinder'

local processOnDemand = true
local grid = Grid(map, processOnDemand)
local walkable = 0
local myFinder = Pathfinder(grid, 'DFS', walkable)
````

In this case, the internal grid will consume __0 kB (no memory) at initialization__. But later on, this is likely to grow, as __Jumper__ will automatically create and keep caching new nodes __on purpose__.
This *might be a better approach* if you are facing to tightening constraints in terms of available memory, working with huge maps. But it *also* has a little inconvenience : 
pathfinding requests __will take a little tiny bit longer__ (about 10-30 extra-milliseconds on huge maps), because of the extra work, that is, creating the new required nodes.<br/>
Therefore, consider this a __tuning parameter__, and choose what suits the best to your needs.

##Handling paths##
###Using native <tt>Pathfinder:getPath()</tt>###

Calling <tt>Pathfinder:getPath()</tt> will return a `path`.<br/>
The `path` is always represented as follows :

```lua
path = {
	node1,
	node2,
	...
	nodeN
}
```

Each [node](http://yonaba.github.com/Jumper/modules/jumper.core.node.html) has `x` and `y` attributes, corresponding to its location on the grid. That is, a set of nodes makes a complete path.

You can iterate on nodes along a `path` using <tt>path:iter</tt>
```lua
for node,step in path:iter() do
  -- ...
end
````

###Path filling###
Depending on the search algorithm being used, the set of nodes composing a `path` may not be contiguous.
For instance, in the path given below, you can notice node `{x = 1,y = 3}` was skipped.

```lua
local path = {{x = 1, y = 1},{x = 1,y = 2},{x = 1,y = 4}}
````

This is actually not a problem, as the way from `{x = 1,y = 2}` to `{x = 1,y = 4}` is straight. Anyway, __Jumper__ provides a __path filling__ feature 
that can be used to polish (interpolate) a path early computed, filling such holes.

```lua
-- Assuming: path = {{x = 1,y = 1},{x = 4,y = 4}}
path:fill() -- Returns {{x = 1,y = 1},{x = 2,y = 2},{x = 3,y = 3},{x = 4,y = 4}}
```

###Path filtering###
This feature does the opposite work of `Pathfinder:fill`.
Given a path, it removes some unecessary nodes to leave a path made of turning points. The path to follow would be the straight line between all those nodes.

```lua
-- Assuming: path = {{x = 1,y = 1},{x = 1,y = 2},{x = 1,y = 3},{x = 1,y = 4},{x = 1,y = 5}}
path:filter() -- Returns {{x = 1,y = 1},{x = 1,y = 5}}
````

See [`path` class documentation](http://yonaba.github.com/Jumper/modules/jumper.core.path.html) for more details.

### Tunnelling
Normally, the pathfinder should returns paths avoiding walls, obstacles. But, you can also authorize it to `tunnel through` walls, 
that is, to cross them deading diagonally.

Let's set an example:

```
local map = {
 {1,1,0},
 {1,0,1},
 {0,1,1},
}
```
`0` refers to walkable tiles, and `1` for unwalkable tiles.
Let's assume we want to move from location `[x: 1, y:3]` to `[x: 3, y:1]`. Calling `getPath()` would fail, because it can't normally cross
from `[x: 1, y:3]` to `[x: 2, y:2]` (because tiles `[x: 1, y:2]` and `[x: 2, y:3]` are unwalkable), nor from `[x: 2, y:2]` to `[x: 3, y:1]` (because tiles `[x: 2, y:1]` and `[x: 3, y:2]` are unwalkable).

[Passing a fifth argument](http://yonaba.github.com/Jumper/modules/jumper.pathfinder.html#pathfinder:getPath) `tunnel` will override this behaviour, and cause the pathfinder to *tunnel though* those walls.

```
local map = {
 {1,1,0},
 {1,0,1},
 {0,1,1},
}
local tunnel = true
local path = myFinder:getPath(1,3,3,1,tunnel)
print(path~=nil) --> true
```

A __side note__ though, that feature works perfectly with all the available [finders](http://github.com/Yonaba/Jumper#finders) built-in Jumper, __except Jump Point Search algorithm__, as of now.

##Chaining##
All setters can be chained.<br/>
This is convenient if you need to __quickly reconfigure__ the `pathfinder` object.

```lua 
local map = {
  {0,0,0},
  {0,0,0},
  {0,0,0},
}

local Grid = require ('jumper.grid')
local Pathfinder = require ('jumper.pathfinder')

local grid = Grid(map)
local myFinder = Pathfinder(grid, 'BFS', 0)
-- some code
-- calls the finder, reconfigures it and requests a new path
local path,length = myFinder:setFinder('ASTAR')
				   :setHeuristic('EUCLIDIAN')
				   :setMode('ORTHOGONAL')
				   :getPath(1,1,3,3)
-- That's it!				   
```

##Specs
Specs tests have been included.<br/>
You can run them using [Telescope](http://github.com/norman/telescope) with the following command 
from the [root](http://github.com/Yonaba/Jumper/blob/master/jumper) folder:

```
tsc -f specs/*
```

##Credits and Thanks##

* [Daniel Harabor][], [Alban Grastien][] : for [the algorithm and the technical papers][].<br/>
* [XueXiao Xu][], [Nathan Witmer][]: for their [JavaScript port][] <br/>
* [Steve Donovan](http://github.com/stevedonovan): for the awesome documentation generator tool [LDoc](http://github.com/stevedonovan/ldoc/).
* [Srdjan Markovic](http://github.com/srdjan-m), who reported various bugs and feedbacks.

##License##
This work is under [MIT-LICENSE][]<br/>
Copyright (c) 2012-2013 Roland Yonaba.

> Permission is hereby granted, free of charge, to any person obtaining a copy<br/>
> of this software and associated documentation files (the "Software"), to deal<br/>
> in the Software without restriction, including without limitation the rights<br/>
> to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<br/>
> copies of the Software, and to permit persons to whom the Software is<br/>
> furnished to do so, subject to the following conditions:<br/>
><br/>
> The above copyright notice and this permission notice shall be included in<br/>
> all copies or substantial portions of the Software.<br/>
><br/>
> THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br/>
> IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br/>
> FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE<br/>
> AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br/>
> LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br/>
> OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN<br/>
> THE SOFTWARE.

[Jump Point Search]: http://harablog.wordpress.com/2011/09/07/jump-point-search/
[Lua]: http://lua.org
[Löve]: http://love2d.org
[Löve2d]: http://love2d.org
[Löve 0.8.0 Framework]: http://love2d.org
[Dragon Age : Origins]: http://dragonage.bioware.com
[Moving AI]: http://movingai.com
[Nathan Witmer]: http://github.com/aniero
[XueXiao Xu]: http://github.com/qiao
[JavaScript port]: http://github.com/qiao/PathFinding.js
[Alban Grastien]: http://www.grastien.net/ban/
[Daniel Harabor]: http://users.cecs.anu.edu.au/~dharabor/home.html
[the algorithm and the technical papers]: http://users.cecs.anu.edu.au/~dharabor/data/papers/harabor-grastien-aaai11.pdf
[MIT-LICENSE]: http://www.opensource.org/licenses/mit-license.php
[heuristics.lua]: http://github.com/Yonaba/Jumper/blob/master/Jumper/core/heuristics.luaEVENTS:

new event as [onClick/chatAction/always/onkeypress/chatevent] = start new event
add event [name] = add current event to adventure plus plus
event.name = name of the event
event.deleteAfterRun = delete this event after its actions are successful
event.resetAfterRun = reset this event after its actions are successful (only applies to timers)
event.time = how much time should elapse before the event is triggered
event.logic = any logic that should be true before the event will run its actions (see logic section).
event.actions = events that will be executed if the logic is all true or if there is no logic
events.falseactions = events that will be executed if the logic section is false.  note that these events will only be executed if all logic is true except the last logic sstatement.

SYSTEM VARIABLES:

mouseX = x coordinate of the mouse
mouseY = Y coordinate of the mouse
mousePos = X,Y coordinate of the mouse
keypressed = 


USER VARIABLES:

set or append [variable name] [value]
	[value]: 
		pointingAt|[attribute]
			[attribute]: 
				name
		mouseX
		mouseY
		mousePos
		keypressed
		keyreleased
		variable|[variable name]
			[name]:user defined variable

[value]:

pointingAt|

LOGIC: 




Entities:

	entity.name
	entity.xy = location of entity
	entity.boxes
		add box = 
			box.xy = location of xy, with entity.xy = 0,0
	entity.speed = 200-300 or so.PNG

   IHDR  Ê  r   ·Ó7   sRGB ®Îé   gAMA  ±üa   PLTE      $@'~8 x P  x | @  E  P  ~MHHH 06up(ø ¸   ÀX øx]ÔXøX@uÔÂ¸  ¸( ¨ U°(`XØ8ø  ÷6eøx øpø@p÷e]øphhøå ¨è °Ô.Ø 8ø ø(ÀøøÀ ÷÷ øÀp÷ÔeøØpØÈØØ¨øÈ÷Ë¹øøøÐÀ÷÷÷øøøÿÿþÿÿÿ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         õ¿Á   	pHYs    ÒÝ~ü   tIMEß
2"Ï
   tEXtSoftware Paint.NET v3.5.11GóB7  Î³IDATx^í½cÍµ4(6qüÈÖÜ%äz^²&&	×»yc°sm±ÿÿwmUsú{¤10D¦«OL®îIî^}<à~¤|À¿R>à_)pÀ/8àÀAÊðKà å
''ççïÞ­VÓtyyw÷áÃõõv{zúúõ§OnpÀ¿-~´§É/Á	à)0,åi»ÍZf§Í½ö âääÝõõ»C³üa½>;{õÃõÕÕí­×GG/^¼ï3ø±RÑiß½C¯µð`m+ÁC»ý&iÓtëÇÐÚdW¾fÙlnn¶[ºùâ"fåãã7oÞ¾µø'ÃÊkÖ_>²»úí$etÚóó×Ûl2Ðönhkæ°¶ÐL{4il*¢«Øjµú8ÝÝÕ=F'à¿
ld¾Â¢ÚJû¥\­¼Øis¯=X¯_]_¿úêfôµ®§~S"|%³×¦ÞøFÛ{ÁÊ9Ô:U©A ¨ÕêÝ;ê!'Ù_õ¶b'Pì
J¾¼,µ!9|)NðXl(êó¡\y¡Ó¾z^k!áÁÚVvû/LÒ¦éÖ_­? mÂ×«hr¸YyÉpÝw¶¶§~cburBÌ Óö0G³Os¨Z§ "V[ü³BR5pS1Û%RfÑ4øºÅ%	ÿ¥¯]OývD2:íÙ2´½Á9¬-´#ÓMè*|nokwÂh½´ÎBÃ¯VÚ£I¹Ðw!N,pñ "pn7NBÉ¦:~äQJÛq.bÅsÉþ6/!å êßèfÙ½E>«wX7à?«zØãH¹ë©ß%AÉl¥to´½H`+¯4±Z§*5µZ½zÅÊIöW½­Ø]AÉWW¥;Qò×¯¼Öp§¡¨Ï ­HßS¿0úýÁh1ÂLwyéÌÅS,S\"ÇSªÀXÊYÿx½U¿Ãñ9Rg2 %±6w+,»Ê 3¬3âúßr~´=õ(B.dÀ:mïs4û4ªu
Â B+/+$%ÙQÓ73¹MPr)eM¯[yqpXñõ¶Wî©ßÑ¸CÏ_¹¡ 0ÔB0#TO±4wøä>eZcOós¨ÃV¥êG&{«~r7Ýy½Ì2ÖÿËJ>GV¥28{(!Ó«ë	ÙùîG3HYÁjñõ¿ÿ·¹y½~þüåK_NBßX[à*âAD<àÜn¬CÉ¦:~äQJÛq&¢\yÉþ6¯ å êßèfÙ½E>«WX7à?«ÝcI¹ï©ß0);qÞ2DýF²V±é)[×òå×2°å1a0%0¬±^A-¨)ÖÌFÚ¬¬RðMDBÉ$ ä¶ù¶¶ã?:[Ót£aVÖHt³ò£H¹ï©ß@ýþ`´Fa¦»ºrfâ))®ã)ÕÇ`,ezX	ôãIöVý,Äç`H%JÈ8ÄÚÜ®°ì*Lî·ÎqýoH9Ô}Oý.*kóÇ9ø<¹~½\AÀZCX[N¢taé1¯2äÈoKAÈ'¦m¤Ä¬kI&,¨ºí%8×Û^Ù I1fÊzNÞ¡oAåÔìévûéÔçi²ù¥.)ï¯Gî©ßÑ¸EÏ_¹¡ 0ÔB0#TO±4wøä>eZMÑ³3¨ÃV¥êG&{«¾¾n½^¦;IëÿeD%!«ÒKFÃ=éråõêG3HYÁ/®Òúú]h¹!zhJÆ¯k¢DkØíaípQML<fTjbÖGVów'ä± ¦¸F&äfêBõåô	Ò¤-æú,5{ú	x½ºfLEKáDFð2ÿZô=õû&e'ÎZ¨ßHÖ*6=ÅÂpëZ¾Ú"²ìGyL!LÉkmåeið
jAM±f4ÊÔfeÿh"J&%çàdÒ,ø££#gkºXy½ÒHt³ò#I¹ï©ßà·Á÷;õÖ	nV 	ÕA5_Ûã5Ö¾ÉO±HO!¼O¤]
!ìù±D C³¹âñy_Õ?®&Ê:1qca,x1 õø>Q¬ð3*«*5þúUjiü5µ<¡n1¥{øzô=õ»|¨¬-ÎZçà³,æú)öjkAam9NÐ¥Ç¼Ê,#5!äµi)1ëZ&ª.a{I" e [2)ÆLY¯ÀúS³GÛíû#T¢§!f£l>kDHy¬@/gß¡ÎTf1ÅPÑåQ0</	ûúòä|4¸0'Û-ØñlÜ>Å0ý	~õ}ZíZ.T 0r|@eTäb^ÆwÂi]´ÂÀ	jÁr3JßÓkÎ½V¦XDØGfÒìkH9få·¹¾îzêw! åèM (¿®eÒí7¹rÕÉÉcF¥¶!f}xdõ8{µ&§°5ÅuÄ02Ô$73 P7¢¬¯¦÷¦	1¶Ä¢fÞ/ÌÇ-yÁkÊüKà¥8a¯òózyI|<}-ædÿP8VÁIªL¥ÑEL¹Àèdý#b0¤¶þdÊpó«Â?Ad' 5»U}<	Tµúô:=pkûéü#KÊªwÄêÕ8y7ùXÀjá5²,pî5ÙHYïqyMØ2«¢³¡å»»Þa9P|%ºú]ÞM"8\ë=¬u¹ò¢:¨æ³k{¼ÆÚ1ù)é)Wji·O·òBfs5Åãó¾ªcê¡¬s7ÆPßHé=¥V^k~FeU¥Æ_ó+A-O¨[Fé¾^×LTïøGs©cbéùsK"NÑo!ÖwéûÓ§§é¼CßV¿9ÏôzuÊñIÊRèæwFXHC2ÕÞ´V§Øw(`ûÉ¾R#ã{}ýéõ©/Òy3\ÿ~ba¬z®EwÄ
¬S{ôMfXñ³¯s	³2WÌHÔJ4YIc"ïççò;Õï^Î¾£vtB©$Ì" aQ]Ã³0o:¡Yµ+¯õÙü ØÛ§Ø5Ó¯ñ«ÿìÓj×r¡Áxã*£ú »ôz0¾#Ði9­VX£,73àP¨ô=½àÜû>ùØ?2f_@Ê1+·´¤¼å´løºIy eÜ gmê»t¯)¥¬÷A s d¦ØÆ@ÅVym>a^5Ë.E&"¼AppóiÔêqúZ+[<+Ì×ËV&Vi/zîÃ)U<±)Ï¢§YÊfXi{ÝÓí'ÂYrÒÏ@ÛdÐLLa&7ÛRx&åfÙ=îÞ½»Pø#JÝÉÏwêå%ññèuZy)	«`$U¦ÒhEÈé"|å¥/tõÁÚú)ÃÍS¬
­ßCk.w«úy ¨jõþEzà^iûþìå©SYõX]³ëW/¬^ ËÇ9é^@õù¸¢³¡åÛÛõwX^@wû¥ê¨¡K²bEM(ëýYÊ4¤¬ú#MÎ´2mÐÍ¯c%Å§iÎÄò0ÀP÷:få×Ê2GJÌä©(äÓ²eÃD.¬Gºý üöW+¥nuÇ9M@4©L»)³ðhÍ/K¹¢#'=üî'ú~Êàê¿r:&¯8·$âýb}¾?}tTÎ+ôm%ñy¦×«£¼ò*KD"¬)½Ùð_(äÈ¤ÌÕýJ+ÅSìzýê=ElßÛW3Q*rb<p¯¯ß¿8òE:oëß÷,UÏõ°èXaÀÂUpj¾É+~öu&aöRæZ)&+)sLÄâýìB~¥ú}1¬ð¼1ô°èÛ.eif±î_Xa´wæub0¢×\ 9ÓÕtÍ½0ÚR¸SAHùóeÁh_ù°Gt°È¢´X¬J¡L]ÊT
©ÐBFÎ8o®«©ß\ä 4M =Iø:óÿÒRù;ØM)§Ûf&ühÂÍ\<r&Ù¦¾Kðb(e½ÌZÔë%3EµòzÑ¬¼ÌÄ2EË!îcx+/L£V£ZÙâX	Ì`¾^¶20±JËxÑs/æH©ZøãÚ¦`<e)b¥íuO·+fuÄI? m@31=W¢EÅ1ùç½¸¤@¶`¦ÛW¯n'þ-¤|ÝBµÞ\¬ÕÉdl0û£,0ðkUìb§
ðÞRøäYBR2Prr±®­B©Ùúê@­YthËs!òz·_×wk¹Z¼Ð4Y ÀjUÙxJ¦KÊ;YÑ®xS|ÔfKX³<¨3üF¿Ä=!¬º¤è(+ö`YÔ2°Þ¿kå49Ó^Ê´A7¿,&~ïc¦9G[ÊÃ@&T$´RToJÙë5SQÈG!eË\<"XtûA¤R·ºã& ÆT¦ÝÀÃÙ
x´æ¥\ÑÆ~÷ó«ë>1mí!ÌTº\´¿î}.ÂJV%¡IÑ±"òÍIHEX¥`]Ïæ¤m,ÒL§zDU`¥"ãÄ):¥èjJg3X¡NS(KèC§vN´*iáÕJÿJ7×pEßFyN¤ÅºaÐÞÁ^Ë@¦¢)ùMâ¶Üq´¤¼æüfY0äW>ì,2¥(­ «R(ÓhO(?Th!#gÈ7×ÕÔo.r &$üGùe©üì¦Óm3¯_yõq#è~©æìÓÕR8Ø%C$5ÔýÚÄu±óÀKâBX~=ÿ%Ùê?¥|*`\ÄU
hÒ(:j	?Ð¿2§ò5ª5*÷Ká=,ºj½¹X#ª/É0,XKû£, i· y¡@±òBx½F\¬ëA«ÁFªc¶¾zPkÚò\§¼^Åí×5¥;«ÅM`	¬V-Ào²MWZb!s'+°ûà£6[ÂåKÑ'fp½øÒ<¸ tQ^ê
P`!<É0ÍÃrj0ëWBý/1Ç¨2t¹P¹Eº+	bZaB`&EÇ¶a.ß¡Ô©XU
Öõiå%ÑÁ®ªGTE¨	X*2N¢S®¦¡Íhs,ÀDYb½ÖNíÊ+Ñª¤W+ý+}ýUøæø:ïÎÁº_ê¹tµÔÂvÉÀ I~åÄu±óÀKâBX'ºòÂøý{ #è._£Z£rãëRð£ÁÏ ã3òå`ÿ!<8ìµðÀ`^àÁõðx`H¤òRWáIiSÙ\GÉäþÝçuú[±~N<)/wºÙ©#XfõTÁï|¸Þ¦o¡ðKÆgä;ðc¥Ü	©W&ýÇ3T;"ºéªÍ½K6F_©§}qÛàÌ¿øw×éoÅvàGvÓ[!`wm÷©6iUÚQ·á­À]vL¸e>m2 --;ê%¿33dQçÒÄ¾\ôµís?+Í;ÝìÔC,³zªà÷JÐGÓ·Pçñû@è-©´#@ÛÄÃïg:3H«ºo=RË2»#jG÷¼ìÆÊæèp`ýÒÐ¬I·Ýî('ßôÌpò	¢R¯,L<ûg¨v"DtÓU{l¾ROúâö2ØyªÞÓmè¨hþ)ÃØ,Àüð×í´r±lQ0¤ÝLS¬U»v±dåXÒ7F£¤B	ÕLKZ]§&è¬¿Ùô9$åËí?ûÝüÃ`z+dÒì®í>Õ&­J[0ê6¼¸ËN	·Ì§Mô²E²eG½ì]y!: ¯¼ôµíssèãmf*:nKtÒLcH·ª¿J¶Hé²µÕoxëÙPÉjå®ïïX2',Sí¼ZÝ]¥-gZ¶z§
$+¦ ¸·Ì;öÉîsJà>EÛÕßV[g BoI¥êÌ&~?Ó)AZÕÐmxëùZ¦)ÜÉÌ¨P;"¸çe7ôP.ü3@?$ë`MºívG9ü¦gsèâÕ¡ÙÃ<ÜÁ4CÕDCÛçT(n~ñÛ¼{wûÛ²,eÃ­´²}µ³n©dR$«ÔnVÜám0(ÿ,f/Z6)wë@ÂÍ9JÛU\ {Z¨\þMRþ·A9ûõ,ØyªÞÓmè¨hþ)ÃØ,Àüð×í¬MZ¹ÆX6È(Rn×ÓÔ&kÕ®%+Ç¼1%jH¨fr\Òê:5AG , dýÍf Ï) )_m·øI÷4Ö {lÎ`Aaª;×2Ç¡ Êd3Å?¯ÈL§]Z.n[f$pÓ-Ó)LÙ*lèRÎÉNØÓ*
µ-ö¼ÝöYI"äiép³·º8ÅKpÉùàR¦éß^_BÍÿä1dÛÁ4#$åØáÇ ¢í¯í'Rú,gmõÞz6Tr¢Z¹ÛÊKÉ@²ddLµòªî®ÒÊ3-[½SS ¯|ÐHÄ´÷HvYS÷)ººZ¸òrP,MÁ4ÃT}Ò¦ÔÔÒI
g)O7¹× &Ïëç»Õ´\ÊL;ÙÒ9I)HgßEÆàÍnö]°µ¡P;"db#¶'±¤SW6LüþÉïº`Lâ]Öä$NPÊ\4³¼HÖ§QÕmÄÚ`õó?å©:4{;¢3XfÈð¯³rhû­,[â¦c¬]ïÞÝþ¶,KÙp+í l_í¬[®dÚÍ%Ê?Ù£MÊÝzpsÎ#Ræ6BèÞ¥Ö&*W£röë@dèÈÏ²%:#z"(LK9n¦+¼Ëû~æé,-ë¯²w;©+¼{ç9AÊ¢©ÜsÑ¤5B&û]9(#Tbát®ÊÏJùü*ÒD P¯÷Wá¸Àem©,9ðæDávSV:N£-æðÔ/KÎÐ=@¶Dg° Í0Õ­kËãPs+ßÂsÚk¢'ÌÓ.-J·¿-3¸ééJ¦l¶Ö²Bdë$özåÕ%I^!  LK¸Ôe.¶0Âa&£S.vJ¦ýÊKÍÿä1ÄZ]Ø{ÐJÿ`º?Í0kY¸¼¤ScsyÑÑ%utÑ )#'IÊó©'I9½3È$«dàÒÁL­-Ó0A.v´WÛäqu;ÉbÏ{º6
bT0)O+­.¸¾H"Ëñ£:	¤h²uï6¯\Ë`Ãé §hlà\ªÀMÌ¨%:i©0û¤M©¯¨¥u
çVcmËL×Ïw«i¹v4³¥)sRÎº2.oFloß[
e±Ó4ñ%±¤SW6LüþÉïº­ÑyWÉÃÑ)ÍqPm­¼¼þÔ«ÿ)×LççèÏUiþÁta*8,i]Fq.8õä3¤½» 4eÒÊËÊÈ&§tSnûiBÇÎâæ$¤ãd¿M°ÙÍ´H{ÞÓOÒ@)­¨êÀÿYÁlîÚS.T´å+aëÂc&-«ÕOüÜééZ¢3(©9bÀ 'ò¹É´Ãá9aÀ÷³0OgiYýpåõêç)k¦rÃ«h]i	Å~[$ÊU§X8«ò³R>[cqUÆrcíâþ*ÕÊËRY6+s(áÍÂí¦¬tF6[ÌáqãÌ%MguÏæ=uè¤¦ßiSêÕ'¬	%\ÌKT ìJæÄéûßF{@¶.-§Å½:å¹$mæBuaª¼¤ådHCµÿÚRAÅ0e$âf7ópmÞïºS.²Eq'¬]1W?-ö´Ò?îO3LåZ®®Øì±¹<Âèè+k eä$iAy>õ$)7+/ÉÀ<Zæ}Eïh¯·Éãê%rÏ{º6
bT0)O+­.¸¾H"ýÉñ£:ÉàÜkZ¹ÁÓ-NÑØÀ9¡
0éV:iF¥Ì­l)¹´ý¥BêF sø¦¯]¸Ð»5M·iRVÐ®§¾KnÞn{æRG#Åí8ÓFP;7!!XÒhºÌÛâäJBôpè¯Ð$çÎÁÄuìxwF±ñ`<'z»?ÌmõÓ?[UèÏUiþÁta*89i]Fq.8õä3«½» ¿u ³çyÑV^GT#nû~BÇæ²H6HÇÉ.µ'K(iá$'Åf/ín¢Ö JYgEåTëXfI¾#ÙÜ¶§\¨hË)W Ã×=ÆLZV«÷£Á±25Ñ,H3b&ÆWlÇ yN3)§<	f¥¡IYÑéëÓOõæ@ÚöKsÂ¨R¥
àNZÆ ¨¹¬÷Á¶øöÞY)\(·zÁéþ¡-f	ä¢*ú°.®9N£ÒÙ
©ãjõg+¶uQ|îä4ï©´Dg° Í0üJR¯ÞcM(áb^¢)dW2'Nßÿ6<
Ùº´òÊS)òQGÜ"á¢µ9Õh©ò~2T!ÕÄÊ«(YSVA"ny3§éÓ~åñ®;å"[Tý%ÀÚÑxõ#äNë@OÊ´n3ËS#`}qe6ÜuªlT³3ù¸:ýô£äÁÐS2RJ¹¼S§\ÛbFº×°¢ºW¾_$³zMeFÎ´!(Ô(¤JÅ»EÌ;}l»>Du CW[:BeÙ?s0nd°ZÊh®nÍÔÝ#{2jÎ`AC)s+[J.m©ú§èkß4ó{zWo¸M²vE|<ò]róv[Ü+È4z)nÇ6ÊÚ¼		ÁÚFÓUÞ?$ÇT¢C&1_qp=CàaÝ;ÞQ@¬A<X#ÏZo÷¹­~F+//#S#ûSîN<E&BÃ#f²4^ÁX]s/ÌÆ÷É¹åYYú#¬ÄºU£t*±AñÚi38ä^°FR§â8LTAÈÇ¨HáÆ^0nÅj&)Ã/`òÌÝ.¨ÓN?¸v;@ÖzÖU?ndhðjÍÛær h­ÇÊÔDg° Í S\±iæQl8IÎ¤Rò$R&euFG/Þ×iÛ/iÎ	£J*;i 6ä²ÞÛâÛ{g¥p¡0Ün¡HP>¹éÚb@.ªb^yuÇiÐCz5\kõÛº¨oHÐ$ÈþDÍ1è§È 7%¤4®SXY`ª!8fL@RA8èÊ^3E)Ae:ª/mªMÊù Ú½r¯t
v¥HwiR¦ó0ïå}pS¥r;ÔðåÎVNÖT¹1ýq´£¿¯Ùw9Ï!Ð 2­Û¬ ##`}qá)»nñQ5ïL>®xÊ¤ô+¡§,e¤rñkû}ÌÓH÷VTw¹«&9Ó PSF¢*ïE6F2kîô)b°->fîút
ÕjV]yléeKü$Á¸ÁRj)£¹º5¡	iïyÂð5eþEEwd§KÙÒd6êÿ%C¨.âü²¬bT8Q£yÚÌêå¤â@QÙÀáÌHí@ÎVyå åª	ÒðÖR®¥ópO  _%ã~P)'
`_hÊvJD× S#ûSîN<E&BÃ#f²4Þj~A/mLÐVìÈ[¥?²Éë¾å$}MÊS%¸ì®¼ 9î´r/X#C©Sq&ª ÂÇÂEºLPÈi[|½Í&ÏÜ-á:úðáèk·# d­ghmXõãFv¯Ø¼m.ÖrTA¶ªdÈ÷~±mâ¡Ý 0'VG&i^£æd,M&"UÉ$ FYÊ]õïÞë½èÓI]-S¶KA¸¶dÊ(ÌLûÕ8aÊÍ
=±LÊ¦å28@êÅ©µº­¾Q­zißC û5§»³þÅZ+~pdÒ¸Naei
©Z`3L@RÖSc"À×LQJå<Mí6Õ&Hå| íÞ¹Fä`Wy&e:ó^¸ HJåv\Ê;GX8YSåÆôÇi ço{+/;ñ.çé(ÂZÓ¦&ï	l*¢
/I3JU´W;@#Z-0¢M·0T5/ß_lÙèBGd*5AG Ó6ÙjÒ[hß:3ÛSvw°]RF!ì;Ö¾¦,Ñ¿X!³èLò40p)[LÐFý¿dk,°^¿,/5e¢Fó´Õ	Ê9HÅ¢2²ÃÚ&­&òÊA«&HÃ[GpÌÃ=T|OøA¥(5|¡)Û*yx]û¬¨ëø5W*
'­TÍ%@eÒ¦Mõ¨|ð$Àû«öHî£*vDL&h4½ý_|xl¤Ü.íP'!ßû1Æ¶vàJ¶<2©Hó5!ci2©J&úêS.Ý4EK{¾:EüN>»Z¦lÆpm5ÉQ±ÝÎ­nÊÍ
=±LÊ¦å28@êÅ©µº­¾Q­zio¨o¨E×L®SÑ¥Yê§úàÁñe6).jhÀ¬ÚÕ¤<ZMMÞØa.*¼$Í(UfÐ^í hµÀt6ÝÂ|RÕ¼|1àë·#2 #il5é­´omÊ)»È>nöÂ õN<ÔÞðe©Øö¦;õÌê:~ÍqVáD ô j.*6Ílª/ÄBñ}Gðþ¾ÙÊ¦·ÿKCÛ¥½Ð'>à§ºAÝHýÏêàÖN5®S1PÚT?54E_fé¢Ìª]K{aøò>áaÀ¯rë%>ô¤oÖËV^pÀÆò×O"eTÞ¯8àß	¾ÊZ°òK_÷ª¾)Ø:ýÄlzÓÎ¯KSpÀ¿	FRæ6ÕùÑIia5½ý^jàWoÅ}ÀÏÃÊëë02Æ«óÕuD'ÂýIú<FÔ5j)SÉHZ§_°üºWõMÁèÐYì'dkèW^KS ôRîÎìlE¸?IÇ!FÒÏP²ý¹Ôí<ôPÌ`ëîÅ?ÞöËqb²-½[/NËm<ªó;¢Òþ$Ã<:j~åÅ?ð«·â>`:Aa®`Ht"Ü¤ÏcDFbõU(9'E~K¦ø1NN>l·"ÃÜ_4Ç¿ÿ,ö+úò¹%Xm%rcô¢]¶Æ«óÕuD'ÂýIú<FÔ5j)SÉHZ§_P£Uúªk÷'éóQB3Í ¬°ËìÉùÉ
Z69x ¦lE!
í?EyÀÐÖ«,»¡e)ghZâãÉ5ÿ6¿j«Ù´ûÐØØp>5BåÊJ¶?÷/ºa l³òÙmé¥ÜR,MÛ6±$V8&')!´ÓÌpêFRmÄñ¡SË»öVG¼±çC¥¡äZË¨e%C3Ë9¡pnÇiÛ`(ÌC¢áþ$}#j4j+¯BÉ9)ò+Ga½æ;æþê 9þýg±_­¼Z+aôô°£íò´msk(x§ÔtD'ÂýI:bH©»VÓJp¬	û=;NàÔr0;nlR9Ïy)#2¤VD9²D}rB7áf%ïL»hÉ¾êÉÑp>%4ÓÊ
»Ì®ÏÖ+hÙä\2tâ!"²*<¶ÿ!äC+¯ÆJ@ÝÐ²34-ñqÝ­¼æÓvhZE»¯^ÞIbÚ¶#:îOÒç1¢Ô9£w:Q¹WKÊ~ECý<ÜÍ<eð·£o¤)ÛK9ÏÉDQÃBeå½$ÌsB×¬$À/ìùÔ5LÛ CHbåùc"ayR@;Í§n$Õ6X@l_:µ±kouÄËq>TJ®µúWVB19³º	áÆp¶Mîv> HðÚD'ÔýIbH¦bÔ(WÝ6n·wÛÑÙÑkæ@vwY<V¼¾KÊtsmØÈâCÐ9¢o	1h´¾·×0¿¹åznÅóocEÔ÷'é!¥îZM3**ÁI°&dî÷ì8QSËÁì¸±^Jä<ç¥H´¡r9²D}rB7áf%ïL;·ä®2¸Î¼ã±ºLKô"l-#ªfêQ#L
7zE÷,yÉÝ£\®NÒæñX¿g,Ï
%û!`¬)GÂ==,å¾% RXBWltoõ>m?¡ÝW¯n%1íÛ÷'éóQêÑ;(GÜ«%e?¢¡~vÜÜx.Êào)GßHS0¶r½ò*jX¨¬¼yNèZ×0m7ÊÌ	öjÕ0":îOÒ#ªfFS7Ð/ÎËõ!ø,ÉRË|äF!ÒI#DÌwÑ»nVÜÚ&+O;ªÎRL¸2êF³V¤ CØù<"Á7hP÷'i!5fQ£\uÛ,ºÝÞ¦u;zÍ< È~b9åa¼¾KÊ¶ò*­ Y|z Gô-!Ö÷öæ7·\ï¤,±S'Û`¸áÞ$=1 Ó¢ïÀ`]0Ö|M«Òj)£¨Þæ½ 'äÈüðkÏb³¾ÃP¶JRî«³#F.çVEñÿ0í`ëÌ[(iKô"l-#ªfêQ#L
7zE÷,yÅÝ£\­Öióx¬ß3MgAWaEr@ß),á;6º·z¶zÛ|¸CÂ­ÇIÐÅò!d=ÔÙ¦(G£$B'..ÚËÌT²¿åâ"P¾Ó8+ÄqAj»§5-2,­QAÝ`Tg)vÐ'çà¢ÑUÅ*­¬#ÀìÔªaDt"Ü¤#FT?Í¦n _ëCðY¥ùÈB0¥3,G%ï61£wÝ¬Xy¹§Ug)G&\IuD£Y«ÒF&H`t/vU§êHAë?ìANÂÀÄGü#óW&hà6
³wÓ;C5!¢tá7ÿ23 ÎA¡(Ï9_ÌTÁÉ@²!'eýR½¤¥Ü¸%t°Ãlv10´¸spsËõÐA K<$®E¸7IO¨Á4ÃhÃa#×z°.k¾¦U¬¼j)£kP!¼+Ì{ActÖqlø5Èg±Ùßa([%)÷ÕYÊ£	Ïó«¢øv0$´aöÎú|@!Áós?¡!t)#P|/HGX(Ñáw§§øÅ.{u3EAýç878a}Bá[®e4j¡4s&eËL^4ÒM\GHÊÉ> TÐRnØryb++TJë¾[®`ó-vA¤p+Âqt±|YG@u¶£)
äQÃ(ÐKáÊ+ç7ìof9 8£ï4$Î
1g\P¤£Ö´È°´"DuQ¥ØAK¬ÏÀE£«UZYFâ~éB©d
ðÝùkåVJv)*-!4<¼~_×»f=EI¡6jRf6Ô2z¬%",o2fFðQ6MÉþ0éaZv0;ÊnV$X72aQ9.meç¦K9¡o	^¼·´hkÒåúÝ]Õ©:#RÐú{0°$VØÀü	¸ÂìÀÝ4Ã»M£3B!1trfFóÔ9xå9âÙ28ÙÈRR6ä¤¬_ª ´·vcÍ.&Ö<·\ºFÑêº°°Þ"SÐ;Í¹P÷L®üé~ýÓ40£sí¶í Â}0!£kÔ2è!³Ðôö,9x fö*Ê)åuX)ÈNC~ÓßKAËfÞÇóö+_¸(éRÎÑµ6¥T: NäpOÕù#ç³3?¡!F ø^°P¢%Â¯ð]öêfúÏqf±f}BáÔZFZ(à\Xfºð¢nâ:BRîH6wRAK¹aK`Êå­¬`P)­ûjn¹.t.oÏLRþôZ.ªDh>;õidHf?yn·>M×~1ñ(SÀlØÈZvâ¥gwJGO1ÐãÍNB>yÇïÂ1èÏÕÃ$znåB÷|erÛN6`ñZJFUæëd!ªßëÐ2%
êQC.å¬ÕVUÏ=~@:ü}8 1/ÏJÆåôêìò*Dh÷Th	Ú½x_×»f=EI¡6jRf6Ô2z¬5Ë£|MAS²?L:GÌÎÀö¥òêëFB&¬"Ês#§à$[¸(;7]Ê	}KôÊä¸¥EëXÎ,×Ï»óq­VäQäzsJ~Éi>Ð*»`E. ü^÷×ÂH£Fw/ìÑ2¯1&pyÍ,DèÍêx£+?KÌâ?¥]3wÅ¡i¼JRFy:£	]2Òó¼<á¡Z¨~ç^¿X2| º zDa0XéÀ6Ö2Þ14ÙÀ«³÷dJêÞ=I-Ô½¢+¿_o4ÍÈ%qØh·mGî	]£ùC_¦?t°gÉÁÃä1³ÿSQN¬d§!¿éï¥ e3Iïãy{Ë/\t)çèZ@ÊÒ* 'r88 U×"ótÌ+|%eÌfnQC`t#q:]Û®º/QIÊ6Á½Cñn¤Q£ôê£:Báv×«Õ5&AÂÀ@UØ=« ÌrTrñ0Éü¡ÔVc]øaì6VAi-q§Ò²Æ­æy`)¤¨KÜÌRN} %É­Xé-Þñ(äá9´ç&)¿¾0Iæã#ÿFdöçvûþ}±ò¢ òâF6ld-;MEñÒ³;à0b Ç¼~+/¬&ÑYp+¯ìÄXàºç+£Ûv²×R2ªB0_¯$Qý^)QhÔTÒp)GÄd­°º(¨zîñûÒáïÃÀÐ{]áR8é2,æØùpáB6'¬Vìv¢hò»uR¶ÜHÃrìR¤diÙ&áS¬?¡s¶`F¸s¤²!¢úä'K«lÀrpI&D[Rõ Õi^Ò¥ê,rãÉº?ýÔ:¨sjÚÀNÌà¨=×ÌYG#È ¡gr tmï$ØE.yåÕ¼¿F5ºÓT|aà·¼âË\- >¯õfu¼Ñ%IfñQM.Î»âÐØ¯QÎhÂ`¤ô</dt:
SýÎ¼~9°(dø@uôÂ`±Òm¬d½#ÔûL'ùØ!!¹×§´æ7D.íÖ\¨sIBÌë×=§|yýdf°çgóO¯£	£¡×ÑEðZqÂLuàWò }+)óx,@1-§:p^D>Ò"ÁËóX;ZDjêXeÜbFÊ¬6#JÙîâNË÷Îu.z3 NÕö~Ô"çtÌw'I³[Ôç%"äHU+/QIÊ6Á½Bñn¤Q£®QÕ
·áÊh¼IyÝ¬¼0ËQÉÅÃ$ó"P[váMRÀVAi-qGÒ²Å­+/BZ¸ÄÍ,åÔ3ÑÍdËVÊL¬ôLïxòpFê}	ê°ù10é¢Z!9)	Ïz«ØQÂ§¥£ ÊA½ÎÉLK)³ÃòÜTUMò`ÍV4=9QÉQ\¯¸T>ÑGEhNZÚûvfRyê³´Hð2>S
gJÂ²VPÁ:CÔ¯´rA¢aòýyÁê»ç_UzÂ~)7º$#Âæb}<é2,æØùpáB6'ÌOìv¢hµòB¸²åFº\yYv©
R²´lðÖÐ9Âá^ÖgHeC EõÞOVÙ,åàL¶(¤êA«£<\¥ê,rãÉº?ýÈ:¨sjÚÀN$¤e¸ê<$é2èÊ0Pt?#<P%¡¯ñb±Ê%Q·@-3WÏØôX	}p©iºdäw
Ib£,eã^Ê´&IYF(·"IF\2ä×ÝoCf-nRtsQè¦|ìÉÜ#Vn.­b.Ô¹$H!æÅBÊS¾ÝßOÓaÏ7Ïæï_DFC/¢iðZqÂLuÓ2ÏÇÓrªçEä#-¼<µóÑE@¤©îUÆ f¤Ìj3¢í.î¨|ï|0YwÏ=e~Î:2¥äê9ÆÐùL6®ÙöhSÌ¡Ëhc YU¿PJ?ü¨¹_RF<ÅÎÓÂI¦,þtÉ:h¬§¡<2 SsúîäTZ&^¯6Ë1)¯¦ßú.ñZ¤ç #Wêx¯ê¬[V2ó%Æàt#4ÄÇ*)Õ¥L¯ÄÕ¹èÆtEðAÃ³PÍ'édpùëË¨B^1#RõV'a&DéUÏ2dPï§¡sfÃ6àêi°f+M4QÉQ\¯¸T^ë£"S²¤§\t³æ©ÏÒ"ÁËøpL))	ÿÉZAAèQ¿ÒrÈÉ÷çWªï{r~UË¥L¯ UãyÍäKQ¡¢åiaí*Ô¨evc2ñT	º¨83K4;l¢Ñ«ãÁÙÏùt	*|ú,>ÜfjÔ0é@ñ,±ÊCZ;Â©â5ÀpMiaZó;AQº ßÖi
B¸Ì±/£^í«ÎC¨]¹Ü¨à´ò²X¶ l3
XÓWR¶!=VEEB\jmD2ò;$1AÉQ2ËÉ+¯^Ê´&IYF(·"IF\2ä×ÝoCf-nRTJQ¨#Ú® [E(Ãzõ ^jÈ&ÇD`h «Âo§DH½¾°ãèÍ>k0HdÝüJÆ4h`ðü¼âX(f"LÄSQ&B.´¡S ÈX:î¬ ÞH^æî
êÔq¦<$ô²ôë] Ù)°hdUüB)-ªòzÈ¥ü¢2â)vN2eáôû#LÖAc=EäËÔWë#iz½VØ,§Xy^ä¤ËßÈzâC%Æ«:ëÌ|1&8Ý±À±J$au)Ó+qu.º1]|Ðð`F´Ý@Ó¥YGr2P^;4)ä.¬¹ÄbÇÊÆÅ´æe_D$­õßaLu Qäa`üß?Ó®ýfÑHõ	mÆäFRþ z§5!*AÍivØD£WÇ³óé29RøôY|¸ÍÔ¨aÒâYc´wSÅkáÒÃ´æw¢t@¾?¬9,)+Ópc_F½:*m÷DPÏ2É³{A××Ö\ôW<O7ÀÖ5é(<Qü#)·EE$GÉDW¸p3ÌJ	¦?ÜÆ$`ídK(ÃþtÎB'rïsí`v@Ö«õRC69&CÛY&|;H$oÁcK;âÑaæRµ¼[uó5iÐ,ÁàùyÅ° QÌE§¢L4<\h%B¦ ±>tÜZ¼?¼LÒêÔq¦<$ô²ôëEËüÌ(»ãô¤àLô«ÎÔWª|ÜÒ_FgX_9(QüÏcÈÄ¯+0µàa #~4økV^¹ÄbO¯/h!LËi^ö5ADÒZÿÍÆTUI¶ES·¹,¿ Y4C%Ò¯[y¨ø¨gfgÀ.\[CTr¹VÁ£uM I@áùGRn9ý®páf"L!;¸?[yµ-¡¿tå5 f`øÑû*ðÈtà£#ukÂïè(Â·ôáÖW#JFÿóà2ñë
L-xèY,±;ÛítÒ?ÊpÀ?Oøw6ÃAäåÝ¥¤Ìï-·b¶$ø?MÚ}.Í²Á&ßÝÊ³óÛwlgÕ¿"ð3¡ÓÉùÖ¶ópÿ¢[éHÊÓë~ÁZÎLSNÚ§>ÐØð) + hFb4fa6s±? ÌÉSMdt¥50¦·[ø)¹aú? ~¹Öý£ÜOßÙßÐ¡N(å­Ky:=ç÷ú¡åâ½6&òIû¶}¦ëÂ»Þì´<#N°ç®ïË»1KÌhvY.ú®6tlá® ÓÀrû¾FþÇcÅ\W<©w5Ò2ð¼ZýáÏÿçgÄ¼æßÙÐH^Ý^ÉAüÞr+fKÿ¿ÙÊßÝÊ³óÛwlgÕ?ªFgÓÙDÚ¹®Ô2fkn:º¢ï&tqrzO¼´ï|ÒN+¡v»>öm=è´[¦3Ä%ÆÙ,Íí xúv±aîïÉ´Ê³©u8ÊT1ý}ÉúPQ&x°uúÕ=þýùï÷÷ÿó´¼>ÛÚ¶sNà_q+Iyz±æ¡ålÈ4tÎIûhßÊk­÷» f$¶ÑiHcVf³0ûÂ9ÕDFWÊ¨XczÛ±õ[¾jgv7èg¡5R¾¾¦5¥RÊú«N¼|8i7^ìlFR'hgçæXbV³NÎØ¤\WY®eKVjÞZ_IÊãAå¹3FÁ® ² í°º¿áj5ÔòúÕÌÊR$åéèßëOÚ·´í3]t6ØÇ+¯q=ÃhWnÜYbF³ËrÑwµ` cw¡öfÛÔô5ò¿8+æºâI½ª)häÕjýêïÿ,«U5³õjJ®ö_=ù )sVÆp{wòXJy<i×NØä¡ 0;­s3,1£Ù¥¹ÒÝ'eOVÀìDy$$0¨Qä<'("Ì3eB\¦G ¤¼HMgiçºÒÇ­å JùvB7)§W9ißú¤W.ì&v}ì[Zc±N»e:CYbÍÒ\Ø§ivÁuVæiI¦5TM¨ÃQ¦ìïK^Ô2Á­Ókåõ+¯"çª}Ôá¶ÜJ.cNÎ? b«#YîNN_S«úb¤&íS<JWYlwÁçÄ)þòþ?=flç¤ëÊ-Ãµ½À¥\0"åLw(Ù)8&)ÙfI%;í$çdb(etê+ÖHºëRÖ_ípâõÌö@ÊÍHÊ3âí,àÜKÌjÖIÀ¹ëZ(ÂµìaÉB4´t¦Ö× F§2EÃ8gPyfîQ°+(f ,H;%d/g-èD:5Ê~üPÐË»ÕÝå¹­ K)&íV¦êïó±ØbëûÕÝêÞbÌ3Ù,Îé©&àDÅ3©4G%WkR´$JQ1ÞV®ì°F!eÜ(!)ù>×òd(Y¦wFYÂ,àÀ?ùËIýb«ýW×î ¾²~Å?,¥<´k¡lòPÖ9ÂÉÑìÒ\
éî²'+N`v¢<Ô(rEæ2!FËJ.Ó#À>'ÌJùD[ËÒ^rE)£«5RMÚrËÒÇ6é§ï`->?ÂYbF³Ks~)cÂ_õwé÷wÅ$dJ?Ì53¸:¹d8¨T2DZÖNPûÃÚ§û{hÌeâ¤d3, £å×¿þµºÿ×_Vq:AnËmÑ¡ä2éúÌÄío×G/¨U}1ÒFö¥«,F6Í»àsâu³ÀL6sIÒuåáZÊ^àR.Ar¦;ìì³¤và`1ò{¦å;¾éê`ìò¥KGcNÚõ÷ÂG6õ
{NãÓfÏHÉfi.HmÚ=ÁrÒý8å0·ÉKÅúâ.¤Ì-yk,Ít4^PR2¬ZrR6sæã5bF3)=Ra²àfêRþW'et"eN¿Î
~(èÕíêöêÌVÐ¥Gv+ÓMõ÷yÀXl±õýê¶Ç,0Íâ\jÖÒI¥9*97&ÞRT7ë;¬QHY"7JHJ.V^ëi¢dÞe	K°SB½òKý
ÝZ#»DÅ;<ÚÙõìQÀhÒ>ÍU	cæÅÉA¤;iÌÎg3¶ïXÊ#£<#aaH[²
¢'0×L%å®F>ÓsE~ÇB uj#ÍÃØ¥lL¤gâl3ÐCþõù×j(åµ¶EÊzå%)3RFWk¤<´1ållãqúÖâó#ü%f4»4è2&ìðU§XO·ÅÊ"HÈ~kfpµjdÃµÔþ°vÆV^k2WÍ°hd Ì`åUÙpý¨^y©Ýy!å¼Ï+ú2`¤!äRIûTry<1¶©ÊïdåÐÀúNÎ°ÀL6s°< °¯OTª¡¬Ü(E©Ü5Q2D9ve_#È¹×RÆJ§y£LÚã¶2PFç>þáÏÿõHX­³òZ=ÓòmµòBcg¯\Êü;"{ôpÒ®W^#z='ÎñiH³g$Íd³4¤6í®±\t±òJan\õÅmH[òÖÔFã¥(%Ãº¨%'e3g>^#f49Ò#µ&;ý
¥¶+¯Ò2:ºë4ÙX¥1pZAPÊý{Ï Þ'm*¹róØ¦²èd`ºlCÙùlæÂEÂAÚÂh¶b¦É,[ºPý4üõ¯QÎ F~­c!ËêPÞ`½FFÝó;+qø«(ºCnè$aR6üë7'ÐU)bH+lù8I-Þá¹ºÒÎ®R²G£Iû(V%m<R'î4¤1;ÍØ¾c)tò!íÂÇzT`:[Ù¥JÊ]|¦çü@ëÔF±KÙHÏÄÙ0g@/®»WéôÎÓ
#þ;ÎËS½FÜåêãêÝvª?4%úI»MÕgÄ¤óQ=l°i®eç³xÐÀçÏåÂ²aÑ¨qøª¦>ÊLVlsÏ"ôBH"-ÐòÝtòR6Ãa,@w(Ø Q¤e§"}\R^ÉèÔ+¯ÒÊ«Ð2ÅÌ.I)CÈ¥
ö6äòxblSU¯CcjM89Ã3Ù,ÌÂò T¯ `h²r'£¥FrÚ5&Ñ´ò"ÓÔH£²Dîµ±âiÆ(¶Æ¸­¤ÌÑ9 WÙ<çë9çp5ÖÀu?Ax¿MD4ö)ÿfºµkmPX5¨£xÈ
záÛK¥ÚNtn2Ùtl!mýó¡ÂÐ1Ö,g2~úÝg óF=99=Õ/ª))Û	NvH;ÒI¿(C	]þP¨\)eÞEHôF
 §DFC¢¹	ä4^ùLìv~°ªqø¯?ÿ^þËHÉ2:ºë4ÙX¥1ÚsZA®rÿÞ³ô>iSÉµ6E'« #ÐezÌÎg³0î`È(ÜÑ4tg¯ÃPÞ%U?MëråÕÕÈ¯u,dYÊ¬×È¨{~g%EwÈÒ$LÊäåÒ pÂ·G¡½1ÕêR®rMè&íYcÃXDÀUÅV+»÷¹ÚQç¡%Ö-Ô»³:Ô^Ñ-;ÝÑN_¯ùá¥|bA)ù]lU'Ü\þúWÙÌ!KØ)âjÿÚJr$³ À.zÍûD¥`}mø/hù7ÂÂ¨eLJñ_iåU¯¢w½ÚNÕG2B?i720²©Ø¡8¡&.a°i®eç³xÐ |Y$iX4V¾ª©O2[Þ3E{!î¡åÛiýªZyu5² 5Þ9¢`F=ô]rI¹[yUÿìJiSRöËæ&íó6!+¶ZtcT× óÐR¯'uOÑá·Ñr«N@¹"J%w¬Æ íÁ	íòë^ "¨\ÃyªÎåòc´Òá®ÉY`RÆ¢ÔÃls@$ÇÝåêæPjKyãy^Ìx)9Ocµô©Ö
Êß¢0-ÿùüãçþÐyð\jbÆ¸î'ój&í£ÑÊ«µAaíÊ²^øöR©¶µÎM&-¤­>T:ÆÕc$'¸ìz¢aÑZëõÑ~QMIÙNp²CâêÊÁPb	P¨\»ò²ä
#èÑÊÍM  ñÊgb·óõPlüjÝ®¼F³I[Êæod k¿avÒ.0o²BSÄ³N?}bëpGútïKïì6,ÑkÖr1KòÂÞtYj·~Ê¨LÊ)Ý¡À¨º¼J)b(¡ö0ÿ§{°GFjxÝÇc.²<×4áð½Kç4¼ÐV`þ>-ÿî? á?þñÿñç?üùÏbXóíQhDoL-^yuöÀ¬±aW´«wRvï35ÎCK4)?%­[$¨wgu:$¨ÿ¬¢[vº£¾^ðÃ9JymA)ùUlU'/+£@±òÒd®Y
(ÄÆLkr¨ýK*ÉÌ¸èïµ¯¼xCëfå5ô;¦÷½À/g1oãÓTíjºF }V-ôéÓ½½þfÕ3@ÁZu¦\¨Ï>}.ráAç%´¦@ïú¸j¨å²yíâA)çV
Owu;ÔÒDÑÁjt8lK[§iÙÜJu¸ÑÓ$å¨?*ÐÍÞ	~÷ÿ!ÿñþþXjÿqü³(Rþ®+¯ï$ªG¸tZêõ¤î):ü6Zl
Í*RD©äÕ =8¡]~ÝDk½òbJ./06A+î Åa,Jz´Íw«CC©-åçyQ0ãm¦ä<ýÕ¢-`ù[¿,ÒÓf]6xz?Øû0gþÉnYSÓ©wÛÌ4î¥ìÙ}H.Ü2Lº)èa¦b$cbFPN¢Ì8µEt<ØGÌ%É[uOZN¢OUì¥-{òpþ»òïfVØû ·æ¤ü]W^!+ÜHôKºçèý{tÕ;Ò§óÐxSzg·a^³ñ\ö¦ÌR¸õ#@eRNAèFÕ%5JC	Åã1ü?Ý#­8ò44RÃÌ(ÄäHGä<×4á­óÊK§m ¿WæïÓ²xdÔ+Jbpÿþ:ÆY>x£zg)Ntªt´!a^¥ÄFÙ<,ª¿R4°åá7t°M1V	!J:
Ðª?ËÞ8Lµ+JÐ&JÛ~Âüîw¿£ÿøÇßýÎ!|?Ù÷`Ï¤-ÌÛøôUÅD«!½7wÿþý½½aå¥[°V)*býùýûÏE.<è¼dÖTè]¿µ«Z.ËaÞ³ 2qf¥ðtW·C} MDüF3É¶´5yjéÜèQrÔÉ×ÅÊ®cÌÙÆ}O­îzijjqB ´;Ïfi.§<rÝ~$IOuv -1[2§kË1(èPh=î$ Â¼`Q¸JBg¼$°üq*áwt)ÿñ?vj=mð&ô~@~59ôOvËR¢ÛfÞ¤it/eÏ¦ÔìCrá(`ÒMA;4#£42reVÄõ®'ûûx°K·ê´DªØK9/yf·8[µ'#ezbFÐGäUÍ²»#å¹@%z« *y-)¥pädÉ-mIES*ã4
êÓ¢²­¢mEÂÈ2pÂìa£ßý-±ß­öªî;¯¼rÍR|¬ãÒ!B¢Ø(åBáWf¢< ¡n#¶2Ð*#DIG:³ìÃT[°¢m¢8±í'ü@6OqOEÊ=SýT
'£3BzëÝÍrypÖD$Iâÿ¨\Q0(ËR"7gðÒëç:áÖ9ÀN$§­HyõÛ?	ôR× Q eÜ±Ä|6Ks9âëö#1HÊ|Ú¨³\1GÌÌéÚr
rSZ;	¨0&/X®Æ/	,J°T§#eÍ¦Üe%Nëµxq,+nÙùlÇÇ°E]3ËAtÝÒÐÖR&Ål-Órf4ö9Ø:Ùåçb^ýöÛoOHÊôÎ8¡-È«e;vG6ËsJôVôðBRJáÉÉ[Ú(¦UÆQEe[EÛeàÙ%ÃÆÅ¼Saâ£QèÄN~£
+ÖþFsÅ3Ù<$ØZ8x%öpa¢0×ãå]Kd¨J­eEÛæ{8(¥3·5ÅÚ`jGåz/þ Ù×!­BàÉèÆiÀîÈæ¹8k"$M((Q0(ËR"7gðÒëç:áÖ9ÀN$ÛåÀ¨Xy=!OKÝ©[IæuÜr¡-_B#Î|H|Ld@èejÑjø´ìÅÈõõWò.½áiNÊÜe%Nëµxq,+nÙùlÇÇ°E]3Ë®ð°[ZÒJ¢­eZ:É(ÚWæ`ëdGoN6<§4íÓ&¶,ñHÐ¶à]n2¶48î4ßx$50E_¤Ö¤¬[(áÔ°êôeÏÆmÙÍÌdó\`káàØÃ!£¿Eyf×ªR+eYÑ¶ùJéÌ-AM±6ÚQ¹Þª+¥lQOÊÕOt[Õ>a@7hÍDË7ß Õf6tO@±]]¶Ä¨JQ?êuV»v¬0$	×qÊ¶|	'x¸ó
ùøÈ@#Z?ò½Ø ¹¾þJÞ¥7ä×A¢)V_ïÀ2«toÕ4ºJ)0¶°|4<MÚÖäYâ mÁ»ÜdlipÜiW^ ¦V^sôÇBïêcóàN¦éÝõ^«ø1 È*t¢|ê+¯ym-åàZ6sðÉôùótýù eâ/OÖDÓÅùõ,³ú©AWMÓbü2Ð3Æöv¤Ê²M$ªü£vVV*Z~8³íbüÿ¤ªùôqrrù<]1ë^ÕÇ çÁ9¬§éÕõ^«¾1H9É[½ÚwÊ²+)ó¯|>sp!åRË­b¶f¯bhyrÝXÉ§K(x¢µ6ÑÖR®Ui3¯måu2ñ'ò9¥¬í¥J%t;)YªÝ?H¹ºúËÝòa^A´®·'¹C2@ûå7Ä®R7æVHòÕrmr¢Ê?êagåi¡²òjãküªBFäÓÇz}õü(1?PÊÜZ73âòûIPRæ}ùùs©ävêv?@¡SòT1$ÐÊ.5+±_v¢E´E;IùJ9ÉÛ¿ÙÊ++¹2ÿÊîËL!åRË­b¶f¯bh¹¾n¬äSÇú
J~L­K@Ë¡K)KoÑA¸$.ï=¦éÙÝ³Ï2º©; LKBI³¸1IÂ3juîûnì.%O½­bçcB·g²¶*Òí¤äÊ}ë³ÑÊ«ºúËÝòa^A´Xd­s_jÜ/¿!vÂ¸Q4·B2
öèZ¾îë¾¥R¶k@]¨9?ÃæàËéî6­}Î»¾wJ Ä]Y¶ÑIÐÖ\JÎÝÐÜ<·
U©×&òg2·ÖÍ¸¼òZ!e®¼®ªW7u;LÉ Ð©¢qç@³	ñâÄ Jì×_¥hmÑÎbR~"R¶Ý6!ÑÜáÈïîxSu;Ês¾¼üçàËéÒ¥\làÙº2G:î2o$CEé¢\EòÓ·êC¼JÉ0áo­ÇFë³bbFûßVhÜfRK¹dÌÏ eþ-w.¥L.­¼ ÜW·¶òº-W^ÝÔP¦ts¸rHÄIÂfQ««p·Øwcw)yêm;ó}P4`O¬PnîpI·+;z¶t)óÀgw²1&eôãÉ¦näb,ÃÎ[*ö¡X¡dÁ)#%dÀ) QnÎ7uo­¡¢v. ©¥I¥W¢hÂ*&ñhA¿úÎ@G¯ûºoiA%mÃPàbjÎÁÏ0§9øjº}¦Më°òÊ»¾wJ ÄÙe§F¢ ½ý¹*»¡¹ÿyn«R¯Mär(y eMÀ+u!MÊç³tÚ<cÀfVÅ»º©B=_G ,ÞÛÝÖÞ$`E)ÛÀIMÕYßTLÈ¸×åNy°p«Æ¢¤PZ0z&y2øk®6ÊÎXqwN¿~|ØnhîpdLÊ··<HÅ)ºå9_]}ÎsðÕtåR.6pNJnV^x¿WyåEEu+/#ÙKªW¥dð·Öc£õYA11£G+¯FÉm&µËHÆ<y)kU[ÎÀ CF8câ|÷NÚçàNÊz|&7'e;ÓÔ"ÌææÔèFÊË¦"å2)µ
kä^+°ò8Ge¢B<"![X*ä WD8C]É{Êùfb¶'V(7w¸¤Û½ JÛÎºy`Ê³«[IÙ2ú±{=MÝÍÊeØyK_¶ògTóMÝ[kc¨¨èFªDiRé(°I<ZÐ¯¾5ªn4ÝÙ,¤ç[ÎÖO{&¤üî$	Z6)'+Ôd¤åÂKì½yri'Ü¦áytò	DÂþgÁ>jÁ	¥â0@IK¹0:+¹ò0xÈyLZÖì+/ÃbH2½ölNç`xY+/MÝôN3\£,ÞÛíÖÞ$äÃe+¯B*&dÜV^P`á	5VE-H¡´`ôLò:eðë+¯GVyUÆt`?ùìä²2gM=zhsBÊ!îóÒ*K¹ÌÀÝ²¿ëa<ntªÃ¸!)©`áJöÓ_Â¢Óé)EX´¡QQÆ[pÕ§÷Ø&ÂX«%î¥mñÊèñ0²Vµå0d3æãW¯Ô¡óÊYe)ëñÜíLSÀ½0Õ¦f0ÿN(«¤dÖ(¬3z­ÀÊã
ñlau¨"\á4u%ì)ç1Å\1]bªàþ:%OÁANtär¢z#¶MçÚGÄ2}úô.6²9}ýÚ¤Ü<E2ÖÖ¦åÄÁi" çF$¥ÂãDRÆòTqz Ï4ó%wÞ°7ÆêwÆÂ @<<"`«kV©l!tÄ8=yZnñ@Q¾¿/|[)O·6ëô|J¦£èò«u1\»bÄHËÕqÎ¿åÉ¥Eô¥~p×tò"¡{2Ø'CC-8¡4±R<"(IÑc)×Fg%{9_ºto;eå5ºSÑÙ¹¨Û¤Ü¡>jV¦8Òýô9¡°æòÜX`wx6§¢)RM{b®Ð'uóý=~HcÐ8_\õ¸S,Ïªw,¶ÖjÑ=ÖºúLR$bÄò!¼iüªzü·2y¯
)sÖÔ3¨1)s(¤:da¥\æÀ-ìïz¾ªÕaÜT°p%ûé¯BaQÈéè",ÚÐ((ã-¸êÓ{la¬ÕÒF%ñÊèë­gÀTÁ¹ã3A
`1ÝI¹eÌv®oÉÝ¨J)+üé4[ß'y)¬ºgêÛPTs@B(R²«ôËËûÕÝª²²gÉ¦dÛN¸ä.¿)âa ¼dàGÎJùn»UUc|c)_aªàþ:%OÁAÖ:r9Q=ÃyÖ¦ó+í#bÞ¿Ù½xaR­¼ômZNÜ!pnDR*0Ö2§Ó}6p ¯¸ó½1V¿3r|äá3°W#ÙBèq
»~Znñ@Q¾¿/|s)£s+gâõi¡eò®ZN÷ÀY×¥þ,'~>O°´ÇòÞçob2};AHªpÏ(å;I9¦»d@­áJ«ÛÜù`ó;¿kâÑÇS¸Ç¶ºìÖiàG¥|' >N E®À£êCÉÚzæîm§¬¼@w*z1;W58÷*<Mq(¥ûþs>$BaÍåÝÊìn/Ùâþ÷®¼(!æ
}òW§8ßßãG±4óÅU;ÅÊ«zGÀbk­àÑc­k
óBDSX>ð7_+¿½Ïµ$çe Ï	§T®o(ö¤lIYÄ³ë?"íöäÓvûéÓ6KY¢=Ás-f;§fHÊÍ%óJo+×0¤x1xc&ÈÑÅ
#ÿI*¦IÊû,â³{¯¦Ó{rû[ïVöYÛwU/½*¸Ó#w|æ!H,¦;)·ÙNÒõ­!¹U)eß¿fëÊsÂðë@}Flà*ýêê~uW^Ô²gÉ¦dÛ^5¯"yËïFÊa¡xG(/xá³R¾ÝnaÕß^Ê§)e1Îd7å¿è©iÎìû7S©;¥Jß(_ê0s#eHcÊI%åYI+l~¨eÞÑ~2@¡eüB*òJñÆs«h	ÈÆ¾eJÑ/´ÌñÏrð^mµ*2Ò®R¾h9Ú ¦ô²"eÎOòçG :8·r&^ZæA)¯ªåtÏuYÊ9á~åµæ¢XÚcyïó7A1¾ F$U&ÛÊR¾cºKÔ®´ºÉÿ	6¿ó»&x<{l«KÀnAxäPÊgxàãRäJ <ª>üh+¯_ûñH©'IRn U²ÌÈabFÊ4,ò)[ôéAIêOZùUn-YÉ êä«æÞÁcâÚJRv%[Å50)3³£E¨ÙËK±§Yæ§½?^ÞM¶r¸«õÊ#á±ÜÁSºÎË@¨\	(ÖY=#$)"GRÑ®¼Öëívý~»}ÿ~¥,Ñ®ñ\ÙÎ©2£|åEið­ðbå/oÑ9ºXaäß2I¥Ð4IpE|r¯óÕtTÒb×gÐ±¿5ê ` ²Ï¢Ø¾«zéýå¨¤þ^_{q°~ZR=J©cbà4_;¥s4Õ®VÿÓñCÒ¤*ðí8}¬¥ÖËwÇ8E|®ß£/ $à° ©¦ïoD&ºO°$ñ9;K9Z§v¾s!å×c½eOðYßð×ÜýR¦ãÌAvS	æÌ!¸3ºSÊ Æ>)CRSÖd%e¬°ù¡=zWRF¡eüB*jÃâ1æ¬Ä(ûI*E+¯Ð2Ç Ë-Â{µ58ÔªÈH{´Hù
¢åhÒ9?ÉoC¾¹³W©%½ä^ê
l¥\3á<H´ü
)Ó¹y?»³iV-çÆdHßÓßo\~øPµÌyW+pJ¹~cïOê¨U2Ú8àZ±Pèv¾yZ%cA<ß¨¡ùDlo74¾-%_øñH©'IRn U²ÌÈabFÊ4,ò)[ôéAIêOZùUn-YÉ êä«æÞÁc²µèJ¶"­¼LÊÌÂæì¤ähjöêJìQùQ/åW·­nk½~W-et:H¼®©ïüT&818# ' z)£÷¸Fu²=d>Ø!iZV(Þ@ó®Æt-À7Æ	±b0@!åêaÔûZr7g+fO%dÂUËºrtá#t²wçü ®**¢rùg'N=&ì#ýà×IÀúiIõ*'¥B5Ó|IìrÎÑT»ZqþO[ÄIªÀ·ãô±Ú?÷`Æù+òàÓtýÆ9+/£oèRR^cIâsvr´ì|çBÊ/
-Ç9zËà³¾á±×(Ë_¼U1éÂÁ&àG:R¦ãø_êÓeAø9EáeÑÐßùãÐ÷
?Âi3$	\<qmÅ¿þ«Gô9½?iÞCbJõl.ùÙýÃ´¦eÍG²jº(9¡²VÝYÊR»zx9/óÛ+§§ö[}÷Hà¼J-é%÷RW`+å¡GE"e¸Ïò+¤l,û+9fÕb`qnLAñí8ýýÆÕ¤\¿1f+/d	µjRvn¡nç×©EP2Äó=ùJOÄövCãÉÐòã)¹²nU»}¹³¶dp½*¨	ÅêÕ¤«Ëë		Ç«Ð×i}VÒ$NNQ¥WéB'eV¿T2Ö7ý;cÈRUü;}4Ý>LsÀ¡Çs¶jéúôÒ¾¾z~}^æ¬7j-W³r'e}c?eÿFZ6ÄkáêºÒ¸ìÐgF N À´2z¿IkT')Ûµ$ËôÁIÓ²Bñv  ô²Fk-À7Æ	±b0@!åêaÔûZr7g+f$dÂUËºrtá#t²Wgü ®**¢rùg'N}5®P_,xxÄÄùøZ^9HÌm¬1$] ßN/qWÏ¸1)@ÚZ"÷÷øHy-"HhôÎ¥ê³6W¸íÃ4KÁ4½¾`Åpª¡`%ci²6)ó:<Äa|¢&¤å\¾¦»x­)³U³tá@DIu¥LGjt6ÚeAèòÒëRú;_òbú^áB8r$± ýî#×¶PÜÙÙ]+¯ÁcHL©¾Íÿ0»Ö´!²zÁ#Y5ÝÐHY«î,e©½_yá)üèÈ~«á¾eKý8À×ßå
éuH¯è4áWR~]«àdÎX¾Í}®Åuóæ1¢½¦?~üë_ÿ*¥ß ¤äû{ó?4å5'ah9È×¢ÞGY´/Ï?3~ØÊKÂãÕKèë¨>+iHë#TiÅUºÐIÆ/WÿÎrTÿJM·Óp(åñ­aº>º²¯¯]9káZAËÕ¬ÜIYßCãÀOÙMËUKý0¨ÕX»°J©#äËvHÈP¬´L/À%ðëO¯ù]Ñ;c¡eJ}ð0-RµüîælÁü6¢ ¸ÓK[O§·Âôþ 'ßê£yÂVÄð&¾¹^ùÊ`aÀÃ#&W|}æ·£+\ãÂ3nL
¶ÈÀý=~G+/hùCB£wÆ(U÷W¸íÃ4KÁ4½¾`Åp¤>²ËIïÔáÉ Þã5Ñ®¼øE4ÝÅhý×òÉva5MvQV	ó<ÇBÎc ~<Çt9zNRÎÙBhÝ'fgOÎ§S}âM¤ïÃrX	VU|)ÿ0@f³òâWR~1ZyQ\BS@\ð6o#Ú}4zÎ+¯áàÜ¯¼0_CÊn1Í¦EêBmÛs½sJÚgÏIÉOYÊhÁ©Bîùn¹35z=|¥Bæ9[P?¸ä·1c¶-ù\ÊIË,h4õrVö_JÊÑvaMS«Öe;$2µ,¤ez._¼ÁïÞ-Sêé<\SÊÝ-¸ßFôwteëéôVÞàä[}4OØÊÞÄ¡l§_óB¨Õ{þx¸¢¦]©'s?VJ'Ðw©û.z¡;0-ÿ&R"5¡]X{¥K»([+/ÎòX9UxøèÓåèa:Iy8g¡õzåµ>ô7¾Ëae$XU4pòCBõëèÅ"jÌÙ*oñ»Õ;#åTTW8ñËKùÁ@s-8Õ1PÈ=ß-w¦RC/Óá,È|0g´À
QWÍÊË¥´ÌFS/geÿ9HùÇb<gBËø?ëþ´¥V(eJü åyÌ VïùãáB40zv¥®g2<& ¯!R3öm3\¦eâ å§°³¦å¢hÄ¶©äJÊõYúOÕþrÀ@Bõë±A!jÌÙ*oñ»Õ»¥ªá
'R~ÊèûÇ´îVöBÊ9¨oQéâñm-ãÿ`\Ê¦å,åñÊR¦ÄRþéÀ?Mæ®ONÊC3zd×;ÁßlÿÙW,¿=l+/ûJ®¤Ü¯¼|ªöÇÁ¡«|LbRBF&åtuÀÓC¯r¬¼nWöu!åÓ+]<]åû+l{vâ_üÓdî(ðáz½.ÍèñmV^õ} ?Æ8àWÃtÅi(&å!ddRNW_CÏúNXéÛa3O^ü
à
Û ø¾8Hù{Pò¯ý1´ìÄ÷ÅAÊðHÀh=÷éÕwÀAÊðXø¡+¯8àÀAÊðKà åø%pòü8Hù~	¤|À¿R>à_)ÿLØlnn¶[~zyqqw÷áÃõõv{|üæÍÛ·npÀÏìbîl`.^¯?ùÒfñ¥|ø*ã>l ¿ü9¥|pñ>Ì¸øç2ÏÒñK»£|KÍ¾üåàâ=x4ÿP)öã¶[Ü;^	Ú&_¤MÓM>àjËÑ,?ß¬|pñìrqÌÊË\<rwßH~ÆÕÍÍÒÏÇï·fkí%ªÇD46ÑU
3µUÀhóµ"ÃFáÚÀ·VÚ£I¹¹¥oIü:.nwÄÑ·uñ×J¹»oJoàfÞRjÄ7ßeH?§ÔNT©A ¨Õj»UcåböV½­Øî\AÉ¥£Q2üá/ÅYú<öÞã£¿¹ÁýSvqWö6¾11ÂHä^Ì sü0G³Ï\ëD«-þY!)ÉF¸©ùbK)³h|Ý{>ìA+ÛÀñ ïò=nÛøþ½¢bï=>.ñ«¸{Ø{?ÞÛ^]û~bcñs»±	7ÓkjÈ£ô»ãFÆkÙa²¿¦MÅäçH9Ãèö|¸%(òa_dw´Ú=îÇ ÜÅy·ÙÌÅW¾CL w1èö %(òi\ühRîoã{£ßó¥;Fafºg(qâ)8½ó c?£ùXÿx½Uç¾,Äç`ô(!âXks·Â²;¨0£<Ñ9#.)ç¯Ç{üÂè÷<ÎáÑbîêÊ!óPp1èg©¹Añ9.F2 %±6·<W*¨0ßßÅMúÜS¿q¿r)£yÁPÁP=âÐÜáûujÍ:a¸nnH [ªì­úænºózS$e¬?þÝ|4¬J/eq÷PB¦W×<%ÐÈí£ü¬`1d_\üïÿý!;#÷ÔïCAÜ¢ç¯\Ê¸0ÔB0#4.¶± ðÉ}Ê:w1KÕ9l_Õ7·Ó­×+»3$¬Ppåb+Åm6Ê /
Ïtíbf;]¼Ù<|Vî{ê÷#LÊNÜ´ÇgKôÃ­kùb ¼jØòÔJLµa^FY¼ZPS¬#2µYY¥à?I@ÉuãèPm­iúQÉÐ5]ÄýRî{ê÷#LÊNÜ´±ËÅ0Üº¯¶À¡ý(¡-^A-¨)ÖÌFÚ¬¬RðMDBÉ$ äàæKm½7+ºt±F¢«].þ")w=õ»|¨¬-nZèìi´p¬ºXAÀZCXP¼
]XzÌ«Ì9²àåi)1ëZ&ª.a{I"àg [ô3)ÆLY¯ îAËjöx»}{Ì¡º£!f£l~æ¤!åýµè{êw!øPY[Ü´¸.¾ZAÀZCXPº°ôWrL.¶bábK0MT]ÂöD³!#Ì©Ú+W¾Ê©Ùõvûr]¸8Ó3Q65"¤¼¿Ê0¡ï©ß¢7AÂÍøuGÓclGÝÖÕÉÉcF¥¶ái¦md¹!§°5ÅuÄ02Ô$73 P7¢¬/¦·¦y1××d©Ùã·Àÿ¯h)ÈÃ^Sæ_¾§~ZnÞd]9jÂdÊä1£êTdw±Õ.&§°5ÅuÄ02Ô$73 ÌÅÊújz	i¶.¦f×/çÂ<à5eþeðò]Oý.¿Ü~©÷°6X4aÓÑÕ7×öìµ/bòS,ÒS¯Ô*Ò.	o£ÈoÕdh6S<[í«úÇ>R7ÆPßHé-¥	où`XU©ñ7Ç¨RKCào¨e,±Ò`îáëÑõÔïBÐÅ_íq1íóS,ÒS¯Ô Ò.	o¡]páâ}U)ëÆÄ±àÅ Ô7RâgzIiÖ.¶ªRãÏ×ÀSËêQº/×6Akô¢§v]7Y¤½Ã¢ º<*7%a_îsBßa+üÄSû»aú~õ}éZ.T 0²ó 2ªr±K¯ã;~ç/Za`Z°ÜÌC¡Ò÷ôsïÛ¹öy4ûRY¹¥%å-§eÃ£MÊ Z}H:SIEºË°(.áMIXêâæ)vÃôüê¿p±r,T 0]ìõ`|G]Z°ÜÌC¡Ò÷ÇX u±4ûRY¹¥%å-§eÃ×NÊqï¼ü|§&(ÇoÄl¶øÏA·1\$©2+B~1áºë!µ¥ÿ§XþØ¼#¼/XÕ§È@U«·oÒÓØæFËÜ·|§~V©LQT¬"V×¬Êò%°©ä²,pîÙHYïqyCØ»¥-ßÝm6¼Ã²}-¬]òó»¸xà[?]¼V¸sq¤Ê4»8$Pi½ÜÅÍS¬
I¿Üåb¨jõòyáb-s_¶..*VÉÅ¾àâçÈ²`ÀqNFºçf#e½#Ææ9Q¸8è,ehùöv³á~­­øbèIosWÅºdË¹%Çè·js6ã Ñ·$îÎ2½^s§²Þ;0[§ÐÄÌB!ÇV½,GK+ÅS,|û¢p!G¢TäDgp¯¯ß¾9öoëß·,UÏõ°èX¡7£·aÚ£o2ÃÜH½¹bFD+eÒd%e>ÝÝÜ@Èl
RÖï¦)ÄýVÍÅ®×!£2Iáb×«uáâ¢Þ;0ÎÅn²¶"
C+ÅS,\ü¢p.F@v1{}ýòù:¹xýëß,,¹x\1#ÂÅ º&3%Ì^Ê\1#¢2i²²Jnon d6©/Ágmê»,BWRÖ^öª&X9()¶ñüÀAï-¥@0GV0¸!Þ"(áåäø=x%&V3¯­´ª´=aª?nl
Æ³èq²Ù`aÁ a^÷tû°bVÇ²Ð6Y 4SÉÏô(*A­ÀHósE3lÁOwÛíÝÂ¿ÒÏX_Î$ÛÔwé^KJ¹rqMÀv¢rñóÆÅfbÂÅÈDDëbÈú¹¹½X	Ì`¾^¶2èb)9»9Rªábñ,ºÎR6,,¤S¼bËânåâd ´M ÍÄfãbBhF.v	dv=Ýn··
ÿJ{ñ	t~£_Úã:j8¢cóödQÊÀzv2?3Ì¹'gÚK6èæ×±ÅÄÏô6fasAN^>dPÐJQ½)e\2SQÈÇ!eË\<"XtûAøí¯V"JÝêshSvS úðhÍ/K¹¢#'=üîg,9^ßèæbuÔp1E=
PÖûw¹ir¦½in~+YLütñËiÎ9y5øiBEB+Eõ¦ÃÅLE!¯CÊ¹xD°éöH.QêVwÓDÓÊ´Âx´æ¥\ÑÆ~÷ó\Ü&§ÐÃ¢oI¤ÅºaÐÞ77ÐkY[.éjºæßqµ¥ÀwÖ
ÂÏÎo£!H¬{øXOE¦¥ÄbU
eê~¦2øSH2rÆ|s]Mýæ" i² éIÂ¯xÔøX_3¿]ÑrºmfÂO$Ýì1ÀÑÃ¢oI¤ÅºaDrh0Ïz¢×²¢$©ÅG¦p1¿ËÒR¸XRÞp~³,AÖ.f¥øö/b±*2Cü)¤B9ãD¾¹®¦~sÐ4Yô$áW<}Ö×Låï`W4¥n<Ûä,])ºj½¹X#ª/É0,8ÀÜeÕ_¨pD<PKÞl%$%%'>Ð*`A°ê­¯ÔE¶<Â)¯WqûuMq·«ÅM`	¬V-Ào²M\Õ2s'+Ð¼)[oãÂâÀ"Ð¢ûA¨Ö5¢úra1ÃíIs_v1°ªòkUúUò4BÂÅo6È+]l\HÅÂÙúê@­YthËs!òz·_×.V®/4M §èâö8e~mº/¹.VévG_.¹*ÍûBìþ¸¢x¯,tVÄ´Â$À(	MïNDêT,Â*>ù¶±H3êUj!§è¢«)×`V¨Ó`æ±>tòi$!Ñª¤W+ý«ý\¢®¯îÝ?îQÜ"]1­0	!0JB¢c#Dä":°J)],ÑÁî!.f©È8qN)ºÒÅV¨Ó`#ëC§ÞÅN«V^­ô¯vqÜêjóOWK-<à`	ÔÐúµëb9çÄ°üÖ:ÿK²ÕJ1ù22U Á¸«.Ð¤)ÀÂ4:':2¯ò5ª5*÷K±ï[xÀÁ.$©Ñ»ëb9çÄ°ºôÌðà n°×Â_QzqÔÃã!.ÊK]
,'¦yXNfsý:([À¸Á^|	FéÅ\PDº(/u(°dæa95Íõáx¤lø6x,7ðdñh.>tX°é»ü²Xìâbðý þ9«øõð ?})/º¡«#XfõT/óïòÓWZ|¯:beVOqñr×Ê}³cTº¾½Pç O+üïiÝXÖæÞ%£¯ÔÓ¾Õkpæ	¢k¼¾5.Å\ü{9£hÃà½´[»W£n7TaS¶yµÌ§Mô>E²ýÈÌ YÔ¹t±/}§7àÜSÃÁÅ-A|#ÿ¸NÎHíÜ nlTâ÷_vn7TÏ§t4½L¯îHfFEW@¿Óu´Êæèû8°~ih	Ö¤ÛnwÁ¯f8ùÄðË¹æør¹äâs®²n6tTG´¿'ï06{'?t£k÷DD_Q. y1¤§n¦©MÖvmòfÉÊÖ7F£¤BõjÇ%­®StÈJÖßlúòóÅvËí8NÜ]åÙmè¨h_ÐÅI_áâÛ[ýÍf`¯¶[nÇ¹ÀÅr.$-Ñ,H32I~v·ÒÀpV ú«dûjÑ²áûo=º9Qm_Ð×j-HáÆ¦N÷R5¼Ê3-[½SS \êYæDÌA{d?÷9%p¢íêo«­3±×]½ûö§,sñm9éûT
s«¼3PÑ~+Höµ.v)§
$+ùs«=Â9%p¢««Å.[
ènË§è¤2üâ&ü¿¡DqKÜôcÃàyuûÛ²,eÃ­´²}µ³néfR$«ºYqãÕÁX¢ü³§½8:Ú¤ÜMF¼s*Lûç\ Ïbm¢rñ7ùùoÞZåì×Ct¾hÎ`A!³ÄÅÚ#Ïa<¯n[¥l¸vv±z~Ò­»¸H6çâ~,QþC¿ÂÅÜF¨âµÊÕrGÔ1nwLtÒSÝ¹£±v
xØ\ )öüÇ¤å	ó´KË[±Ûß	ÜtËt
&öÕw.\Ê9Ù&=½¹Ú{ÞÇnûLHD[¯Y:ÜlÀmÔôÿc¥dÃLn§\ìðóö-ûÁëK¨þOî`=öºkà¬½i©n³Coábí5@QJËpqH+\ÜîoËnºe:ûj×..mØkû@#¿¡¡âr3õÀÅWÚ·l¹S»l"+Á4ÃT}øçkðÄI-mR8ûyâ¼É½0yN\?OÜ­>¤å~frØÑÌ¦ÌIÍtöÇ)È¸¼¡ÉwÁÖBYì=Hy"8QZî>û&~ÿÎJC1Xp8A)sÑÌò"¶Í l³È
¨6Ül[$æHÔSã.)w¾hÎ`Aa*Ì>ÉÅWÔÒmËL×Ïw«iv4³¥ir1Ò%7#¹¸ØP(½q±%ÿ¤åoébÛÜSÚíbT[.öú;f]ì9:òs§'mÎ ¤æÊÜ.Ìxáa¶4mèpoßÏrÂ<¥e7#{·Vh`-'øYS42Ff9	Å~Wö2eªS,ÎUùY?ßl0È¸ËäöY¯7ß`§á²6Bõó²$e%¼9Q¸ÝÎZ¨Àf9<n¹¢é;=ËèJj0è Ü¥¦¥vÇ.öý,'ÌÓYZr1§h*wÖÅûmïâK&%;]JùRk³2Ý¨}.fµNÎ»¸
ï=h¥0ÝfÊµ,\\ð^csyÑ
jCµhPí)#'IÊ³Çh«ô¬VÖF¢Ð} e(°u#Ì¾£½BÜ&KÒÏÉ5°a¨Ea£ ºIyZÁ;Äk|[Y2~TG#2S¶nàÝ¢ç[Nh9ã2Øpº%À)8×`ïA+ýéþ4ÃT®eáêJ.ÎáÊÅ¢!@s±r´ ¼¹XZ¶.Vî
q¼½ZXÐÚåbráâ4 ÂË\¬aÊÖ¼Ûìâà2Øpº%À©.®ý¹*Ñ?îO3L&íâ>hdïïqÜf«¹þÐyH+/+7nu|xÌ-rßN¸ëìyN@²A:dbÉòa,ÒXbL?Ê ¥,=ÎÊ©6Xù?+°#Í]{Ê¶r2lq]ØcÌ¤eµúiÑ«Òýéþ4ÃTtqh÷A. rö×É}knûò\ìc1;]l÷V¸8I¹õèÐÅ·í)*ÚrÊÈ°Åua1Õê'PKYs§Í{ê -Ñ,H3L7oµ)õê-ò*-*^v7sTõýoó4çº¢:æ¹''âæ`îEgÐL÷CáiØÿÃIíD© Ìb²
q³Ìy8Í&ïwÝ)Ù¢¸Ö®è©ãÕO>wBr÷ÔAZ¢3XfJ.æ¦Ô«©ÀÖÅÚ¯ëeábVãb72jÍ-r.nTU.æÖL÷CXââ~¢Tf1LY¸Ùe.Æ-ÙJõ`V?JÊ(~ÏA+Á4#~æV¶\ÚþR!UÞÔ|ãf¾q¯¢3°¦)Û4)+hWÄÇcß%7o·Å½Ì!©Hq;Î´Q&ÔäMHÖ¦4.ò¶ø!9¦=Î)4ÉÇ6ÐÄuìxwF±ñ`ÜôFï¹­~ú·<+°ûqd'Dg° Í¡¹-%¶¿T¨q±où¼uq·iRVÐ®kß%7o·Å½âvi£L¨È¬Mi4]åmñCrL%!z8\\hrÑD2`kVè]¬ÕÏØÅ^J`p¬LMtÒ	¢1Åæ1aÇäLÊ)%O Y)ehRVÇatüæøm½9¶ýC0ªT©Â ¸1 jC.ë}°->GµpÑü¸ÝÂ] 0¶rÓ?´Å,\TEvåàã4
 Ë£ð­ÕÏßþ¦¡¨MÁ±25Ñ,H3bàâµ)®Ø4AsN3)§<	f¥¡IY­Ãhý|ý²ÞHÛ~©ý0ªT©Â ¸1 jC.ë}°-¾¹¸.\Û¸é	ä¢*.nÓ(0r1F¸m]ÔFÈ·d@1p+áe3«ãÊl¸ëUÙ¨gòquÌSÎ Ý¤7\!=e)#¥ËtÊµý6æi¤{+ª{åÛ83«7TfäLBMBªT¼[ÙÉ¬¹Ó§OøÅ¶øÖëÓ)HTz¨Y9tå±¥#T­ÿçãFK©ýæêÖLÐ,±ÞïbîºÅGÕD6
ìL>®Ö<åÒMzÃÐS2RJ¹E]Û/cFºç°¢º³o¸«&9Ó PSF¢*ïE6F2kîô)b°->ÛV©4¹¸$Ô¬ºòØÒ*«sq7nd]Ü­mS#ËÉeñLR8wcM¬®¹fcQrË³²ôG6ö=-'ËóTb	.ß
Ì¸ß4wÚ¹¬¡Ô©8Uò1*ÒA¸H	
9mÿýL¹[^uüáÃñ×nG È¾ÃrÏ[Vý¸¡]À«ÕoËÜyqë05#%OÐðÈ$¥©ýWð zicÚ°#CnyVþÈV.FuJ¯]ÊÅmÐÅwÚ¹¬¡Ô©8UDábKáÝÕ,]Ì&ÏÜ-a]ø°þàÚí Y·.îÇíÞ»¸YýjB £CôSd2¤4îDXY`ª!ø(a2uI+Ì _3E)ó49¸&mªMÊù Ú½r¯t
v¥HwiR¦ó0ï¤A5u©Ü õáÃüB¹sU#9»1ýq´£¿oèÂ7@Î³&ÁÊÅÖ¿PáÊÅå£4¼«äb¤)¦j>0:¤qjZ¾fR*çirðJÚT U¹X»÷Bî¥¹ìb3 ¶Ké<Ì{á"i7ß¬ÜHrç«@ãbRõ¸¡ýÇ.Îy&MöçQHÎð5eþÅÄfÑäi`à~¶4 úÉòTá¿,Èk5§Í¬NÈPÎY@*ÎÔ4él5Wr« o!·Z:÷
RñU2>qàr¢ Ö0ð¦lgèæáItpÃì;¥­¡!ÜÅÝIÉÅê úÉæ°©ñºØÆ¬NÈPÎY@*ÎÔ4él5WæQÞqÞ:Â<ªdî	¤â«d|âÀ*åD¬aàMÙÎëå±%C¾÷cmíÁìBÊE7h32&ªdàìçÚSBÃÐ£ÞªwéÌ¤Ï®ö!Â%áÚj)£0³Qu"Sn~Pè	s«çnHÙ´\&ãH½8¡V·Õ·3ð3ªU/íÐ]!ßû1Æ¶vàJ¶<2©HóÜüçi2©J&A­ç?ÜÅ®­&2Úãb-+ª#Ì£»a eÓrO õâTZÝVßÎë¥} ¼%Öß¦&ï	¼¢
/I3JU´W;@#Z-0¢M·0T5/ß_¸c~êà! #2 #il5é­´omÊ)»È=¬]Ú×`µmjòÀ2.*¼$Í(UfÐ^í hµÀt6ÝÂ|RÕ¼|1·:"S©	:¶ÉVÞ:@ûÖØ¦²ÜÅ{¤,¨ëø5VR\ÍjTÍ%@eÒ¦MõXèïÞ_utAGU9±#úd2A£éíÿÒÐàÃc#åvi?º_Ó]
'e¡Us	P´ifS}!þÍ\FÓÛÿ¥¡ÁÇFÊíÒÞÑ'/Ð5)Xt¤ú©¡ñðàø2H54`VíjR-ÇçÐåKg"`P©~jÈÄÙ¤@º¨¡³jWòh9>H¾4w|Yªö#y3ê÷ÌqpñÂC\|pÁÏ­ÎêU©ÿYýÏÁ«¿ââÓ^hQFxpâàÕ_îÎE.>8ý~	üRÆÂ¯øEqpñ×b(e~¨úYGtè,öK²5Lå7¥)ÿ­ñ§?ýÉ¯ztØ:ýÄl~ÿûßûÕPÊüÚðàèÚya5Ü\9ýUmîz@?ý÷ÿ÷¹çàâ§ßÿçþgÒr/e´>·3ÎsÕö'éóQC¨KÕ~¦´N);¿> øÓÿ¿ÿïXËÜspñÏßÿçÿóÿ$-wR.öý!:íOÒç1¢F.U.¿àfû[ð2©Ûyè¡é#`Ë³ÇÈnlK/åbgÚ?ý÷ÿ=ò÷\\clK/åbgÚßÿçÿ9/e4¿7!0$:íOÒç1¢FH]ªxS¤psNüÿcl60< !Ó±çÑz<=¬µÚYXÊÑ{t_Ú?a=ò÷	*ÂCjîâßc=#eÜ7 1":íOÒç1¢fBYaÙÍÍfG¯KN<h.¦l[ýî/¦&,úÜ´#zc% Ë®ß-åMK|Ü\ÛvæÓ&Þ÷Zàs£>uç÷½vQûçåIJbHíÔv)IµGûWN-Glé
OWkÛõ7×ÄU{ýÓåÐÆ7ã´E÷øÓPÉÖôåùc"ayRÀÁÅÇpñï%·RæÖP<ð.ëy¨áþ$1¤t/Õ¤¢k^æ~ÏN%8µÌÛá¥pUç¼:Iáç²ÛE}rBÛ$ÜlgÚ}ë1[Cñ|ÀÛhúèD¸?IG©þÆv»û=;U¸£nªE`vÜØ/eÛüZ.®²÷óï$1íÛ÷'éóQªyTÝrÔÈ·,?CxøIõSßÏÀ,¿¥¯ä~±½óM5,\PÞKÂ<'t-ÁJü½?QÓvÝc í¾zu+i/ØèD¸?IÇÜn#F¢¥=ý$ú)[jÐz,¿¿°Ëì)1ªG$øí¢êþ$1¤xsàbQ£\IÉPÞÝ6{¶BÍ< ÈC,§ìMÆKá»üLO×V|À¡ì9¢o	1h´¾·×0¿¶{¾#bçòß }@tBÝ¤!ÔàÆQ£u1w[¹¸f s1Ë)Ýd¼¾ßÅ¥ æçÐP6ÿBu1O×ñöæ×º¸øH?ÀuæM_Kô"l-#JOM5jdHáFÏ2³(4Ü=IYÈÅj6Çú=ÓdyPP¸ÙÏædMÙ=
+bôô°úa	²Ñ½Õû´]÷GëÌ[(«èEØZ, FTcõ¨ý"=ËÌ¢sñwFRrµÚ¤Íã±~Ï4Ù..¬ÑÓÃRq1EËF÷VïÓv..¿#bù$°P«ÑpQº»jMÝ@¿8.×à4JGó`Jg&Y<292KÞm>bFoÉX1Jï"í¨:K9¢o	2êF³V¤íº}E¤Ó2ûµj÷'é¥VÓÌhêúÅùp¹>ÄÀÅ|äF!ÒI#DÌw­p±[yÚQurDß&eÔf­>HÛ¹Ø¾"âZöÐA dÛ×"Ü¤'Ô`aA´á°Ûa°.k¾Æ\<iÔR¦L¿±å$ÈQÊ,C>W± ²Ur_¥1pñ<°*ÿiåçrÿï?}ì§et(ÉÓ`¸áÞ$=1 Ó¢ÜuÁXó=F.¾¢©Þæ½ ábÇÿX|-ð½Yl¤ÜWg)G&\<Ï#¬âÿaÚnÿÏßòGo(9nE8N.!ë4VíhByÔ0@"tâRábàÌA7ÓIUn(Î(å;³BÌ©vax)Xð ÃÒ`ÔFur`-±¹®*VieÕ ³ßÁ¶ùBHáVã$èbù² «4£)
äQÃ(ÐK¡s~#Ì¸Øï@ùNCâ¬sÆE:ïâÒ`ÔFur`-±¹®*VieÕ û¾ÍåEñ'g\sø¦É´þÃä$,I|ónD`pËÜFavàn¡£Ó¨á¥cH¿àæ¼>qîCyÎ¡øbv¤¢Nv²9)ë*è%-åÆ-¡Ýf³I¤Å z×k$f÷hªðÀÅì?ìAèâáÅ¾éØ!JÇ/v1ÊsÅ³#ep²#eáâõKôrãÐÁn³ÙÅÀ$Ò#Þõñ¨±)Ï¶@þ¹¹ñó
Ái2s;ß@oñ+!öêfB×¸aÄ1Î
[ndáË#Z(àJÒMt×òsGÒ	iJ-å-)'¶²A¥´î«¹åú s.öóÓÅë5~Ã%ìÕÍE3¢uq(Ür#Ã¿ÈÅe¦/é&®#äâdó§!¨pç2nØryb++TJë¾[®;üyÀMÆt3½³½y#"TD¢DKõ7oðëa×¬§(¹ÏºÔqégfC-£ÇZGay³¯g¿ýaÒ9Â´ì`vÝ¬>H°n$dÂ*¢<7r
+M[¸(;7]Ê	}KôÊä¸¥EëXG LËý¬<ïâçªyK"TD¢*Ú¥ý?&pO77Ïã7¹]8@¦pñºs±ºõ¸Ø&#LËfg`«SLyõAu#!Vå¹Sî:Ó]$]Ê	}KôÊä¸¥Í.F\7`Z5ºfÐ#ØÞ¼%SÐK°¹òâ^Iqoßâ×ï%M3qsftÃa£Ý¶t?sDvdt­ßäh½	ÈÃö,ÙöÿiáÂÆfÎ	V
²ÓßôÇ4p´D©xÞf%¬ªNË9G×ÚPÔu:ÈÁ0üâ¦y%zÂÂÅ/É"ôÌ¿ÂÅ/_â7¹]³¨ »ÃF»m;"ìb{ì?ûµpEá{]¬!¿»\|ËBw.ä]K\{°D,æ¿¸Ùüüönaf"´Rý|ÙODÛíÛ·Óu8Ú'e
¸YËNSQ¼ôìåt'4ÙÉË-¿¢Î ?KVh6Ü
ÓÑ)øÊ(æ>ÙÅk¹U!¯W¨~oÂÑ&Ñ¼p¡áRÉZ-au!P¹"»? ÍnàFÄÜ\üòyåbÐ2_·ÜODÛíË)¨<¥¸YËNSQ¼ôìÖû\ìÏÕÃ$.¶cuëb°xm.Ö&òÏ¯W¨~Ï%Ñ¼p¡áRÉZ-au!¹¸øQ!fc2ºóqÌ&E J~Éq>ÐÜM°Ä"^-vÚ( ¸Fî4_øm¯xÀ2§ÀèÞÉwAò³dñ0ÉÐ3©&B\8´½Æ+\QÎhaÎóò@ú]ÀQL@ÙÃþÆë·
dø@u´~e0á
æ)JFèi¥ÊO£ïawçâùê(r½Ð3YçÍ?»ÂÅÌe¿9jt§©øÂ ¹ø9Æ.gÉâa¡UÖT¡µ¥âàWlZw±iB¹y^ÈÖÅª_ãÎ}ÜãºFÅ{Ø^¹ãö|@È¦cÆ¼,I³[¨IF9ÇÓµmÆ­;üÌ!gp#å	õQ¡po²Õ5&AB¯aÉÉ ÌrTrñ0ÉüÑ\¨­:]°¥¬Ò2Zâ¥e+¸9[ÍgLá'-\âfræçn²%ª¥`Xé-XgÀ:ÙÃ3Û¬Ûó!C4i:fÌ1¹E}Y"ÑAÄºr±¨ÊÅÜP<CiÔè],ÛýÒÅ,@öä1ËQÉÅÃ¤»µµÖÒEébUPZCKÜÁZZ¶ruÜjçb-\wîåÂÅÍdKTK1Á0±Ò[h]\n#utº$#Â5¾ÂIa1ÄÎC°8ü²Á8an`%íDÑ´s£NÊi@]ªÜ,GÛ$|õ':îesTÖ?(ª·~ì°Êf	,dB´E) UZçwZÌRõNK¹ñdÝ~lÔ95m`Ç'Æ,wº$#Â£pÒeXÌ%Yé|8Ãp!ÖâæbU.F¸²åFºt±eª]lðëO´ýîesTÖXÕËÚÅÌ2¹8D[Rõ Õ:»Ø,Uïd¹OÖý¹èk[è Îg-§OSÝ¦|ìÉÜcó7.­Á\¨sIBÌ7=§|kv,ðXlö|ólþöM¸0
xãi]Ë0S°ò¹y<üi9Õ&ò	^ÞÄÂó¢~,îUÆ f¤Ìj3¢í.î¸|ïq3Y÷ç¢ù9ê=aJï¹i:ÉÇÉ=_óØBIÖÀ.Ô¹$H!æùóBÊS~ábfS¸8Íæ/.6
x^¹ø9'ÌTp1Ó2Ï1-W.F>Ò"ÁËäbÎFú±LºV7"2«ÍR¶»¸uùÞ¹¹¸¬ûsÑüµ6§òßSÍgPÍ'édpùË­TèÒ[ßg½ÕIì(áãRÊQ}Ä ÞlAçd¦)_Ú;æ¹õ©¦äÁ­h¼ ¢××+®£6ú¨mÈ	P«{SÇ¬P*O}	^ÆcJaðLIøOÒ
2Ø@gúC.H4L¾?/¸R}÷Üó«h¤<:l>AL'#Ì_÷W¡K¯)	Ïz«ØQÂëRÊQPåbtÎÒÅ*	Üºv1i°f+Z.¦£¸vûràÈÅ<õYZ$x)Á3%á?I+,È`!êWZ¹ Ñ0ùþ¼àJõÝsOÎ¯*Â\\¹«ÎC.®ÜEÝð@~¾ÆÅ"*hF«a%eÐcUT$ôÁ¥¦éhß1$!Jf²Y¯aÑKÖÄ")ËåV$iòÀKóºûãmÈ¬²³eÑ-C½Ø	LÈ3;a»ê<§XÐa@a¨-¶r±ÌÅmH@UQÐÆëdä·$åbÿxFú¹¸2­ERÊ­HÒä9æu÷ÇÛY#egË¢[]ì&ä³2 PløAHj/¡ËªíÝª
øRZnÍ/*ûùM!eÄSì<-dÊÂé·Ç¬ÆzÈ#:5×0ÛÍ±´L½^Ë/c~^M&¾õ]âHÏAþF®Ô*ñ0^Õ)X·¬dæK1ÁéFhUR$	«K^«sÑéàg¿ÍßãbS`ÝìÙ[E]<ÄÅÏ)#bçiá$SN¿\c²ëi("èÔæâµ´L½~äbÓCÂóìbI¿+õÄJ<Wu
Ö-+aä"1&8Ý±À±J$au)Ó+qu.º1]|ÐðàÎge_Ç ¯Y¾°É-¦pJG+¶Ù®Bf7¶þ¤d§JÐEs;d6ÑèÃÕñàìç|ôLA>}|25jtC xÅXå!­EÆáTñ`¸¦´Ä0­ù (ÝïkKÊÊ4!\æØQ¯þôñO3»ç²	Ñ;kS%è¢¹	2Íhôáêxpösº2Y+|úì]tC xÅXå!­EÆáTñ`¸¦´Ä0­ù (ÝïkKÊÊ4!\æØQ¯~ÿñ÷y÷Üh½)a½zP/5dc"0´MUaÂ·ÓDÒ¡[Úñ¡}Öa ä.ãÝ|%c4K0x~^ñ,@³E&bCáæFê{BL¼tz @Æ"øÐqgðþ@ò2J3¨S^ÄðÐ3ÊÒ¯±ºÛÓÍ)a½zP/5dc"0´MUaÂ·ÓD²¾[ÚÉÅÑaæRµt±ºùJÆ4h`ðüó³µÊÅ&bÃ©(Fê{BL¼tz @Æ"øÐqkÈfSº!ë_åÈÔQ~Õõ£~$,:²ëkÕ:)S62ÅfÈ@G¯4
¾&HZë¿9Âê"@¢*ÉÃ6#9uËòE3T"mÅB[1¹ÑfÿÊñÇ¡éÀ_ãbË\bA±ªV5
¾&HZë¿9Âê"@¢*ÉÃ*Àø¿¦+\ûÍ¢*~wì"òQÏ2Î÷W[CT2î:Ý7­k`t^¸ä ·³¨h\3Ñ.ÜÌ ³aBéå`÷îÝN¶2ìÍ.¯rÏÄ®óß~êYfÐ3àÍÖÖ\6
­k`t[hÅ?rGËY´v±Lt73È¬dáÒû3·-¡èâù½½~RTwg8>Ö=Îx+ N tÜÒ_FgX_9(QüÏcÈÄ¯+0µàa #~eît½ÖýÎZÉ@é4¸¥¿Ï°¾rQ2¢øÇ_W`jÁÃ@GìÀ2«8àc±Íÿçî~-\üSc©9ËcÝÇívÚôrüô¨]Ü?Êð´QKyÃ?Â®ÍI^Ü]ÈÏüÞr+æ~Dïsil>8øÅøÆ]ÆÇØ¾c;«øY¡ûuñÕí¹øeú^rBã>^w¹46GTM½¹ÙÚdNàp+Iyz³á¡ålÈ4å¤}ü±yãhløæÜÈÑlÑ'FGåYaÍÂ\ì¯ËrräT])£bémÇÖ~dJnizÃNs+Iyz&Ñ·æ\Ìwö¹Xï'\ÜR?2%·,}ÕÒ¸_ýù'Ýá~F¤<ßð{ýÐrñù¤}ÇIÛ>ÓõHGaÃ]vñØ×÷ùo°1KÌ8tY.ú"/lá® Ã=3­rûc|¾FÖyF½G1×Oj[S -ÐÈ«Õfû÷ÕÊ@-vºXRÖ7ü^?´Ü¸Ø'í[NÚö®G:
NìOpK­v®+Íg¸³$îß¤<Å'`å¤}ç6Xy±Øõ±oëç®ÍÜÞ]%cÌãlæÂv<}ø=9>÷÷Íñ¼dZCåÙÔNeªôûõ¡¢¬7­Ó¯îñoû÷ûû¿rÖ­cG¸R¾¥MÊcÒ¾õI{äâjb×Ç¾Ë|3pqpñr×wL7_ð,´FÊ××Ô±¦TJYµÃ×Sû^OÚ?W6#)Ïx´³ss,1ëP'çFlr«7T®}K-JKgêÆÔHS¦hç*ÏÌ1
vÅi§Õý½sµ
¯xZ#eºø
¬KYµÃ×óv÷ÕöØÅÙf$å±o;'0Îfi.K&vË7i6àgÜN_Ùlù¥u¿v¥¤<°ÉCA`ì	Þs3,1ãÐ¥¹¨Q½~ödÅñ¼NçE®È3q"Â<SæeÀ(pÙÍezÂÏÕ¤«Ä%çMZp±N_Ùlù¥ugv¥¤<°ÉCAààb@a©¯tqU³ßr[t(¹.ú"¶:ånsüZÕ#Íh4iãQºÊbdÓ¼>ç9ñ÷÷ø)è1Ìd³8äWwk®ýìE îçáÔ(gºÃÍNÁ1ÉÍÎ0KºÙi'<`uoÜÅÐ1\k.æv·õsjU_4£Ñ¤½Æ£tÅÈ¦y|Æ7Æ_Ýßã§ Ç,0Íâ\~I&(A§ãAÓ¯³
zq·º»¸±t)åÑ¤ÝÊt`Sý} æèÄ;Xß¯îV÷ÎcÉfq.HÏ¦6j(<°È!ts9it¼Gb¶¬´:ËõÖ(ü¬`Ü|k¹&úéQ°8%ð9?ùËªº% ãqÊ~üPÐ«ÛÕíÕ­ K)&íV¦êïó µD'¶ØÁú~u[9gÌ3Ù,Îåa.FbãaåzÁ¹ñ5ú"_Ü]\ÑÏm-ËÄX<9HÊ¢QFÊ£ISnY±G:fÄé;XÏðcÑìÒ\à\ú°ÃWõÞ°îpÏqW|AB¦ôÃ\3«Í=ZZY_¢áÁ²öpÚÖÎ|ü8ÝßÃÑ`.'7aÑÈ ºzõ¯­îÿõÕ_vÈÅÚZv9¥JÊ¨X#åÑ¤)wäâÚÆ#3âô¬ÅçGø1KÌhvi.É.¾-\Ì$dJ?Ì53¸*\Ü×hÕþ°v&\æ*qr±º¸°Âýpd0-cì[ª(B¾p)óï`ìÑí&íúÏµF6õ
{NãÓfÏHÉfi.HmÝ`-é~r{¨%ïa}qRæ¼5f:/è'¹ÖE-ÑÐ[3g>^#f49Ò#µ&;£5Ju?ÿ«²¹Ø´Epëb<æòºJæ
ºpq?i÷.nmêö8Ç§!Í4ÍÒ\ºp1¸9c}qRæ¼5Bm]²a]Ô®3sæã5bF3)=Ra²æ\\¸÷AC²\a#b¿·xü¿PÄìQdÊdÅ¤}?«Æ6)ÌHsÒ;ÍØ¾c)xÀ`
áwµy¥°8¹f*)w5²®C]]Ü± hÚHó0v?é8æèÅÍ¿þò/à/ÿZõRf¿Bç@·ÖÁÅ~oáâ+EÜHÉH¦LVLÚëüY0¶ñHa^DÓæØùlÆöKyd#aáÚÅzT`qsÍTRîj]|uËBt±
ó0ôLss.®\IH½òÓÏyWd<Ù%ég¹T¡FôzÒ>Ö\OmJYqj@É'gX`&¹@XJ¸¨T4Ã67ï'0ûRµd0òÆ,û©ë Kä^K+i(æa2ikÛÊÏ\@3Ø{þ¬VÝ¬üëGõÊ«äâBËt1»$]!*LÚkmÈåñÄØ¦´§Æ lprf²Yå¨D.¦RÐLáb¢ÔHî..L¢ÉÅd%·RÆJ§y»q[sq2ÌÌ¹¸l Eî:M¶;R)eVP3ú¹ïÍÀn¬Ëk(¹òóØ¦²èd`ºlCÙùlæÂEÂg'£i
?ÛNeSª¦Í_ÿåjä×:²¬}ÖkdÔý¿¢;déNægÃ¿~s2aC£».Îå­NOÿôï=+Kv*Fsy%]\ÙT¬@mè1;ÍÂ\¸C"£HÙ4Ã0¹8«¾qqW#¿Ö±euÌ=Q#£ÌÅeéYº¡ÄKÔ2&%<Ì»æÕÒ+1µo"²´IÙTUÄÍÅ¦fáVæZv>·úü¹|¿§aá³8|Uã¢e&+ºÔ3¼÷3ÐòÝ´ÙÂÏf8¬¨qðÎ4êAG+½S¾K.?cÙEôJF4çÂÅõ*qW»]J§JIÙÔÕCìPh<.a°i®eç³xW¬\,Ý]e+3YÕ.öB²CË·­»YïQ°A»Þ©Hß%sqe£ªòÝ=:Æ¸Îöj(¡´¹Ik×Ú °êYm.½ð½Òú%6iGÛ­³Nd5Ëa_Ý~2ß°ðÙfs|¬_TS~¶ì8ßJ'ç¢%¸3
+ýÌû±õ#ÐS¢£!ÑÜò¯|&v;?XÕÉÆÛ_)@¶±^îâjÒ^]\Û °ÎÅÒË×»x¤Ù¸x½Öor±Np²Câj£%E¸Ø":+ki4$À\\?»¬êdã>Ãó:oÐÞcnµ®7töÀ¬±a=-"àMÎ+ïýFMÈ³\2MÊôuÜÍ ºõì:Z]ã¦¢[vº£¾ÞðúycA¹yFbÕÉÁË`ùë_eGh¤W,bcF¦9Ôþ%	d7· À.âÞY)X_[ohóaáÂÅzcj¹ÙQ÷¹¸¶y°×¥±Çw±vúz\lAµå#º*ä)bAµ¾ÏÅhà"~áõN|æoÌCÉr3¦ÊÏ~9¢wÆó6Ñæ¼Ã¸Gö»gÔ=EßÆÑMáPåB(ÝÜ±ê ÚÚåw@DP¹Æ@¬
èP./Ðq l,Ð?±(9Ë6DrÜ]®iêSSeám¦ä<ýÕ¢-`ù[¿},êo.pCÉòr±ÎCk]¬SÒÝÅÚÚuGpÆÅ\^T.æ 3t1Æ¢äbÛÉkn]Ìó¢`ÆÛLÉyú«5çâ/kÜBr·bÍÝ`W<1om*'7ãÎß¾Å}LÜ>Æ[ÖÛ~Kôµ\çz­°7d­[×á«æçîP`T]~ 1°e0ÿ§{°GFjx½ä7ðì;ã5MC¸7~¤èÚ
ÌßÇlñÈ(Ò f fÈ-¤9)?¯_¾äírGútZrqÃc¯ÑíÆÅ¦ÚÅ¸u¾ê. t£êò¥¡$»XâÔ ]a+|r±¢YíbsÑºXÓ4[ºX§m ÞÅ:âQÇîûÉ¼ô¡_ÎbÞÆ§4yL´«étL8êþþíÛ{{«õØ´êL¹°¹6ß¾ý\äÂÎKiM%ÞõÛ¸j¨å²ÔhÞ² ô3qc¥ðtW·C}à7Dü±Ô,¶&Os´¹êp£ÇÉÏQ'TÞpõå®cÌÙÆàûÉ¼_çb~àhåöZ4ÑýýË÷ö>\¸hÕrQk|~ùòs:/Y¤5 z×oãª¡ËräÑ,cDr±ÂÓ]ÝõI.üÚNjn]LÙ.¦ºÜè:¹8êäÊ¥á:ÆÀÍ`îÕ_[ §ÞÞÝ#ºaÎýu.Å©éÔ»mæMF÷RölJÍ>$îB&Ýô°Cã411J#('QfE³3èåþ>ì#Gæ|¯º'-ë5GÆ½óð}£¹Ukèi7¡÷ãk\þÉV*Å©éÔ»mæMF÷RölJÍ>$îB&Ýô°Ã\Lºt±reVÄÚ\,:ì#ÇÆÅª¥k9>U±r^²-æV-a§Wøìñ°Zå>¥ø4#XÇ¥ßBD)±Q6Ë*Ã¯Í ,Dy8­ºØ&ÊB«%hêÌ}Â8Lµ+JÐ&JÛ~Âdó>®Ãwvqî³YÊO3u\9§c£lU_)AXòp\Ìh$}®bECh¢¤£ MÙÅÆaª-XQ6QJØö~ qßÓ;[p¥8!ZÆKÌg³4c¹n?¤Ì§:;ÀxÄlÉèàhä¦´wPaL^°(\%!3^Xþ8`9M}4ÐÞ®A¢'AË¸cùlæ²æëö#1HÊ|Ú¨³\1GÌ£}P
ÐzÜI@1yÁ¢p4ÎxI`ùãTåLx*RFcleE`>æÕgÙÝÍò\ ½U =¼R8Ar²ä¶$¢©EqB gQÙVEÑ¶"ad8avÉ°Yy§Ã¨'3VË73â¶<"?¬jíØÙ,Ï*Ñ[ÐÃsI@($'KniK¢(ZTë2((8Ê¶*¶	#ËÀ	³Ky§Ã({"æCMê±x2:# W°îÙÙ< 0Ð gMD¤É1âá #2
&eY*Räæ^zá\'Ü:ØÉäô¡Õ²¨Õoÿ|2R¦oR­ÀÑ!çØÙ< 0Ð gMD¤Éñp ²,)rs/½p®nìdH²u±åÀ¨ìâ'#eÍ¦Üe%Nëµxq,+nÙùlÇÇ°E]3ËºtÝÒÐVBÅl-ÓrÌ5ö9Ø:Ùå#Õo¿ýöDl¾±(ä.+qZ¯ÅtNôåÏæ!¹p,`Àx\È¨;èbréb]áa·4´¤E1[Ë´tQ´¯ÌÁÖ9È,ßlüy.~*Æ2!:  ç¨Âµ¿Ñ\±ÀL6É¶^=\¢(Ìõ¸@yf×ªR+eYÑ¶ùJéÌ-AM±6ÚQ¹Þª+¥üTü y¢J8µ¯:}Ù³é#KÉæ!¹ÀÖÂÁCyagv-¡*µRmïá ÎÜÔk©ëý¨ºRÊõ\í°îÁl<[IæuÜr¡-_¢=	ùøÈ1 ©iD«áG~Ò² ××_É»ô'5);ÔëÌfói±Å$h^Ç=(Úòe©S¾6.¦­ùIË^l\_%ïÒJÏ`#uÙ<=aÈþïmÞå&cKÓãNó¤¦XBÒOkR~xTk[ð.7[wZúrÏÙ Ô-Ýx¬9Í.l¾ØªÍ¬ñ{ÅvYtÙ³nÞu Ñy´#hû§ïây£¢©¨8¿ÞeV?5:ÿw¿ôL±ý}4ÈMþâüzYýÔè¾#f\æWíìR,I§¿$ÙjC^g2çÁ9l¦i{½×ê~,²y´ösp­z3}þ<]>øxÂs×ÁÅêâHn©ò/>x'<Ê.3t3ýpf7^òqjªùô±Ù\üã?ÒÓ»ppñc`³¹ú.Þ/åäSîf_õÎn®üÌ?ùPÐKG·îtØ®¡åæº±O(xµ>¸ø1°¹ Kù~ÖöR¥AºÜ,S77Ï~nÇõ #&Gð
åé¶¹C2Ààß»JaÜ([!ÉÏORËµ½ÔÁÅ³¥0nÍ­~¨»¶êPú[ëfF\~C}^ù uñùséæv\w?ÀlepnL
 Õ»\­Ä~ýeØYÑíL &å§/en­.¾ú7rqèµIù¹¸n«Ü«üëJî]ú\úä^Í qq÷ìÙ4MÏî}@w6Ê´ôÚ*97&	k~Ã+ÝE»{Ânì.%O½­;çcJÛöë]|uk.¾ý·qqz;ÏÆ|/Me@+Ô±±ýèæ²íf
\ìBÍú&à4_LwÏ´£ÙôìsÞõµìN	ô¿;/ûtàÑ!	ÚÑ1hËÒEs=ÁÐÜ<·
U©×&òiI78ëbréâØZ.Ææà«é6¹8ïúús»8h¬J½¶.~jRÖÞô_®óóÝRq`£Çò/.>ç9øbºp?8'7c(/ýÌ®CÏ]ÐÛNÉ¥L¯PüRLõÝÊÍ0áoí¬¦#Ì¶63Ú·r¨Ð(¹Í¤rÉ'#å.¾½åA*NhUì(Ï9øêês¯¦+wq±ó>_=i×Jn3©¥\¹1OLÊáÖ\äÔ½ JÛÎºy`Ê³;IÙó3úñdNMS7°ÄX·TlïFOª2SFKOÄ3*ÀÛ¦î}ÂÀ1lîr\ïÆíFªDiRé(°I<ZÐ¯¾'vºØ^ ¥mç]Ê<0åÙÕ­¤ìÂE¹ý¸t1§îûÕÕº8khÆÅkï$ìvq-U¢4©ôJMXÅ$-èWßµÃÍGÃ«+{lÒ9,4)ÓsÏ6è´yÆÀÌ¬ôö¦1ºé"½íi"°xGnw[{ýl?b '5gçR1/ã6>\Û¨ÁÂmÜX5µ ÒÑ3ÉëÁo®5KÕVÜºÑ¯C3a§[ìvñÕ»Xç°Ò¤ì.æ*1÷.ÖÔ=ãâ[8ïêvkoqqÊ;]<§E¡¤PZ0z&y2ø¹Øù_ºp¶ÌÇ§³ä	C?sh©f`@éE8cÛnÕ¡}îü¬ÇgrsR¶3M?Ó§Hg#ñ¿à¤©b¹HnfíÂÀ9£iH Vç¨LTG$d«Ceà§1«ÔLÀHX\gÿ¬ð )gn9ñ\Ì=çb=>Ï¹R^éLS³@Ðx¿Y(År5çb®Ð· ¬<ÎQ¨HÈVÊ "9ÀN?ÈÅ«ÿjù_º½òKAf^ÌÒéN6éùFé($'z&ü¼Ý$¯ÂÑæçd1rtÎàÇK<á2xÔ­1"]Eü¼Az2Ø'CC-8¡4±R<"(IÑc)×Fg7. Bl¥ÔàÙß+¥<Ý.NÏ·t¨õÓ¤äÙåâdµÓÅW·<¹´ÈsäÍ±UaÎÅóNh[°PX)¤è±ë£äâ,¥ÉWoVFÁçø²éÁ~òÙæ¢2T= xhó3ûGáçðüMiý\æ rìïzÇ]é0nHJ*UBÉ~4¨PXr:>FsmhGñGÜ@Eõé=¶0Öji]VD`<mîÇB)ã!ØO>Û\Rþ..f×ÃøÃ]Ì¤ðW(yàbZrZ¯G.®L2Þòð¨¨>½Ç6Æ>ÈÅ,m5}*Â¯ß+å#Ü¿Bç¡ä)ÃËFçñ&ªg8ÛX¡]qÄ¡%§·o·±Íñ7æçæÍMRÆÚÚ´8´À¹I©°7m$e¬]§úlà@;_pç{×¤~g,
äøÈÃ#f°ºfÉ½ 1Nb7[Ôròý}á¥ÜÀéÓîûWè<<?ÐÅWÚG]üòå66²Y?>ïb=e·ÐÅP\,)õ@hâ+î¼1pq2(ã#»¸÷Ôq
ë.¾åÖå ÝRÆO!å|!Èa½Ú¯ÌÁ÷n§¬¼AYÅ-²dwÐ§N5dOS
Aé¾ýPX}×Ó°úêñ¨÷OÀ/þÏíIJ¹Âyü¥/îïñ£X@Cà«wúáú¾ÇÖZ-Á£ÇZgçÓQ°C)3Æ)@,WüäMã×^?/Á³ßg¿ýÝ/nÀçnp/ãPJ÷åç|HÂó.REür#Uãâ«û{ü(Æàb¾¸ê.¶ØZ«E#xôXëæâ6:E"Æ)@,]ÌOÞ4~íuq!Mý&Í¤¯å/Å;0p§GîøÌrXiu~n³¤ë[Cr7ªRÊ
¿}+ÍV·Æ&ÿó×)Î7µÜlà*ýââ~u·ª¤¬ìY²¹ùÆÆuµAy¨üe¼#<ðÈY)ßm·Êp¯l'*x¤lpºî;=rÇç/r1f;I×·änT¥~ùR}T»\¥_]Ý¯n£@eÏg]ÌHÁÑº)ËxG(/xá³R¾Ýná~CTd¦Â¨þ¤âûJÊ¸{nåL¼9.ÍR¶ÕZ«gÎº,åðg­½Ê¾¶áéXÚcyïó7Á6ç;AHªpÏó)å;I9¦»d@­á
7*¿fbrçþðtj¬Þe#¸Ç·[§G9ò ø8¹ Ï1áfíðìéqx¤Óg÷¥lN×Às+gâùºp1J©Ú3g]CrFxÎÅ\ÖÑ±[o]¤,SÊ·rLwÉZ£óF.fÿ.¾=¶Õ%`·N ²{)ßà	H+Ì¸ØkÊÿüÂSù#<ÿÙXOé8/yÀ8¦rÕºñ9_ÏIÊ¦ÈE<»ø#àSÍæívÇê,eytçZNÍÜ¨><Q|+¼X¹$ÅÔ2däèb=iåwMh¤N²{¯¦ã»¹ý­T }PÁö]Ko~Ø´KËË¤|£m 9/ÙÅk*·rhÏIÊ¦ÈE]ür»Åcu²yÏµ½2£ÝÅß
/V®a IñbèbÈÿ0ºØbÒ_@r¯óÕ´.i±èØß¨\|[º¸^z*)sR¦)Æ8sÝg¢§¦9³gîßL¥î2(}¥Ãvc?m¤IqLÙT~±ÂæZöè]I5ñvTëo1gm£lì+©½Zfgà´Ü"¼W[Ã´Ç«/ Z6)©HócÞ"Ê>6öÅ3àtÆ2)¯9)SÊc9ÈnÊ3ÑSÓÙ3÷o¦RwJÔ¬)CRSjÈJÊXaóC-{ô®¤CË7Æ³¹Éæ]ÌXà¯Ü"¼W[·.^¯R¾h9Ú ¦r1+¥Ìéâæ9ä+0ò?)Ýbd!åZ%ËÌ&füLÃ"?i²ÅzHRr4¼ÌïùjÉjHp_5÷jÄ®ßCÔ
h+IÙÝl9D×,À¤Ì,l@OJ¡f/.Äg÷Rþxq7ÙÊá®~TfwJ(biV¶w¶ðÏÙòs?)¹8I²rË ­efD3.¦a´HÙÒAIê¯t±¬d.æÜ+×oe3ÿy³xeá.NUð¡f¯®Ä®³Ì×½?^ÝN¶r¸­õ:çâ¯D)eôGô:üÚõÓêÔPJk§ùØ)å£©vµâü¶pIyø^>Ö²vòh¤üyðiº~cK$ 	8,ÀáeÀã	Iy%èYÊÑ"48¶ó)¿)´ò½eOðYßP½³ýìÏÊ¦äñÛÓ¤þ^_{q°~ZR=ºI©cbà4_;¥s4Õ®VÿÓñCÒ¤*ÈÅT5G#à¯ÈOÓõcMª3.VñXs¼Eh°¶ó)?/´]L[ uq¬º÷/¯O ¿tÀq¹J%rS W©%½ä^ê
l¥\3á=H´ü
)ÓùyG»³iV-çÆdHV[ýýÆÅe+ÉÍµ§ë7Æø±¡Z5b{Sn¡nç×©EP2ÄãÂ£c)óqÉE[G»+%S©¾´ZG_Ë¤Á)³?¢+è¥è¦ÀVÊ5CDÊÈÞò+¤lÌØÅ¦älU[tÏ!Re.¦ÑKÊõcæbd	µÎ¸X+
ÝÎ7¯#S d3µÇRw±kyQðjuòîÃõ»³õ«×¯b®¤Ng× Ã5Õ1pÊ/gà@ïgô~×¨NR¶Ié¦eÐzj<@9(³#´bóÆ#!V( ü\=LCz_RîtEÐì±¼L¸KYW.|¾J~VÜÞð=âºª¨Êå8EP &RÊu åJÊÃnz¼®©¡+\là@ïbô~×¨NR¶Ié¦e¸Xðæ1FB¬P@¸¸z õ¾¥<p±)iyÝºuåè²ØÅ*vâTÕÿÞ}ÀÚàÝ¹iYÌ+2¯ÎæTRæÍHATÇÐÏô_ÝÑvYÌ,Õ'Rú;_òbú^áB8r$±£×¶PÜÍÍ¿zD ègi¹}c)Õ·°¹àf÷Ó1dpR¦Éªé. äFÊpségu¸ÿGð«ÇÇö[~SHy¬åBÊúçtåb© ý/y1}ÓÂ:ÊÆºk[(îææù.ÞãÆ6WüÃìþaZÓ2NÊæ]Á#Y5ÝÐHy±×kû­>«Á?3d-3ÒrÙVZ`^¨®WÕ1áN½_uy]s0!áx5àú:®ÏJÄæUZq.tRfñK7O|Tö6)sT¿ÕGÓíÃ4JÌÙª¦ëãûnãÍõM³Þ¨]Ùéæ	ü½tt%åM<r+£?ÌÅ&º_¼p	}­ë³$±Y£J+®ÒNÊ¬0~Ñ@tqÿÎrTÝÅ£i8rrq5g«f®×W½¡7jµÌÅø)û¼QrZq}Rê+õ -¯$æ NÃÒùíø×xð¤­%2pßWÐ"òGûÞ£T}Hç
·}f	0ÀsÜÜÍÙß«¬àæ×÷)k2ß©ÃA¼Æ'jB®ü%#t¡9ãçeRöËò=ç+ð£ú.Æü¶¾Â5^!<ãÆ¤ ikÜßãwäbhùÓÅwÆ(Õp1TÚ>L³»9ñõÐÅ&e¾S'x3OÔs.Ö]<¯]\!ÏÀ¥\3»¥üÃ \kð}H>Os¤×¸òÚÄ
39cùè×ÍÇv?¦?~üë_ÿ*7ß ¤äû{kk h Ëk:Zò¦h÷QVÞG%íË³7EKY?Í÷HùÞys+)?¹Zä.æ·yóÑîâÑÃtvñðpAJî]ùR6§Eê2çbTÒ¾<[º¸ùsyI¹ÒJOUÊÑ*vauª]ê>2«!-Óp	üæí)5oÓ®eöÁÃ4íÝRîælÁü6ÂÑ(îøÂ[ð´qzoõÑ<a+¢±'à$å9-?Y)G{ØÅoîq1Åjè;³$-?u±k.<LgSÊÝ-Ìºx}ÕºØFÎ¾MUmeAoB`Þ|ýp{w¹ºÌª½½½Z]¹aBÙRO¬yïü¸´²ö+õÿ$ä]ËÐXêóo0]¦s¶àÐyrs3£óÓ%9¬tTEÐÀ.)Ïhù©JyÔJvaí.í"7¿¹ó<ÇBÎc .Æt9zN.ÎÙBh½sñºw1`UEÐÀ¼SHùNRvFR¾ý¤ü` ]W3àTÄ@!÷|·ÜLJ½>L!óÁ-Ð+pF]Lñ(eïÄ¸£YÐ@Éýg§ÇZþ©¤ü`ÈÅ3àTÄ@!÷|·ÜLJ=>L!óÁ-ÈWü6&âv»¦^ÎÊþ3+e}9äî_¼DOUum§ÿ°j0³_HÊy!Ôê=<ÜQFÓîÆã¬ ÀHÍØw±8ôî1¥R.áÔ@Ë¿¶s2ØáïùãáB40zN.F;xäbDjÆ¾Ýãb4¾PÊïÎO a k@ò«³5áYµ_{V^	Õ¯GP<à0ÀÉPZs¶JæÛbünõn?§¢j¸Â]õ$Zþ·òH¨~=âa0ëbDB­9Û@%SRünõGQ5\áÄ>)ìAÎ¤lh×ýÀ¿ã9ÛZÆÿÁ¸ÍÑÙÏé
2%¾@Ê-¤üHÏÙÐ2þæA.¦)ñ½RöùÂß¡}x(ù å/=ÔèÓ2àaÃÍö#Ý\ùùºs´OÕþ²R~,ìt±´üÅ.ö©Ú_f )p}}µÏøE0£z¤üøè»À´îVö}Máçº;è|Qéb'Z-¤ü]0tñíãºZf1ÓôÎ¾¶)-ój4ìï,|=ø§Éüsó×My¢Bz7ûùáZ>Hùü¸.>y÷îÝë×çç¯_×¯^½zñâììÅRþ.8-Å=ÌÏéj7j-¤ü0]qZ&ËÅ'çò§O¯ÏÝh})¿_¯ß¿8$[ÐWøzpmOÐN<"*-¤ü£À¶=A;ñÕ8?}ýIx½õ#óÎ^¼^Sà åïý1´ìÄcòMú=HùGA%-;ñÕ8ý´ÝRÉÛí©÷èývK%o·G)ÿ(¬ôí°7D¿ÏòA)ÿ0ÀÅ|sÙC&¸UÍ7R2ä{òÃc»ø:&^ºL¨câÅQ/Ü8àIBOÊ¯jY_ Ô²)pÀ¥üúx]JùÅðâ åøip	WJù$¯5R>à'	NÈñêRâõ åø9À÷Ð¤ÎRþ~Xñç­ÁíBÚ«sk×zßøu²(·ó0 
!±¾èÃò¯öZ§ÿ²"WÙè¿Öÿ·æe|e_½âÂþÏ(i]9,þ3¯nØ½2ÞÁkÎc¾1Vw¥pïXìmÉÜvøµzvç|+nFv#wÀíÌÒíÙxVÿëáç±Åy©ÿñ.WdÏÎýhççê]Ãêÿú¿_ì:3@bÊÈAðÚë*r¸9ÿe°OïHév9ÿôê½òÙÓª1¯âKûúÕë5HW+ÏÑÖ7í¥}ÍîSñèoÖâ*^Ë«3j{oîÒúÿK»wÎ¦BÁ6)¹:dRÚ/~öÇ(¡q:
Æ2²*¸9ù?þK%ìÞ$ÈÛ|TT	tô²ZÅ«¨i¢³øïÿ×øQ6MÂEÒBºüß<ì¼bjpKù[öYfìJÞÍVæ×b¼\]BÊí¯{~É¼Hÿï~½^øñT½ÓnWåÇpÁ°ßß²û¬|BWªïöÐDq¼B-z!$>oÒÆW²/S þ·Aú*-¢KèÐ½Ñ d[&êR=+ÿx!#üêk©SûÁep²]È´è8eG²|L§zzãzëñ¬È"ÿµ9»Ì»µçÛÙ²ìô¿] eI ýuó}óÿÍ/¥ov>r
Â/Â¹`|[nÿÆàðBÛEzc±.­ÿR{;;·æ°ÐõrtÊ¸¨±²Û)Z)3{0¥l²4i¶VÞþ±WÊÏ¨ä¤e;óØ Q	â	Ó­¤/Óä\üG[ï0ì<ñÊ_ËÈtjò-Ëÿ©å`¥d¤eºjHËÍ ¥8ýfû"} ¦"r<Yûß®]ü2æ3öÃÅkÔ«Mçáe(î7x»ßóÿ÷ÉËlðM¥FµüÅc[y§ÿ+D÷F¯7)+4§ 5mf¤)þöÛovYEvRfüo¥\¥Ò9Åzó'»G®YXØn±JCÿ=kÙEkñÏgiÏKY¶ËøMÑfknë~'Å"_ËIØRª&'tÐ£À<[f¥W~Ýá½âóÿveàµwÆÚ^£ü#ÿÏõ×ýéù~gê"ÌÿÇù]ûëÑßVk¾v5´Nçdéa"uwÍ\qb¶ÒYhå5¸Q§LgZÓ'¸d³%Ù¦áÁØ!åTÕm¥,JnÒ<ûJþ;&ãÐò?ÿNüöwÿsJ]À{ ev ¼Pµñê¿1y­»¬øM£1å+ÛI°õóy)«WèEaf4)ÞâÏ51éÛßH^©<çyÃºæ[+y®÷WEØkÎÃai_ÙYØÊ4Æ0{ß	^^x±»ô!©°sSÎÎ´Ý]ú`WSAáYVf¤Y'ra° );!ñ ²ùöêSXI0Wi Ô¿SË¡SJ?¨O2¥=2¤/ºò×øÅL2Ë8Ä«¨2"ÂB\òU×nc1iÝçq¿°iñ^Ò«Ã¢ô¿a]ë%¡÷0_-Â_r¸áùkÿ¥°³ÿß /K¾ÿÆá¢n&cIz1m Îx=ÒBñpñës¨³ÌS2Å(%ç¨MÈ/FËÖ&ýÈs§©einwÀ,¬`õ¬YØUµ&`VÇØ²Ë½ò<.e3&åÎÊ2µ¬Îì½»íìÒº`$W×²p
¥\ÁTFHWÊq·*QÕdC4~IDcFº9g|Æb?q©RÆUøzpñ¿fã/²¤H¦¬wGß<¡$(hÊMJvÉ$ûzÕºKÊ,´*V&ç©¸VÉ­idLT¨Ù¢,7(Ò Îg®dIXRÆü¡^2kwò[ÌsVæÅÎåý°¿{×ÙÑ®M¦)$dNìÈBZ:êlÀg)3µÓ,ÒÔ$øJÒ-µ<rSÓÐ%}ÌfïÆe6Ð¤çé"Mk.J§NµÀ6ÄAÊ|_ìr	é²õ°bµKÕöh¬¨,åHbR*ìrs4è	ê4Ébæ\JÀ÷æq	4©Üj}ýÌÂ]¦r¶pÆïAÊ|_,2ûu£ä
¦XL#ÌO$pæ®ýÊÌ@ÊE65	æY¦!L¬u¹L9V`,Äd4@ÜG+M¹þ>Xùae}øÞx]ZNB¯¯«lX)³X+ÏHåX
K:µRFþõÃ2³ ë¨òZ%ÓªIÄª6·L­òmWËUuG'¤|ÀwÅB)·ý|/#fâÐk¦]Z"hd(à4	d
ñQ yjÙCL©òêTsóKÏÿÝ=KËÜJåÛÖ®-î)9Þ7@æ¥¿^ÌDH¡FÐ~çKc °^×°Ç+ÿ//øXÜøÔ2çJ©&p-èêu!rÂqgóË0ð@ÚlK-ó%CIù!>H9*lUÏÄ;":_´¿Ûs¾MçDÊ/Å»½eà9ÕßËÛ~Ô¯ç¶)púç/¥û»B|{)Û®1_0dç4Ãñ¯®<Öãv^ÿÇ+~u9Û¾7Mÿ³¡äÁàÓ,¿N»]É±¼$U!1FvüþgCH)$ÄMâdYL®fWü:-é2_Æ_ð²³W+/§~mÿ³!¤öRÎ_$Îðe,àù/»ª<f©üÿg	Ê.8+ÚÉÊôh··ìwOã	È+ ºà-ËËÀÂ¡í:¤¹#^ãWÁÄR°¦=.¯¢E¼Â¸ßl`ÿðcphüø%pòü8Hù~	¤|À¿R>à_ ?þÿNvq1g,å    IEND®B`require('strong')

local function testContents(t, ...)
  local args = {...}
  
  for i = 1, #args do
    if t[i] ~= args[i] then
      return false
    end
  end
  
  return true
end
  
context('String operators', function()
  
  test('Add', function()
    assert_equal('Foo' + 'Bar', 'FooBar')
  end)
  
  context('Subtract', function()
    test('It should remove instances of one or more characters', function()
      assert_equal('Hello World ... Blah' - ' ', 'HelloWorld...Blah')
      assert_equal('Hello World' - 'lo', 'Hel World')
    end)
    
    test('It should accept patterns', function()
      assert_equal('123 Hello' - '[%d%s]', 'Hello')
    end)
  end)
  
  test('Multiply', function()
    assert_equal('a' * 8, 'aaaaaaaa')
  end)
  
  context('Divide', function()
    test('It should act like split', function()
      local str = 'a,b,c,deee'
      assert_true(testContents(str / ',', unpack(str:split(','))))
    end)
    
    test('It should default to plain text splitting', function()
      assert_true(testContents('a.b.c' / '.', 'a', 'b', 'c'))
    end)
  end)

  context('Modulo', function()
    test('without string identifier', function()
      assert_equal('a' % 'b', 'a')
    end)
    test('with one string identifier', function()
      assert_equal('a%sz' % 'b', 'abz')
    end)
    test('with two string identifiers', function()
      assert_equal( 'a%s %sz' % {'b', 'c'}, 'ab cz')
    end)
  end)
end)

context('Indexing', function()
  local str = 'Hello!'

  context('s[i] type indexing', function()
    test("It should be able to index positive and negative indicies", function()
      assert_equal(str[1], 'H')
      assert_equal(str[4], 'l')
      assert_equal(str[-1], '!')
    end)
    
    test("It should return nil for out of range indicies", function()
      assert_nil(str[0])
      assert_nil(str[10])
    end)
  end)
  
  context('s(i, j) type indexing', function()
    test('It should be able to index a single character', function()
      assert_equal(str(1), 'H')
      assert_equal(str(-1), '!')
    end)
    
    test('It should be able to index a range', function()
      assert_equal(str(1, 4), 'Hell')
      assert_equal(str(-3, -1), 'lo!')
    end)
    
    test('It should be able to index a sub-string', function()
      assert_equal(str('ll'), 'll')
      assert_nil(str('foo'))
    end)
    
    test("It should return nil for out of range indicies", function()
      assert_nil(str(0))
      assert_nil(str(10))
      assert_nil(str(10, -2))
    end)
  end)
end)

context('Methods', function()
  context('bytes', function()
    local str = "hello"
    
    test('When calling normally it should provide an iterator', function()
      local t = {}
      for b in str:bytes() do table.insert(t, b) end
      assert_true(testContents(t, 104, 101, 108, 108, 111))
    end)
    
    test('When not calling with first parameter as true, it should provide a table of all bytes', function()
      assert_true(testContents(str:bytes(true), 104, 101, 108, 108, 111))
    end)
  end)
  
  context("camelize", function()
    test("It should lower the first letter by default", function()
      assert_equal(("hello"):camelize(), "hello")
      assert_equal(("Hello"):camelize(), "hello")
    end)
    
    test("It should work with underscores, space characters, and dashes", function()
      assert_equal(("hello_world_foo"):camelize(), "helloWorldFoo")
      assert_equal(("hello world\tfoo"):camelize(), "helloWorldFoo")
      assert_equal(("hello-world-foo"):camelize(), "helloWorldFoo")
    end)
    
    test("It should accept an option to capitalize the first letter", function()
      assert_equal(("hello_world"):camelize(true), "HelloWorld")
    end)
  end)
  
  test('capitalize', function()
    for _, v in pairs{'hello', 'HeLlO', 'hELLO', 'HELLo'} do
      assert_equal(v:capitalize(), 'Hello')
    end
  end)
  
  context("center", function()
    test("It should default to using spaces as the padding character", function()
      assert_equal(("hello"):center(7), " hello ")
    end)
    
    test("It should evenly justify strings when possible", function()
      assert_equal(("hello"):center(11), "   hello   ")
    end)
    
    test("It should prefer left-flushing to right-flushing", function()
      assert_equal(("hello"):center(12), "   hello    ")
    end)
  end)
  
  test('chars', function()
    local t = {}
    for c in ("hello"):chars() do table.insert(t, c) end
    assert_true(testContents(t, 'h', 'e', 'l', 'l', 'o'))
  end)
  
  context('chomp', function()
    test('When calling without a separator it should remove newlines', function()
      assert_equal(("hello\n\n"):chomp(), 'hello')
      assert_equal(("hello\r\n\r"):chomp(), 'hello')
    end)
    
    test('When calling with a separator it should remove the whatever specified', function()
      assert_equal(("hello...."):chomp('%.'), 'hello')
    end)
    
    test("It shouldn't remove the separator anywhere else than the end", function()
      assert_equal(("\n\nhello\n"):chomp(), '\n\nhello')
      assert_equal(("..hello.."):chomp('%.'), '..hello')
    end)
    end)
  
  context('lines', function()
    test('When calling with a separator it should use it to split the string', function()
      local t = {}
      
      for line in ("foo|bar|ha"):lines('|') do
        table.insert(t, line)
      end
      
      assert_true(testContents(t, 'foo', 'bar', 'ha'))
    end)
    
    test('When calling without a separator it should go through each line', function()
      local t = {}
      
      for line in ("foo\nbar\r\nha"):lines() do
        table.insert(t, line)
      end
      
      assert_true(testContents(t, 'foo', 'bar', 'ha'))
    end)
  end)
  
  test('endsWith', function()
    assert_true(("foobar!"):endsWith("ar!"))
    assert_false(("foobar!"):endsWith("Please return false"))
  end)
  
  test('includes', function()
    assert_true(("foobar!"):includes("oba"))
    assert_false(("foobar!"):includes("nada"))
  end)
  
  context('insert', function()
    test('Greater than zero indicies', function()
      assert_equal(("world"):insert(1, "hello "), "hello world")
      assert_equal(("far!"):insert(2, "oob"), "foobar!")
    end)
    
    test('Zero indicies should just concatenate', function()
      assert_equal(("hello"):insert(0, " world"), "hello world")
    end)
    
    test('Negative indicies', function()
      assert_equal(("hello"):insert(-1, "ooo"), "helloooo")
      assert_equal(("hello"):insert(-3, "ll"), "hellllo")
    end)
  end)
  
  context("isLower", function()
    test("Should return true for lower case letters", function()
      assert_true(("a"):isLower())
    end)
    
    test("Should return false for numbers and anything else", function()
      assert_false(("1"):isLower())
      assert_false(("!"):isLower())
    end)
    
    test("Should return false for upper case letters", function()
      assert_false(("A"):isLower())
    end)
    
    test("Should handle multi-character strings", function()
      assert_true(("aaaabb"):isLower())
      assert_false(("AAbb"):isLower())
      assert_false(("!$@#$A"):isLower())
    end)
    
    test("Should return false for empty strings", function()
      assert_false((""):isUpper())
    end)
  end)
  
  context("isUpper", function()
    test("Should return false for lower case letters", function()
      assert_false(("a"):isUpper())
    end)
    
    test("Should return false for numbers and anything else", function()
      assert_false(("1"):isUpper())
      assert_false(("!"):isUpper())
    end)
    
    test("Should return true for upper case letters", function()
      assert_true(("A"):isUpper())
    end)
    
    test("Should handle multi-character strings", function()
      assert_true(("AAAAAB"):isUpper())
      assert_false(("AAbb"):isUpper())
      assert_false(("!$@#$A"):isUpper())
    end)
    
    test("Should return false for empty strings", function()
      assert_false((""):isUpper())
    end)
  end)
  
  context('ljust', function()
    local str = "hello"
    
    test('When the length provided is less than or equal to the length of the string, ' ..
         'it should return the string itself', function()
      assert_equal(str:ljust(#str - 1), str)
      assert_equal(str:ljust(#str), str)
    end)
    
    test('When the length provided is greater than the length of the string, it should pad it properly', function()
      local justified = str:ljust(#str + 10)
      assert_equal(justified, str .. (' ' * 10))
      assert_equal(#justified, #str + 10)
    end)
    
    test('It should pad with the string provided (if one is provided)', function()
      assert_equal(str:ljust(#str + 2, '!'), str .. '!!')
    end)
    
    test('It should be the correct length when the padding string is more than one character', function()
      local justified = str:ljust(#str + 10, '!!!')
      assert_equal(justified, str .. ('!' * 10))
      assert_equal(#justified, #str + 10)
    end)
  end)
  
  context('lstrip', function()
    test('It should strip spaces and tabs', function()
      assert_equal(('  \t hello'):lstrip(), 'hello')
    end)
    
    test('It should strip newlines', function()
      assert_equal(('\n\nhey'):lstrip(), 'hey')
      assert_equal(('\r\nhey'):lstrip(), 'hey')
    end)
    
    test('It should not strip to the right or the middle', function()
      assert_equal(('  hello world  '):lstrip(), 'hello world  ')
    end)
  end)
  
  context('next', function()
    test('When dealing with a single character, it should advance it', function()
      assert_equal(('a'):next(), 'b')
      assert_equal(('F'):next(), 'G')
    end)
    
    test('When dealing with multiple characters, it should advance them all', function()
      assert_equal(('aaa'):next(), 'bbb')
      assert_equal(('aBc'):next(), 'bCd')
    end)
  end)
  
  context('rjust', function()
    local str = "hello"
    
    test('When the length provided is less than or equal to the length of the string, ' ..
         'it should return the string itself', function()
      assert_equal(str:rjust(#str - 1), str)
      assert_equal(str:rjust(#str), str)
    end)
    
    test('When the length provided is greater than the length of the string, it should pad it properly', function()
      local justified = str:rjust(#str + 10)
      assert_equal(justified, (' ' * 10) .. str)
      assert_equal(#justified, #str + 10)
    end)
    
    test('It should pad with the string provided (if one is provided)', function()
      assert_equal(str:rjust(#str + 2, '!'), '!!' .. str)
    end)
    
    test('It should be the correct length when the padding string is more than one character', function()
      local justified = str:rjust(#str + 10, '!!!')
      assert_equal(justified, ('!' * 10) .. str)
      assert_equal(#justified, #str + 10)
    end)
  end)
  
  context('rstrip', function()
    test('It should strip spaces and tabs', function()
      assert_equal(('hello   \t  '):rstrip(), 'hello')
    end)
    
    test('It should strip newlines', function()
      assert_equal(('hey\n\n'):rstrip(), 'hey')
      assert_equal(('hey\r\n'):rstrip(), 'hey')
    end)
    
    test('It should not strip to the left or the middle', function()
      assert_equal(('  hello world  '):rstrip(), '  hello world')
    end)
  end)
  
  context('split', function()
    test('It should split a string up properly', function()
      assert_true(testContents(('hello!world!foo!bar'):split('!'), 'hello', 'world', 'foo', 'bar'))
    end)
    
    test('It should accept patterns by default', function()
      assert_true(testContents(('hello1world2foo'):split('%d'), 'hello', 'world', 'foo'))
    end)
    
    test('It should accept an option to turn off patterns', function()
      assert_true(testContents(('com.nowhere.nada'):split('.', true), 'com', 'nowhere', 'nada'))
    end)
  end)
  
  context('squeeze', function()
    test('When a string is not specified, remove all duplicates', function()
      assert_equal(('helloo'):squeeze(), 'helo')
      assert_equal(('boo!!!'):squeeze(), 'bo!')
    end)
    
    test('When a string is specified, remove duplicates of it', function()
      assert_equal(('helloo'):squeeze('o'), 'hello')
      assert_equal(('boo!!!'):squeeze('!'), 'boo!')
    end)
  end)
  
  test('startsWith', function()
    assert_true(('001 hello world'):startsWith('001 '))
    assert_false(('blah'):startsWith('foo'))
  end)
  
  test('strip', function()
    local str = ' \t\n  hello world  '
    assert_equal(str:strip(), str:lstrip():rstrip())
  end)
  
  test("swapcase", function()
    assert_equal(("HeLLoO"):swapcase(), "hEllOo")
    assert_equal(("goo"):swapcase(), "GOO")
    assert_equal(("GOO"):swapcase(), "goo")
  end)
  
  context("underscore", function()
    test("It should result in a lower-case string", function()
      assert_nil(("HelloWorld"):underscore():match('%u'))
    end)
    
    test("It should work with camel-case and space characters", function()
      assert_equal(("helloWorld"):underscore(), "hello_world")
      assert_equal(("HelloWorld"):underscore(), "hello_world")
      assert_equal(("hello world"):underscore(), "hello_world")
    end)
  end)
end)
PNG

   IHDR    b    S%  KiCCPICC Profile  xÕXgTÍ¶­3ä0äsÎ9çÀÁ!'É
H


(9@DED1¼Fß½÷­÷þ½?¯Öêê=§jN×Ì>Õ§Î¹NBÐ ik¤ËíìâÊHÀ°@à>Qá:ÖÖæàmßè`ðÄ¯ÿuÚÿ<@ëëå d{ûFùÀø&×|Â#£@ÔÂøq\t8ð"áÂøÔøË°÷|ý÷{[=xÎ  dDbd  øÇ°;Ö' ö_ Cê
 
Æ>D_ õá9â!!a8ÆÂÞÿæ'àß0èýO"1àüç·Àß¬N"ÆÿþðÙbàÿëw£{På7dðµâKÔ7ûÃI¿9ûm÷u°ûkõ¶´úý#mÿâðhÝÃÖöí	z±_Á?~¦Öí1¶qT¬Á_hïôûúéÿc÷24ùk6ùçYÃÌþY|¢ýðôÂÂã#£¹uà(óç6	õç9þÓö×Å~µý½o Âø¿lÑ	 ¨»Ãqo÷/' ·Z `ÄýËÆ§Çñ wûÄDÆþñ2 hÔ° NÀ@h`
¬=pÀ	â@82@ÈçA)¨5à2¸
ZÀ-ÐzÁx i0æÁø ÖÀw°A¢è!Ä YHÒ sÈr¼  ( ãPB¡+Ð¨êF¡	è9´ ½6 A`@p ReÂa8@D éD1¢ÑhGô" ¦óM$@â$R©ÔCZ!]þÈHd
2Y¬F6#;ÃÈ'ÈyäGä6
¢Gq£$Pj(cÊJAe£JQQí¨ÔÔjõMfG¡UÑ&hgt :.D×¡ÛÐèiôú;!`0Jc&ÉÆT`®az0EÌ&eÁa5°VX"6-Á6a»±Ø%ì2<,!+Y(YY!YÙ=²I²e²]rrrUr+r_òxò³äµääãäKä»8ZNgÆÃãq¸¸¯x<¯·Ááâñ×ñ#øü6(;EEE=EÅs¯Ú®Ñ9W(û)ç(PÑSIRPùR¥RQµSMR}¦&§ Ö¡ö N .¤n¥§þHCN#H£GC¤I¡)£é ¡Ù¤¥§¡µ¢¡Í¦m ¥]¡ÃÒ	ÒÐùÒ¥ÓÕÐõÓ-Ò#éùèõè}èÓ×ÒÒ/1`L²®21¬1Ò1Ê3:2a,c¼Ë8O@	&á,¡ð°ÃÄÁ¤ÃäÇt©iiYÙ9ùó4ó7Ëa<[,¯XQ¬¢¬6¬q¬¬¬ÙØÔØ|Ø2ÙZØ^°#ØEÙmÙÙkØ²orprqspôs|ä$pjsspÞã|ÏEÏ¥ÉÄUÀÕÍµÊÍÈ­ÃMâ.æà^ãaç1æá¹È3Æ³Ë+ÄëÀÆ{÷OÏ¯¯oß?¿ÿ ¹²@ @À°À  àIÁ[+BÌB&B	BB/)µ#«§D0"Ê"E*D"DDEËDÇÅbbAbbâhqñPñjñ	
	XFI¤¹dä-ÉÏRüR®RyRÃR¿¤¤IÒµÒ³2t2¦2i22²¢²>²e²Srrr©r·åÖåÅäýä+å)Ð+X(TèSØSTRTlV|¯Ä¯ä¥T®4£Ì l­­<¢VÑUIUéRÙVUTVmQý¢&¡vX­AmE]HÝO½V}QW¨qQc^[ÓKóæ¼Q«Zë6¶¯vö²N°NÎg]iÝHÝ6Ý-=U½d½}¤¾~¦þA©Á!¯aa£áQ¢Q1ÚØÌ8ÏxÆÃÄÇäÉ©i²éY©ÙsQóHóN©Å9¡·¬Õ9«WÖBÖÖwl06Ö6e6ïlellíèí<íì¾ÛëÚµuvqès¤vtw¼â¸å¤ïï4ï,åìüÀÕ%Èå¶+ÖÕÑµÎuÓÍÀí¼Û»{ûÓCBõ`õ yÜõ¤ö$z¶z¡½¼¼~­ÕÄMoïrï5="¾Ú¾¾ïý4üòýý5üóýW4Î¼Ô
,ü¤T´l\¼uØêpýá}éZYWHG(]èáÐ0Î°#aábááóªç#Ö"Í"ë¢ ¨CQ·£àÌÃá1±±e±?âãZÐ	=ò0^4þtüraÂ¥DT¢Ob_OÒ±¤dä)PwJ_*_jzêÒQ££á>ö(M:-?íÛq§ãééGÓOhÌ ÊÌ9©v²êêTÐ©±Ór§KNÿÊôÍ¼%Uõ3Û'ûþ3ÅgösüsÆÎ*­ÌÅäæ>ÍÓÊ»O¿xÎâ\{wAfÁ·óçGå«pE1EóÅæÅ·KøKrK~Né]+g/?]¾Uá[1Y©]Ù\ÅQUµs!èÂ³FÛ««k05±5ïjk/)_ºRÇZU·WZ?ÙöòÀ¥+WØÎ6"cß7¹7=¾ªõv³DóÅkkY×Áõë«7¼n<m1kékUnm¾)p³¼¾-³jo_»xkþ¶ËíÓ¾NµÎ¶;wê»xºÊî2Þ={w/ýÞ~wB÷fOxÏÇÞÞÅ>Ï¾Ù~çþ©±A³Á!Ã¡þaáî®QÕÑûÊ÷o=P|ÐþPáaÛ#GmccíãJã·«<îP¸7©5ÙûDÿÉÐÉÔiËé§OÍ¸ÏÌ?ó}¶òô|ýEìÝÙ£/Ñ/3_Ñ¼*c«~-òúÚ¼âüÝýoìÞÌ.ú,~xõöçRú;ÊwË\ËWVdWºÞ¾¼ê¶ºô!üÃîÇO´Ê?¾ùEûËÃ5çµ¥õÈõýì¯,_ë¿ÉëÛ´Þûò}w+óËËÛÊÛÃ;N;Ë»q?±?÷Dö:ýz¹²¿N$þ> ááïÀF= . ÐÃç_Õóïïðñ>´#`ìIBH^Ç¼ÇÎ½&_ÀmQ )©Ì¨£i.ÐÑí3È1êæXY­Ù2Ø;9¾pñpððfóÕów	>º/Ü-rU´P,EÜWÂLRZ õSú­Ì}ÙrEòÉ
DE}%Ae¬ò²Ê°j½Ú	uM.-HkUûÎîÞþA¿a¯Ñ=ãNvÓfMæuU¥VEÖE6%¶vì®;¶9u8w¹t»ö¹õ»òõð%®zïúRûñù+º'>Cª¹Ú6þ>Å­ãäjühÂbâ^2!E"Uû¨å1ç4ã^é^'¼2<Oz:tÚ-Ó%Ë1ÛîuÕYË\»<·üÀsG
2ÏW^+ê)(ySºQ¨ ­ä©»`xÑ½:º&§öò¥ÞºõWp<JMW}ã¯¹~áFKKoëÄÍù¶/í{·):X:î(téÞµºw¨ÔÜ×w¹¿gàÙàaÌÇ¨Ü}£+oxÜÇ]ß©Áé¡§C3CÏ¾xÙ÷ªw®çu÷|ïBÿáÅoÇ&Þ=YZz?µ:õaòãÄ§ñÏ#_:×.¬'n%|ýV¹éõÿûòVÃÒ¶ÔöÆÎÍÝØÊ?wöîüJÚ×ÜßÿþP«èiÌ]ìU²ä]¸Aü4Å*µ4;í	ºú%FzS"s3Ë"».Gg	W÷k>~NA!va¼ð7g¢båâInjRlR;Ò/d:eKåâåé?)+_TITuPWG«¿ÔhÕ<£¬m©£ª+®Ç¯ÏaÀhHe1úiüÕdÅtÎlÒ|Ð¢Ã²ÙªÆºÌ¦Ð¶Àî}¾CãY§çL×ãn©î	b<"<#¼bÉÞ§|
}kýZý{ÆgV¿@>)L \!Â$Ò#*&:'¦>ö^ÜÓ#P¬IÒÉú)N©G£%¤¥OIO:s2âTÈéÀL,lç3¶9gÍr-òìó½Î¤Ï+¬.j-î/yRºX¶QUÒTñ\»h\íYs¤6ÿRSÝPýëË?hEt®:7]K¿^r£©ånëØÍWmÚÞÆu0w
ÞïÒ¹k	GAhÏ±Þâ¾þñOCøaÑ£Q¿ûiªÞyôtìËcÔã$ß)iõ§z3&Ï,Û¿p=ôÒûUÀéuä|ÂBúÜÅ·Kï¬Ì¿ÿ´ºýýæ3óö5uüú·Ç_/KÞ´ý.ð}{ëáÊí½]ÂîÊÏ½¬_îûÿÿýÿ3í#»ó?_¢Ø¦â¦Ö¤!ÑVÐÐï2ÊÊ'XÑlªìaU¸6y8xµøùIñÇ
'DÝÅLÅ%ø$ñ[RóÒ÷eZaöÉ(+J+1(m*Ï¨ÜV-RUwÔ×dÐÜÔÕÕéÒ½©wM¿Éà²aQq©Ié³ódhK¯µ­«½«££³½«¥©»þ!m5Oe/¢·µ¯«X@B`ZPVð¹Ãe¤ê+¡7ÂîGLG.EmÅÇ²ÅÑ·L8|*¥ µâècUi¥ÇóÓOHÉ:pÊõ´e¦N\¶àæ\ÎþÙï¹yùßÏíGR1³ð
IËU¨TjVé_0¿èXí]^zél]E}ãåÎ+ÃÓo>_Ý¹¹N{­¯Uô¦LR»ú-ÛfVwìºïºÜóèöí!õé;Ù_2Ð4Ø349¼4òã>îûCGcã®ý&B&#ÄLÅNÇ>}ó<úEälÄËðWasa¯Ãç£ßXÌ{[¹Ôô®cy~,¬~ú°ó	óæóÇ:ÛÃW²¯ÛßV6§¿÷o]# k'n×÷§õú/á}úþÿè 9£@m<0û@¥0 pî õkJ ìU " ¤k Báü 4ð 1 ôða ®)«Asàx!5È
²ájpZF#ÄVDbñ®èlÈ»È(%TªM¶GW£70úbÌ¬1¶IæGv\¼Ã%â¾àýñ¯))SQvQÉR]¡æ¥® a£)£å¤­¡£k£×¥` 2¬3¦à¼¥Æ4É|ËRÇjÄºÊË®Â¾ÈË©Î¹ÂUÀ­Åý§×w¯ß[U`Z0_ÈF^xZ¤fn±EñzIyÉ=©Qé" Y9*¹%ùn
Å£JAÊÎ*ªÆjêFf6ZnÚ:±º§ôÊõ[.ý0Á²kXXYúZ%YÚ´ÚNÚ}s`vÔròwÎqiwsGðpòL÷j%.ù°øZûeú¢3O°»ÁIáM[7OhMâLÎJÙ9|ìÅqÓôÛ'ÏFfÆd}8ãó*×-oöÜ¡ÅBRÑNINhùxeÒ©Ë5/yÖs]~Óp¥)ªYë:õ7­ímÙ·Jw(»îõô\èK ¹ßW{(;&öXlRqÊñiÑsh6N}~}±á]À{kï®ý°e°#¼GûûýñÀ«*°Î`¼amá8( õ ·°f@ëú'CíÐShÁÐ@ø ²7óH*¤\Å7 Pü¨ T3êZ]~QÅäaV±0û²`²IròF;.OO£ G)!Ê£{TñTß¨#¨×i"i¶hSèÈè
àÚ´Áa1@Ghb2dZ`Naádéaõe£`kg÷æ åèçãàzÃ]ÄcÆ³ÏÛÊÄÏ×zB¡çÂU"¢2¢{b£âç%»0ó%2$Y9f¸úz¤Ð¨¥¦ì ¢£*£&¢.¨!¢)­¥¦m¢ã¢KÒ;®_npÛpÆhÛÍTÝÌÍ<Öâ¬e½Uõ-;½²»ãq§&çg®7EwÿCßüÞö>'}»ü¾H]~O
½plÆÄc{ðÄHøäÜ*}´:p<ë{òýi×ÌÑl¥3ugrOçý:[°3ÿ¡$¤ôkyr%UUÝEÃêÏµåuVÑWº®ª7ï_lÉ¹éÒ.tk³càNþ]Ïnñí¾¡ýûvÍß¨};}r&çyóìÇ9³ùîEÍ¥þÕÂ×È7ê6·¾ìîþÿÌ0ÿâ@ù7ÿDÒÀ9P:À#ðlC40¤¹CqPÔ«@ëz"Âh@L!!¤4ÒVpÆPä°VGÐ^è«è]æfkmÕ²	ròX%IÃmâIø·3TêT7©%©iDii¥hÛé´èÐ»Ò¯2$3Ò0^"¨&1Ìµ,ú,Ë¬gØØæÙs849Ö8k¸¸É¸;yH¼<¼3|¹üfpµ?*ï~áEk¢b&âñ·­Ç¥¤Ee ²mròÑ
NJÂÊ¼*V§N§Á¥)¥¥§íª­§wCÚ`×ßØÊ$ÞôÙ ù²%µMmÝ°ý¦£ «s®Ë¨Ê]ûPÇ-Ï¯D)oO£ï'ÙøÀþ`êÃ¤ë¡è0÷ðöH¨¸èW±q­ñ|	IÉ'RÁÑÔ4püÄ	|Fþ)ÓYÜÙs¸Ï^ÈãÍ¯/<»H¿øI©ÙnEAÌ©êZÉKïêk¯4J4m5\/h	¸©ÑÎxk­ãÑ»Ý½ý¸¹¡S÷½j±ÿxódtºu¦úyÑìùW_w-¼{ËþÎe¥luáØ#ë£ß8¿ÇýÚß+>à?Ê_Nö { Bçö÷¿
Í`/o·z¯.6^ÐCú£­LÆÐ P>skb×îÿÞþÝëB	Æ8ù=   	pHYs         IDATxì½¬&WyçYV2ùgm°ÇöÆÂ7Ö1x1i¡I{¯`±:ÁØCBº'Øò	XôÖ6Â=f5ãAc¶Ü$Ý!aöN«1,è:
ÛQÖ4ÐØ!¦ÉµåÈv:+Àõ~N}«÷¼§~¼õãÔ[o÷­ÒUÝ§Nó|ç9ÏùSUïûÖ³gÏ&Ó6E`ÀÀ«VÀÉ)S¦¸L|4åÁ)«ÿ¡Þë¯¿Þ¯pâÄ	ÿp8ymmÍW¾µµå-×ÿì¢ï8þÒÐp¦ÿàMÿÙß¢ÃåÚ<]&¨ù0zÞ÷¯z¬e¡n`Ü?ªÚvíÚº_%^a~2ö"Ã½2ÝbãèKýÛõ½ï}ÞþTRR5jrÿÙï%èöJ¢"yÊÈÚ¿wpf@nÒ ÿg .ÈtV2`¦T(TËÁ~~ì,)ÎÀ6Åu©_µ2u$ÏR^Õ$Jy.¢¿J;WEÙ3Wõ`2Ó
ËÃed.±ñ8JåÔ°<G³ÎöCûeÆÜÎý»Æ¶¨ó`§Sÿáª«þË°.(êq9;Ðµ>|;®ùA0ùôéÿó¶ÛÂeÃ-:§Ãáápv	ý×××ÇlÂ]<V×¼óáú%ÇÜ>ý[~ÿ¨4YARöln&L¡úÁí//Ä%SåþX+¥¡Ôq
EÑM-eèþÂµäép]\êøpqÞqÍ*ÑãÜ³»<_ÃCüd5vó õ¯)\hiVõ×?©95µÃõ/	CÚÔAýªR>J«é_.]~û÷oùúHËâ­7.N¥6.^Û¼°¼ª4[eÏ2Ëg¡5öp´»"qÞZÿåïra¢¿Ì8ãAk­£Ä+»àf÷Öªÿ¹[bß>Ý»ãµgïx-²;üö	äêv}ÏÂíÙÆ½ç½Î)nÂ¹Û~M÷©@µÂÉ~i0wSw,Úi]Î8ËS<ÊJýr²¹Ü/­Góy¥.?Î=q+¯×ø,LrêdHÅÇü/&	K§¨ÛòqA<pOæ7­YåÊEª9óbm» ²ÍGuN}zêü3©ùk?u2fd¸E¸yKâÆyü¼÷Î0h©ðE¸å×k¦»·IíÞZw>P>»^;´{V-º4{ú§_·ëÄ!pÎ{î9ü0ö1Tî&¤7íuAÞ¸xëxF:§8ef"ÌÇÁû7µ¶6\R¥«úÝÎ÷âüÕçâ<b^yqÞ¼óù«g·CÿV>ïwì~é,:ºÐ®üµé¾Ò¬b_i\@ñn¡é{¯ýQäk§÷ãªxÇÌ|/èÔì:<?Ûÿÿ(q¶Õ4ÞY.¹¨ÎgZä ¬â<b^)Cç¸å|Ts'ÕÆL6`¢~c,\èÆç=ëÏÁ»wÇ'#ágá)¤öÑoioÃþ]~û÷o9ÅÕ¦k!ÈH9.èU);ÉåQpÇó\Ê¦÷×¤ÑÉhÄ8WcÅ¹'n%ÍºÐ[Kgºvº228	ìý5¼{ÅWpý£ÒPÀÛêIÆîÂF_(X¥þÊwv¯õ:,t.XÙµù ý+wHÙàÍÜz O¢è²õ/u¢£[/3¯ôÁ@î{ÆyPaUÿ6éÜ|vTß;çÃlèï@6¸AîbóqU¢=6D4 P¤pç@<~Æéã¸_§`)Â¾w¾¬býSýeöã7¶¥FêsR.XUN¨µÐ³¥&gW[ßÍb_¹§,6ô¹BýÛ¨s+?²à#9¿¸oÒòÇ)ô§&ö¹zÍÏÚ§{$«¶&«Dj®¹¾&p¾/_Mà8i Y¯³ÉYS%=¸
5JUn¢¹a_'²U? µ5¯fÊ Ìh®§aMÓ/ýrâyARqhöSÍ´ÂÎ¢ê7÷GÁà×ï#ËhÖR\;U£¿òy¿&{òå7|ïó|ËTþÂj"¸HñYùk;v|î{çs@ßãîNl@þÂ¾«Î-÷ÝïW%!Uïò4~-9UõU[¯n_ÜëÓÏ:HoôU¶ }01Ò³8ýØ¾4Dçú³7úKÍh4.ð¯îô2ãUy¥òòJtCqÄb!#$ï}m]º3B°nE`ØÒ¡û^²ª®K¹*cÍtº¦BD)ñ§ÓR%
E¨üà TêØ9$³S©Rdw6Þ&w4	4RRl:@gûKèÚÏNåÕây\Þ§Ò¯	-®³f9j¥_%òÑÎ"Kü³ä0K³9ëVCé_i^ÅuPSÀ%l2ÀdêÏ&(§sÝjªSÎÚ.-­±HâX
vçdìMëIÅ.Ó_¼øPEü³dp-i2ô<8äTfXÕÕMðBYQ%ajUÎø1Dvéþ zvÑZe­Áftpda0KóòóÊ§"ãJR"pò=íqk[¡4¾R2*Zh@÷³¹ëîé¦7w!-[±CÖíÏèëy-ç¾ú¥×ÑE/Áï}m°ÆóíQÝ{üåÂÐ6]²ébM÷ä7¹­NÁ¿eE[zSßçÎFÁW¢SÜÏ~å¤û,¾nêÏ·è{$.Øµ«x¿ÕA/÷óÚÏERY­³ÇÜ%çUqh¸/½Ì(v§¾ïLw§lÑÎ% þÌIH]^3B×ma±0Äzïþ¥Äy?{79ÏÿùêËÙ}m¡äÎ¤67pÃ!âlNÐLnÚT>¨¿(ÏÑv×ËtÖ@%íÙO§Aqýâäù¡Ii7ÐÜn£nòOQ®?}a+ïg;*ßÅ&-Ü6nú8(÷N[%¥ oûÒË6SíÀ¼mÓQÿH×Dþ°¿Î*nÉpò¤ÿÜ ªæTÞ!é8Ê>OÇÀ¡O-Ô¶2:xÓÇ|Gª-:k-	Á5ÐæJÊùO4]âéP¢ÝOÖë.¯ygÑC	×qì¡*>åq?Å«8ú¦
]ûø8ÃUç	Îäáp}hzn×ò@àä)ÔwÖbK¡ÉÃA[ÿ¦¹<\^éãÀi¼¼-¶Ãí¡S®þ´B­S5·äÏ­ûwîÈ¯Ó[¶/ÔèµúÍøp6t£VÕ\I¬6ÿÊ?æ*= U-_Z¾^,wÜ8Òü-3¯ªGq'uG|¼ëK/7¶o òãgïgiVE%÷³©JÒ)¸»ËéÌÏ$ÝÃ¥èþÅ}ÎÝûHW BKÍ¸ÐÂõÙÝ÷øÑå±pq¤z­rò¡¡K<®#7|Ü0B«$ßAî{ØZÜA$hEÐ:Ðø¥¤
KÖGR¡68væÊ+)?§:Ñ÷DGlèîÓ(GF¡ó.ÿ¹/ NÅí9ßþ±pÍeµéÇ7l8ÙRS2`Ð ³`^
=JÿÚí¡­³Ùg\å8{×tÍ1\J×+)üHÃÊ,)
¯*ùVúíÓ>»ÓêsÊ¯iå=tV©Õ)pvI_']àåýK\TÓ_*UÅ©psÐ[w¦Áu+å±003uv8ãÑóaBxÓn]0"v¨T	ÚÔÒ­~úNM«æ%×kvZº¬¥¯:VnõÏi¡Ô»ÒÂ¸nBÆÅE[âëºs ÊÁÒB?ýåRÒÂþX+¢¡Ê;×§V­{S¦l\¯mÏ'7§LXµL|´j=2Ù3E`ûF`â£íÛ÷çSV-­ZLöLØ¾øhûöýäùUÀÄG«Ö#=S¶o&>Ú¾}?y>E`Õ"0ñÑªõÈdÏí¶oßOOXµT~vÕìûq»à«ËqQZi[AZÙ?UîÅ|¤Ä5¤è¿m'ai¡fäùò]àáËÑMZZ£[~Î)ìêúÏåGó
÷KðJò3ÃÿýÖòðXc!äÍâ<Ðë[ð.ýíä¹×
©d,ÇÍ$P4/¢aYï5IuºPça²BªðNÛòm7mA×G³W!Þq:ù<ë#ho	«¤²o	f9Ð#OD§w$Wå5'CûþÔÙ·üY*,¡[Ø.Ó °x©IöþEäAÞ*88âa<¿$¿ÅPòGSý7ì£BpÔ|@q¶bÖë¯û~¿ï´lnþ;zTxõªû-B£MqºÙÝÚ:{ÅWÀô"o^Kv5äEò3d-ÆSÂ>.\ULæ±fÝ¬jÞ¶8ÂsÏ=Wl¾QZ®7ÉÒìÔYAÖ×'ð±ºJÝjXihJªB?ÿ(©ÊSB=(%¡w®åëÏ$§?ÌâWkKå "7þÈWwd··¢WOFB©*Q,YoUvç© éÊ"ï5è¯×L	 mnÚQ|¹qïµN-?(§ßÖ³_#¾Z£ÅG]pfo	HÑMRçÒ¤ÑÆ¯gÝÊ¼j	RîÍ@*ýshG»ßx¸xDxWAgÀ6$D_~ú.Ðþ©ò«ªjø¶µ½ðÃZ1áÐÁUÍ;»HÝsLÄîÀ¥	2Ú|{4`:C¬TCùÅ Uv)¡£Âè¡6 ÐäÓp62V`@Ò³mA$jedÄ¡AÁ÷¬-ÄJÕWÍ$ùåÔ¥î÷Âmp1Ð¬N,Á5:.Lp¿T+êÖG³§NnÚål\êµÍI¦%¬SÚ½vÓ^YbÐ[[ÿBÖ±'¦¾Z]û%Ñe¼cÝ'ï´÷l8E.Uvn6ßÄu_ùÚgþ,5¸I!a4R}/àÏÍR½®®uZt"fâ£Ûg	Mí]ÍoÚ.vÍ@é¨ã#µuC%ýUy×g T~Õ/?qµ»Ô¿åÒåÊ©ñæ5*]XZ8ß.Î,oddBÕ-¶LÈb»qqr(}ÅÆÅQ¨>T-9®Ýï°Õâ@À
¯ðLmiZhçÚ]éà¥³ÁMù¼"G?¾|V]èµF ³såRåõ[Î-¢/ºS¹âN¥¤#·ü!L!ú@L°Ô×5ù3%#õ$ÊJØì°NEs¤K1Ç2!ÙPUÌí=t75 Ûc0UG$	SÜóùZþË7À¬*7ºk©¿8ÐÆ,à]u/nGò¤ItBUó\út®E~±¢Æ54@D»4ÂmÞLìZÜWæl\ì¡~;u²þ:±2µ,´xKÌ¡Ý®Szy5 ×%ÂE:´7Qhr½ãÍÏ¦}åø-?¥(*g¯|ÊÓHãïNu:±Æä®cíËç ÈóM1_çákòµû®þÎ\Úäó6Úöj6±ä±tÂlmíS­S6¬¿6TÍ÷pXåÃ­¡ÎFÕrZÈÐ!·
ÞílX´¾AíõZ®¼tO¸6÷r?lëø1wC'E¹C­·YÚ¨ÄPqµYÊ:c¼{wzö-yøÿÓ	üwfäRR|T£sÛd×¦·ç*0ÿ»¤ª¨Óª!MS³ùÆqJ,ZÛ§ý( ­ôÎB¯Ç,_1¯;*§<¸à<H^y¯D^ ³Íi(uNmZw©{Õ§>LÎh¨º~d¨wÏy#:¾³^rY.±É"ÕôÉ¸{J~ ®÷§PtäÔ¬­E<ÞZemù[ÝfízHÆDèHÉÈ(½É1eõÐABµÌ_Á¸©Á;ý÷«fýòy»ó±ùó7Ô|SÈWLHÞ"_»GÛ9ën¹¡RÁÝW´$a.ØµË'#**ÔhK+t´.vCcÃMrè\/ó§Ñ¤}Þï­U/j`ëñ»¦O&5sCåç!íò$&&eSkú¡5-GÙÙú¼[5ØÉk­ãw²£è°Òdíy¢GÊÎ/eµ´¾äg¢óïiÆ¤l¦ÆÎ0Ý÷íèbI3yT<¡ï,±æãP¬ßªÄ@@IüàlÃü.§ëÙ<¶èqSQf?ú>Òëæ7ãF_á{çmOÑ/*ðÉÁÅ{LQ³(ç#TÛ3æ/ìûpÐOnå+[_öáûËæÞCìáÆd3Ay^¢äúï:D"yÂIlÆ#6Hè r·Ã :«ÓÉS|4¨¼Ó´5©¼ýAT¸Åv«é`íÊ+~:QìEåÛpa£(}ðÁoç¿O¾,íÜrßýkFqÉõÈ(ûÚ¡Sðaia_±Sq9 ÔùpâDü¯Î¥Ãrþâtý;PqSt*è_{æwÅu2ÕÆ$^cÏT/¦å	1Ð³ªý$>Aæ&#â|úÎû¯ø®{¢$Oßy;÷8²ËðõÌüµíçÙ\k@!2R7ò/-?ýz
µ_EþZú½R3L!dd+PaÅu)j} º¿ª\fÓ B dR÷Eñü7fÿù¡ ~Á~Á~¿_LÕ¶òYãRQ­_=ÞOÄÀ;{öJo;{sP¿$üïQå{'|ûÄìï´$ÇàltÑ_¸#tô³É_8¢þúQhÊÂîR!ÆPH¸òEj|Ç\´ÎY¿ZpG9cwº,ºãµ^Ò]ÙÎ× D+)úU,±Ê}Sky%m[ÏZ¿¬ Jpª}ÌYKÓË/½ÌÙ·åOI·¶^UëTIuÚcjÒêË±$w£áäIM,DãßÿiLö`¤ëâô]4·¨vì>ÝÿÁ7~ Oß^zuÇ4ln"EÐ>5É]ºÆÚÌeÈ«WÒÀ8{·íØIüá{®Sä¼P¨ÿì·?Î¡}wWÁ×)¿rÇIÛnËn8TÊ¥¼|Iò2tÑï Í[Xá ¡ÓMß#¯R®P`µìµÁËª4£¥à×`#_ôå§,x¿Ø½´yÿB#ZT¹³ºéeÍ©Õ
ÈÙf9í#B>Ê!ôóçRy±¤g @Á#T®!Q%qª(ÔÐ%GpUèÀUFvöWwì5 thiÝYYZàÔ¹=ÑÇ 89'ÜidÂaÐÐËïg½X2¸ùÓ£2.¿ñÞ×R`·<â^ôzP³§xÁýlÍ¨qo*.ì®:v7á«_zÙ-òí¨÷³µ^øÚoøÞçAøþ?À^òÐüêÜ¿k'ÒEÊõ»vK	NÉBþ[Q%t®¡ÁÚ!ne¶¬éÚ6ò»Îõ«õ÷W6=øõîtìPÂðQ4|p õÈÐ÷³²'$>oûÒË{,ìÜ¦|Äªa¹42
¨¡·lf,ôJÛîæÖÖ|pýÁ>nÍÀeÐm/z		è2-½\|ð½¯µ¸ã§|NNô¬u¿¾%ò?ê8éÓôð ¹mÇB6JòÉåBiî·bÁá
%©PÎ"³¤"ºHI.=Ýz1¡J$%Að¶2¢| vGsÀG©;.Ú
¨2ÇýçGD_á¾âÈÚÙÌ7R\Í:T>>Ñi¼0<ÂGFØMÚnÊÂâÈì .úBqb87!¼nÿþ bÄ\ndº#·hï;.?¬CÄÑ }rÕÙ.ùJVY¶£Û²ÁéñÎ²Á¨ý½²O0¨Æ'\61¸)ç__y%rôì*ÁÍ£(lmth¹¶ä½?rm=1Üµï%6Läêkä&#÷U¾¢¢ÌH@þà9}&P0ÅÊ.$é_µÙ¹Tyü?ÓåHÚ¸&ê±ìµmÉqöá0c0	Ã°gÍÍLÈ£?<}þ/yébðAÆ@4ÔÆµüy¿ßÄ&gíLªcè\ÍiÙ3´KÖÏôW¶ ã, qçmî\ð£ÀnEíúÓmÆ; èÚ%)6µUÆpÃÒ*Ñvxan
WÚªáÝÑ VHß&Ü_ÎðK í²ºùHU]§¾÷µ_ûÒËJVÿÂÍtÅ¨'q5¯ 6ÜäÓ(FI
²ì´2Ã.óâÆäAñBrík¹§ |Tè;;.@>_s,È¹I/ÄØý9Ü®Z8­_UTWSÂÊ þÒçPk55{J}¸jõnÚ(1ù¼R7·FÜTy¤T\-^	úN*t¹f&Åõ´Lp	µ âáKS%J3rÅ.ÜÏöÝ#8Ô¢!õmË¯QV©Â¡Ù½t B¹x¤«T-âeÀÅ¶Þ \ÎÑËÕÖ[Õ¹?bwÄ*Âëëz1~sKöãX>¶àD­°Zð0|'[!F` qR¯³L¤qyÐñB©ûõV6iR8Ú&ÐÛ­B-¯;ðCk>ÚnñÝ¶þ1Ð¹m;è¼t|â£ó²['§¦xÕ9iõdô)çc&>:{uòiÀ¹ÎÍ~¬"p>F`â£ó±W'¦øèÜì·Éê)çc&>:{uòiÀ¹ÎÍ~¬"p>F`â£ó±W'¦øèÜì·Éê)çc&>:{uòiÀ¹Å¿ÔórMÂâCP¿Ã×ð ël7\?cùîÛ y,Ëó×w°É¸®ã#érZNoþóÇ¯úÍoñ6;ÞdOQ8;[L±6%èÙºdÝµø\|Ðý¥ÙéªÞ¶®±|÷m@Î:ºÐûM7PÕùp,ÎKÜÌ©x7:]yúÞzÕ/íL®:dgk:«òzÆ¼ß]êÐ¡W¯§³ìkô¶:uìÌÇÑäôGøõ­ô´­¼Ýpýøå»ÙàR(íh,¡ß]ùãUKÜÆ²á<ÆõÉºpdôß@8¥Ôëòï÷ëUÑ¼l·´±ÈÅ´7%êÿÉÛÉÉÝ\´vf³?Dizo7\?cùØ }>ü¥Jò@ýî¹Ãó×yÒBiq·fó~J­lüî¼øz­Øvi¥Ó*KÐ3o×*)zjn7\¿#Æò=°ADPÊDªÙ3µ|¸RÙéOÉhÉ6ß¸Ê®¾ãK¤ÒQaåúH÷jZvæY_¡Ó¢TùvÃõ0ïfX·Za©·Ó}±l8¿qñÎ8ÁvQæ¾RÕú¨òþ´ à¶õ¹¿t£\ðE¤V%èGÙ%Í[ë»Zéi[y»áúñËwß_¦¯­Ó%è¬ÙéWHËóW¬¤îË{v=ê;±6.fqäèø;ÞÙ8ÆO@ýzª³X¬OQöBQ+£ÝÇï\Ô`§ôÁ]¨¼¦ÂX¸¾IãÚ@oÒ§ºJ²õ{|ÀBßàèòX6[5"Æµ¾iÏÎØJXÜµ×ÆÅÖÊÊøHçá êÑV]¥ÑÞæ~àÐÆ¿ñÁM6öú%&û[a¡'nÒ:cáúÆiÃÆ^×þ6ß×!°Ð¯YËq+ÇÂÀ¸~ïä¬P;ÔK%­Ý´÷ôO=iªÒC¾Ù¾AåS'òCGÝyê$JÖ6ÝÞm¦ÿ²;èmOýÊn°J5BÜÖÝOë[<¢Ö§êe,¡ßé}r í}ßÌ¡ä±lQàbXØf£c\*0Z@0ºPB)ß*Ëîgo\¼¶y!íÕõµ¡ÛQßÎ§@­º/eMê7W_z£Õaòt/ÓuâM{-Ä;^wäÊ?ÎnWhÇG';pbCÜäP~Åj&¦BD)h;£ã>­ÞÐù>ïw£|©ë:.ïh÷¤ù48pü¥`3³IHó¡;>,Èf0ßAÔX Î >óë[gÿ!£üµ(ôD?ûàt=D,Utq%KÙ{U1Y,>*v9ægb
mm=³¶v¥_Gã3[N¾    IDAT¶-;4Ç¸h~qáúµýÂ°9îÑÝ¿s.w³@ùBb¬|}ìTAÿj¹¸.Ôc¥RºÙæ·ºË[Á){K¡ÛúnQõuj¼ÀGËÍ*¿NÞ7h^ä£ ðÑÁ»wWÍ7å×kÔ¦¦¯@ciaP§áa©óè7ÊÈ$ÄÙ_º2jTk+,×&ÚØ=ú£kkv gqSåWâ¬þdC8Ãõ¦6´g[¥FÖ³~wû­Jíô+4;¤9cñtY2Ñ68¸43'JL%w/"ºï.,öx
´]XáoM/Ø(öëPXCFÔ,_I«$ú
ë¿û.Ö(r½àòÁÀtí¦CëºÖÛ.ü>o^ë@µ¥L¨G7Ò¥bAÒkUú@*QzÅ¥õ¾ÇB1×ã6¸F³:Ä¡jò´:%MQkQ äèÏnß¤WÑPHsñ9tÔ]lÕbÅÜÖGhvÂ¾ú;pðEwTß¹uÏþ³¾ÛCb%ÓûÏ.r±ÈHöÑ¤D;\8cJÕ£)+(ë³¹5`þ§7gÀ(pfj®å±U¶7«»/ûÈUè&ÔØÂX(U¶¡SÄüS?AÐ³ó´>_«tËS/ÜÁ4[+Ú?[y.mmÅ¬Èw.Es´q4®b]%A" ;=ËÙv\&T®¤÷k;vÐêßû<ûï¿ñìßuö¬ô¨ä>{7Wç7/¯9uû@vúo÷ýµü"ß ·É}fòz\¨:°×FK -Òìèáp¡ÔT9ýy3ý<uíc~\lÞ¼D@Õsm¡ùîP:pÂõýõi¡=ü
~CÉå|$Çø¦	ô®$¹~×.j8yòk9Õ)®SUâÕq%gnÌ÷-5yúÍ£&¸Q|ËàR­jq
VêiXCz¢Û¡RâûÒ*<xÉÃ-´æPêc¡m(5Ã«8û6,ºÑÃw á£=XÙ¬¯ÿ§ª²«äzOT[êhÉ1´Sx?Uô½Ïÿ¿ß­St6îÞ~z¢Êô¸p¦Íp­d9áâoýpÎ³a8ÓQ.A¡k¸eÃpQ³4SZ¸}çw³vI»s=Þø­ôËH&èñòçkT¢»4Ë¯Î²fgÏRÈoÕ|ðø_we «Ã!#¡5DæzCG¯\°×ÎF¶®º±|7èS-{ÕËôxÁrÉFÆ²á¼Ç (¢=ÄU]Y²>ªªm~èôÉ_&gÜïGF²íÅå2¤jnó÷Î}«RË¹üêÄËWp%9nâ9F>-õ'#Pj.ÖÌAm0¢p~ãB,^7,©»ô{Ï<£WQ×N~Ì/X:+5+¹üêWì~Í;÷\§ê­ß"n£ü¹c?xþ»õ·äÁj­8nÍ ê©ïw§Oô"$2ç£{Ô³¼rDÝrëæ$|ýèý{¼Iè°²¡nYÁvÀÒû,7 ÿõîºªj5S¹>22BmFO\¦¹9_Rjºa5qÓã, M¦ýYíÆÒ(¾CIIr§ÍCmQqaô`C©¹ç1.´ð{Ï{@ (É«5+×Gâ#ã3µðI
¥U$7SßL²IcÏ£ë´02ê?UÖã¯2.ýñAUX,¯w³ôlï,Òëµhýk¤sûL¿*%½qS¦þËáª(!U²Á\.
ç7.AXÂ"àSJØV§r}Dã6k,0k]0&®¹^á
âZÌ}ËKý
ä±|7S£P¥ªr,nyW/¯¸¢É¢ÉÀ(¥*,ë#¿ßÒ«³~¹_¿Ì¤QlÕª,êJ¶®ï~©ïw¼éÓºÌ¾D"s¤¸ð|àéøÆH^Bû ¥Xç1n?øåtAuT®ìVEp.;fX[Hè¹#ý2iÎf;Ù¹rwl[áãÕ¾»þ-vºß¶§¬^ø|= R¾¶Æ¥bò5×ÈcÙp¾âT6)TsÊú¨äóG(-ýn®µ1jT¶ÃnÛ\Çzö¾¢?þÙþòvÃõ#ÖÄ÷ôùûÆß°³ìóoKIÐ¿±:ç%®ëâô­F¾7J®×	áOYõgR¬PThu|\+%l7\?n5¾ûÕ$Géå#)ÔXÅë"¢JÎKÜ¢S~ëÏZ JøÈÎMÂ)SëµeÂOXS¦L°L|d¡)SFÀÄG#wÀ?E`E`â#Å$L"0r&>¹&ø)S,Y(&aÀ#0ñÑÈ0ÁO"`øÈB1	S¦Fî	~ÀÀÄGI"0E`äL|4rLðS¦XÂß	¾öæ#ÎÚDFÅí;¢ËMrf¬î1,c¹<
nÐ9>¢Þ`|W¹AYiP¹¶|gGÄô-K³ôm±~îx²g,èmÛÜÙðzÍ½ëñCtÕé=ÌåOêjò©ç©Q@±y»áèrM]J3º¬s5?äºføm,èmÛÊÙÙïÐ¬ ¼!BÞ#ºvfsÉjP<Ún¸#º\L*¿DÉ*öÑK"ý³ÈCd ÆÞV¸mÍøfAøzówtJ¿¶î.ûYT-YKÈêAIcAo+ÜÎ6â#2C%ò&br`®å\©0(@ÛwDK»UôõoM5NEL¹q¡ÇryÜn Ùý#ër·­ïÒú\és57,ú¨]Øv»á±\^ØVÁO9¥NåV3º0ô¶ÂmèlÆGô1¯ @lÉÆ·O7ñÑîãwHVyý( X¾ÝpGt¹*OÈ%2JWjW~îÑXÐÛ
·³3>:xÓÅî9fÏÆ¿äà&{ýò( Ø¼ÝpGt¹<C6öº\ò·ùLãÙH7ùUâÈcAo+Ü®ÎÎø(ëìS'ÝKKuSÖ©®mº½ÛMÿ°?¶î.fMQYÑd¹G¦¹WÚ(NáXÐÛ
·½³³çýnÉpéÖÙL_¼%J/TZ»i¯KtÑwWÂZµ&´Õ\_ÿÀµKfó¥ÏõK+#BWªÊÚd¥×hA8þ¹ßVºÜÔá]×¸ÏÍûwñó5_/ÞòV?óW¦%_(ê[o:%@·j*·µ¡FU70¬ÏasÜ,êüZÆÝü!@+KÆ×Bjëk¥MæcÙ<¸ÖÙå± ûíP½`VùS»ÕÐÊåÎEªÂõmÎ ,cÝSìZöïl}TôJ¬¦4Rì¥DqSú"ÓhTÍzHi¨ñËFi#g;|¿r\ZÍH?õÔb®ø·JV³aùÐ ú	C[Ã§ùêUÏÊÓöÁ:;;t`p¨^ë²âÑýüÐ Ý9.®¹æH(iÝ
4ã#ó¦}î®v=ºvSVÔ\Çi¯LéFIs Þ¥¢ÔA)Ï|Ã*âî3;qGp	ããvÒPµoîoÆG<åLoÞmétWÐéÐÙ¼ðy°'´o¼}æ)
þ5<¥÷;_©-¶aS-Øw¶Á4Ì«ÂíBP²ÀæãëA{=w®ÙÁ mïMè@ü0W¦`ïÞ]
êøÈåh~ncF>èk´ä+#®}úÕ6î5rG	it¤=%	Ôö¦
Á@UÈ§ÂU+åï<8Ñ,}gõSR«Î6K¡9´yJ¨*××â²ÎºP÷ã#ôT¹ìÈ(ÏR¹'´KÓÔÔR=³üFª¾%¤r=4®&ÊÍTõíãÖÔÒ)ºË@ãBî3ù¢Î¥(#®Mo7ïÜ }Q#ËjZkh(t³õQý37_þÃË¿èN#°ìjæù«æ&fË¯>Xúx"8°µUÛÍW.Ø{ÿ+MÉS×>¦ògnFàË1:ÌúXSºk.ÙÍÑ;ø+J÷ÍqæM\¡
ê'^ò°Î^sê_ðs¼r¤!PQíBhÆg6¿¦ý<wÉÿÝAg!JKÀuÙ§«ãÉZ­P6Ë¨õ½¶1¯2¿jpÌñÇ)%ñ?òE/ÐéEÆÏ~oD'È·^sÿCqìLrß­ï¸"Iö=ôI®r¡«ô- L®?:]7íÜÿHÁE6¸æËQ4û§DÚîñ&Üú	$55DØ.ÏÜì~ÕàÌ&~)¶$äWRmqU¿¡¿ÝWµjèr·,.Ôã²%ýå%°NwóÁ¿¾ïÖ;e°:¥¨¿¦¤ZYä3àýÉÉöÉkHdzçÝ5ÚkO¹)±O³E)D.¹±:ËåÑ_8¿D2àÝI/2®IÜìÎÆ ò;ß±ï¡ÜXË¯ÌTmî~ö­_xhýN °l=)iÑéránÃGJ¸Ü÷µ"¨  Új=U{Eaÿé'~~ýwEFAP¨ 5Ë_s!X·ræcù+h|lâr[§{²Ôr4®wÎÜÌ"ÿ½÷ªëÔYôW5Ñ(²Ô¢F¯óÈ¯Þ÷.N¶Ué´r]'6^ Z¾ËÃù+Íæ»/à©¸Âg*Afàù6û=6®\èþ$e"'°¥ò7S¯}âc?wàø#ÍÖái£;:Û]¦@I?ìÝn_ ´Ùi²üÞã/í¼õßÜsÝ«÷=\ÕHJdR¶ä¦~Ç*~ùþbFC}Ç÷n/ùöxJFÑm +-»2á¦ýG¾üépáÖ¬`Z(mP¢DªÑ6Ëú[ã±}àê÷í~Í;÷82¹5­ùèáãÔÂç³ËH²â°Ïé°´úrÇ>%UWäÔÓAµ"Å!2ÙÃâÜÒÆ¡þ¬å&7Æò»ÜÜ5!A&°Að1ÍêºI=±Ú6''ÉLß°æüÜ°ÌQ"­¬Ëü­Y±jÈj5»^Ã¦+r2+ÕøÜ±hÆ¨1ðû#ÐãJÉûn>¸ïaÒnÏ£ëþYDZDOÊ¢³ZcÃW¯ù{sÖ·ª<®¿X¾|K&QíÝO}\Y§X+ò8z/H¹QÈ>(Þ¸	)3ç³]/âòþ6!sV³KÒþ]¯Á5´Oö­Ñ[13è*¿ª-MýÂzÙiH¯èþnL"¤¯Y¨ÖzÝ\\vVIYålYÖe+å/Ö/Áåú)åJS¶¾yç³®#òìrÓÏÑ']df¦IW-ö6ËúDÉçsae¶)S3>R=¿¥§µ÷ÖAð¥_¡Àé
ªÒe` ×A¿5q¦z®Â%^¾P3Ñ´&C>úóå+ârF7ÿåÑ°.ðsË#v½B¡1£_q³ èÜ¨øÿï2È_1QÐ;.ÓÊ6EØz¶*às|$>ûzÞ-
,°@è¥eeeÔÇt\2B¥¦~¬Sê÷½pù<®/b][§jË_LËåhÈª;®ý¤ ø³J"G¾xþÑîs7%#vD`UUÖ¶ mÛCÝåXþVõHPnK$ÅÊh3JçûÙý#®Oá*,miõ;tÚBIþ" #p6úe¼@
ï k@¿Ny±sDk¢Uþ¼m5Õê
£ópWè×*ÉÏpî¶³Áè2#»	£¸<¢¿¥æRÂG5©>,ÍJ°ØöºN)e#Ú µ²å¾æ%8¾|-Èc¹,Üâ¾&Ú:e¤@ÛÒ)êlRb¸Ò_ª¹¦@TÕ1hU(æÞ.èòýµ8EÇ­hÉ×Oüo»ùQ/á{@)MÎèÒiÍ¥Ü9¾¹Î]LåõþâÑjºU¶PeÁ²¶½S«ÔZë¯þÂ@AnbØ(.è¯bâ{M	ßØw?©Vö¡>*µ´e±Ú¹UtÍÉeÅ BUØÞÔ%+\VÀKXÈGKî	nÀ)W4	S¦L7ÿ	}ÀY&>Åb¦L7ÿ	}ÀY&>Åb¦L7ÿ	}ÀY&>Åb¦L7ÿ	}ÀY&>Åb¦L7ÿ	}ÀYæ~ÿâª/×ÌZLÒ)SÚG 	·Ìñô~¨äsIòA(¥ß|koO]&¶Öµïzn[áålóÎÅÂQ@ÉöÁ§En)Ë#Þ{µ{ë¡äôÆé=þ{¯
Ô[6O²5þô=yKæÁm;³{_0¡C'ÞòAAÅÙ±p-ñà·ìÿîUÉNÞt}lM/@Â¨¹mvÿH1â4üÍú½ÿü%:;×4ê(z7<(Ä%âÁ¶ÂËÙBvÑÝüa!	àê²¤ÄÛ( 8´­på,]É|«À-"+Ag¿7BàÈK&y+ïb²*Ök--ç+îXAö³¨JÆ61¦AÍ²nù ø5³cá³¥Ýj½ì÷o#>¢¥*zýÆ¦±³P:NLÛp<¸­pÇrÖú±Fè²5ÚÛ¶.ÎiÔ÷O)Ùõ!¸m}þÛÈë5túcWø6D©Úm;³D^)«|iGQ8
èXÎôO)âU@ökÎîqB?fìÿÆ£ QY»ûøÑéÉ¬¾Ñ¾Ñåm;³m{Íï}å4ým6©?
(÷¸8cÀrV}áslSìÙ¹êÞs,ìÂ=~ÉÁM6öú%ýelZ>bö¶Âíé,i¤­Uwç*×¶ÝR¶ÅÊ£º|ë4>ö·-wc¯ã
gÎÀ6p_yÆGÙS'y¿Hrè(n$§NR¸¶éön;t4ýy7n+ÜæÎ¼£Ã­­g\>´ßhEÛRLlÝR¶½^Q@Áßn¸
yÎÀ-dÜÃ¤ÜâuL&ÎóíõÇûË_|wPË5NÙýKoL¹ÃøÛÒy0sa[á6pÖQOÎ ð#r¨0¹µH=R"Vr:SLCûm]UuPÙ>¸8®ÈyCd3H&ßK¯¹tL7\ñÏW×AvSwjºÚb±{÷YJî%M9ºxl :ÛÓ
7 ísØw¶,¥Sçïùu@oºãuG®ücÇs9aR+KDgªùä[[»ò_ß:ûÙµ¿Ó÷8ïA>øï.3¬ñ6QCÖå7:Âõ}tÖYãnæÇ²Çv~&üï'Õì}G%þ¤)"R'¨ñ[Z;AMM©'³¡ÒuHsÜ¸.·Á£³;[Ò4Ey&\A%<ßhIFg×©dûCGåCÌ§åØ\µü §ï³´qõÒ`	[=÷_½0³(7Í³UXê©°³CyÎOï`ÎåtÀêË«fuÆGÌViî®v:­iÍ¢
L_qßÝZ-*}zRr,¿«E ;sYB·ó04ûMüSÖJ¾3:ÛÓ[i j9#ÒÈGZzM¸6KYËB¯-tVÙb;¨õBt\çf:
éW¨sþåTtÜ¢*Á±g^¥SZê¿Û_ÿ:>rùã/©±¤C>ÑÀG¥]Ç¹ý©EsåéÖjÌMñ`w#ÇöÔ·÷¬më÷+C«%a èþ¥PfRz,Ù^&OåLNG.«ò$Qå&{ÕAÙi^³-f)ë)eìh
DF>øñ6'¦¶Ðg|.32ÂUÖÈÕ Î_p«lsóúµéMÔáóeª©gÿf§u®KË<µfë#Ü37_þÃË¿èT °ì4R>ÒÌ­íóy¯ÕRÅ·ÙA$¢YÃæÕoËGÝpWÜ7çßn¸æ¯Ø1()rö	àòQJbeL1õ%xí,Ï¯fd7eøåËQld4½ã$7¶òÿ@ã³/?Qä#q1Ø_×§ùÀw ©ì¦LÃ¥0¥$þûd"9xÉÃçädDµÙý#òæS7Üwë;ö=ô@`­]óö¢,Ã0B3j:Ò¤ùø¤²¨Û7æAZnCãöç_Ìîà¯(gïºX#w_¹`ïý¯ü5ªºö1È#¤_NÌïXyLÄ©>d$¼ËJÇéÕß#£ìReáÃüÜ¯iÕ§j®½Ø!]qâ+/ÅÑÇg)_(Oýö r Ù½rFãZö°J2J¡D<C³ÎpìÖÍ/<´~µØK¶¥
iÐÁÔ±yOvtH nÎôcdéÖ
Qø=­pýnêkIIÒü«×|B¿RS3JJW1êJê=È3£ ÄJ4T0222c8=Jßw?õqwèÍM@Éäª¸Q6smÇÉB\ñBôñ¹·¦â0¿àÎ\N0&2èn=(÷Eldò.¿úàóß=°ÿô4»÷ªëØKö¯}â¹c? °þ¶£Z ZîQØÛ&e,\Ó#OûóoC³ 8Õ*ÔnøÞüùõßeµ«u®¯
L	ºp£\¸Ñ.ÄÈ×â$)¾)¾¹ùQRQöû×ËD¸&t"mÇI=¢Îjhâ[2n½mDo8\¹,ÌSà(!E¡+v¿æ{hóYtÿÃßcóÏ¬àÛ¡S­FiCà
ÂY®Èd®äo¦~åØÏ8~ÀoEn+OµÂmklèærÜ»ÿÑ+OUÞ/ìà>IyïñvÞúoî¹îÕû²+£¢nõÔæÔÅ,²û?·®<%#+"Üý^ºìé÷åãD?æ'òÑövÀ"zxdR\=n½©|8\¹,DCÈAÑ>%Õ[;ÇG;÷F-ýQiû ²´NÿBûkó50>ÿâ1èyÏ£îæE°ù¸ò´8rºE 9n`H¢cOsÈH<Ô¹bxµÈi&Eþ%ßà*\`NçíÁ62PÖ>ðôGXWi(£Ð xÖ/©'nÒþâ/ù!ò[ÕËGi¥¶ã³n½U:[åo¶5uç!J|bmjg×k+ºX+¶ï_h°¨3A\µ¤{@I­F]%4Ç}áf7ù4PÕÐ"×[åA1È¯Þ÷.ÙÉM%áú·**aÈºUðû¾fMè¶ÕðAãO(¿ìáìÉ:öÁÔ}ôÆÍ;ÞôiÊÅ&­L«úg©0
n)¨¬íäz7ý³Ö¿A©C¨ãkþûkI¢Ñhú>ÌdA·MÇæ)áH>âø(%<ß4×Ù¤f\ÈTQßÿ³òÃ¿qÉÈHEKdRO¿¬¹4Å\§-=,\ÒÌ< #SE FÁÅx²yÅ£VJü8Ó°Ê¹ë5ìÏ¾Ìî	r8R@¿Â $«³UÓÊíVIS-@Ño®S¤QÜI&¸GRJ¢fÞ"]ï%Ú¾×ô;á»¿YKaaYåO§m»@ìS7[r>ðô~(Ô|îtï\È×ãsºÆõÁM¬èµ%n­Î0Æü­ã#|7TD<¤«îà£¥O%_=ú	ìÖjÁÈ¨m:v°Í°:´íÓ¤7Q*-¬±A#áÀ}/\~c¢F ¾LsÖkkÝ?ïSc@Í)u=Ì2I£%0ïùG_8¸¯Åý²ªø¨Dßúøû5ãÊKÆu^§¸YGm*Úî2ùM<¹°ë[QÊÜý#]lP¢íT,>µe_fÑÍKÎ´ùª<ëfå%³ÝÙE *ÍqÝ_>®59ãQ1Âd°fmùªá#~5e°õBézÇ¯ß\6D5!þÂ0¿»ïÎGL¹±pñÂ å¬s,_vXùªû-jª&{³AkÆT¸>¢¥OMÀzÖI¿
ç>°@j¦ØÈÀÅæÊ}2âP©Ét<DÆÂÕö#C[u«Ef7TÒ¼õß
/QÉîrjÁ9®"ÙðôÎ÷]ßÊ    IDAT°gMFã2ú×G¥^iË NçÃ Q#Ö¸ âÜØÖB6¨ï¥&EÇ-F\
·6×æEª²JU¶v;pßÍ¼K/µ9
¨4ÝÚ<rYq¶¥Ðp.`©Bi|TÔµ³+MºÔèåt¡(ªO?ÈãÆ¹ÊÀàó¬;ïgYJ,ß¤"âªðQÑ²©dÀíWm7'§LXÙL|´²]36E`ÛE`â£m×åÃSV6­l×LMØvøhÛuùäðÀÄG+Û5aS¶]&>Úv]>9<E`e#0ñÑÊvÍdØm¶]OOXÙL|´²]36E`ÛE`â£m×åÃSV6%¿7âÛº´ïÚù_öÃó×r©lákÙÁ¢Öo^8ÐOü47 ªævsÙüU@ÎûoâïÑ@ïçK>$tQ¡#µÝp«¤Ês{AXr*Z/d½yÉÍ6ÓþøUÝ¹þ­÷wf¬þÐãWýÒNr/ay0oø¹±4çúºüÏlH_Ìëµ%4Ì-ñÕÁã#lå%|»·JNoß¹÷jNø¶x»áVe1¡ìåª¶;Y'>={Á4»1Õ·®º*9¼uë³4WùÒ°|Î°ßü­N(a¦Ù·$J0}me×)Ñ§oÙÿÝ«Éã­éEpmµ¨NàÎ~osÎifx¤ïwwï¾m7Ü "Y}ÒWÈvL3ýh
%06úh´µ=Î0Ó\jÒX.cUöB`ßÂnýëk(ÏÜl}¹¥nd!;óvè\*ûÉÒ·nÃ°T­HF Q8»6xÚ5láíÎ)2t4ÊlÖ©²xEp=_#|Ì'dm}T9Ù³|»áöW}ó1Psª^g³5è5§¢@/S	c¤uÙ[láà¶õ]úPÕ2J9(Òcp&DÑ_¥d,Ü*{Vnáµ.^t=ÐÊVovç³¤Ê2³³æúgÂJáÎÖGB¿øíA{l)ÝXÌLµûøën{¶'.vj[2n[¸õyOâÌZ¬lóªª+Ôlìå¬Ë¿ãî½)þµ.¦0ëÖ´Zèç3lÀ`vAfiÅgãH}áöéûu:_JM·Ë/ì;ã#ºwøLâzÛÁMbgms\ÞÌÑáÖÖ3Ö»vªÐ·¶u|cDIÿ§<>¢r¸½®×Øæ»rNCzjÎC	3lÀ`.4?4g­I¡;Z÷l®ügFkÖûyåbtÆ5%BWÜðyrê¤EuüÔIÖ6ÝÞm¦ÿÙ5À%è`ÛTÑÐF¿+Ê¸Ã8\Ðê×Ø§P©{/¸þÑ³é>Õ«C·PZîë·§1là`.4=Ì­bLmÁGä£±F¿¤c­©b½=[ë®t6:ÒÁht[´Ä/i;{ÞïfKo4mÐª{'Vø¤²ÝH:¯ù­j*tXjJACÜ¯;ÂË×EI3ä|qß­â&±ýµ1ëd9ö4yýakoìuñá%|)ïÌº2lt*;W>V¹9¶2Ì"¶PhÌJ"*TªÊ/,ä2íè×ó®ígñuh>þeÔÚÚÏüúÖÙpWëlqq¥Ó©-<ÏFb'3>**5<ófb_{0B©33×QU£ÞÛÑþZ<m½IÞà©sÏ·Ý%sÕjÖàÅâmóUrä»HóÝÿè%ú3ÒÏ£Ý!ÂY¥ùº}\.eõ¯b¡°¬¶@ÐvfÍ@Ó±`Jpè¨ABt³ë5BP¢ZiØXød¯ïrÆµ\¤4Äe¬º¡¢á¡I *sÐø !.ú"ú«ÎE,wG½û×_Jî¾xëx	%õ!#¼Å ¤Í"£Îª+¶Ëu³½/jÐà*Î=mGâ<··âì¤ÆÎ¸Cø­HVsÔd®ÝTÈ
Ó]ÇÁ>érIä8e­:ë-\Uë¯ËòÅQKÖ¸½ýµÎó#.;@n¶q)ëÜ¹ôF£-Õ±»ÖGU´Ù8þ²Ó%'ÿ}SÕã­:w¡Ëoz­K7ÿ²E%æ2}¼.¦.}þíÏ5Î¢HÚÅ¸úW>Ú¾³ô¯FK$8ÈK§áp»øë­!Xéï~çºõþX²ª*|úäî5É[\äÚ?~ÝS'uéëJzl!nú¨WëC»jKëÝã/µ²¢.@­PVBÕÝÚL·­­£ü:ùÊ{¿è/ÿáeH¿èfwo{xEÉÂÍE ²÷~[ÅÐUN©0º³Âò]ÆmdX^Æ7DÓ¯]þôeÉkÌµMî]1QyQþòÌÙô¢á wn°;vêÇNýAO-,ÔÆÖempoºxH)%E<ÃÌùËMçkwànî¥I½¿³õ^¹@¹`G{É;%#'¤|ä²­ÕªÐ7Å¥÷>àøf½XfKeYÜ*]ýe>©Ò3v¾ó pßC¡/ÙBI­¼§h3¿zÍ'ÐFÉ}·¾ãÝO}<ë÷t´SGóAnUýzÍ5ïhy!2â3¸iöKxüëO~C%¨¦Ã.×8;§!¥$43ÊØÛ@C8xÉÃ~_SSh}§ëAGOþÍØ¸uþ¦|Ú7»¤@\sê·^sÿCqìKÖ+$MÜteä%´y|Wk´èT[\ô!7ÏÑÀ¶¸ýý­×`CH9ÂÚwî¹ÎlþúÑ'9|ïß*´Ðü±>E[÷|4Ù6­·3¬]{\¯
Öõ1UI9}KÜh±Â:5Î2tË·Îe»ÿ¿fíL^Ã»?ùáÎw¾cßC7¸
mR¥½kTÂAqòwö¼ëoÝüÂCë·à	{Éºdãåe¬ÎCmq5oc ;÷"4ÄåãVÉä"ógIS£7ºïâïyÔ}°JÒ¢^¨I¢r¥¸írß×:¯Þ÷.|´
Ëô×Çk«¼­æS×>¶LÉa4Ñþ@ÓèkÕ¹AWÚ!½lCfi¸f 6tÀñÑåW|þ»övSñ½W¹ÉY²0Ïûtq_Ð@ÐcáÖ®Øý2÷+w²U{~·ª£
>è r×°Ù9 ¥öøY9Ù¢´áX¸S^èov½Ff<ÿÅc´×l8ÆHJ|È(Å¶^9eöhnü(¸m67;¨	=
«&þglKÃ%fÑÌÀ&,Öx:A.5©±ÎX¸tAéKN>ÿÅ_yü%ªã#ìæCr÷î;Þ<p£»@ðg*õ(£ &âáÎýÅ>®ô[>Ñï~êGÆÂ­]qäKê5%ÅðªSöo©=V8¨aÅÐKÌ!2_½&#£`pú=B6F4`,ÜÀòþ5¯Í_îEÜñ¦O¼ûÓ\Óñu¶>B'DI(YY¬­Å_¡0-Ã_OÜL¹âC#ks6¼)?ñ,Ü¶O:Î±hXÊhVA¶S'úu,\</H²A^Ëeuà #g|¤Óºal!ókëTÜôÅJ*Ä	ð«öØÑ±pÍ@ð)R§ÔÚ÷ÉWÓì¯Lî£9p¡íápf¤ùKÉr\Ö"ÅÕ6ÊTÁ~Í>òX¸f³ðÀÓVæs¹HFÎñknµ¼`ðÿêÝæ 21,Ü0b,Ü&¾èùÅ¡IuÚ¨é³ÿÂCWÚ0²èè±Í¸ÁlwÙqÌÝ¤ó°QÆÂÌ0Oòâaö|>Ó9 þí%Ï°ZÄ;8ETbÄÄáó¾ppßÃº<pßÍkëÃ0®ß¿¼Ö§Ù·³<aÃinâ&ÃjksÝÏÞËotÔÖ¿CsMáÿ±pÍ[©¤øÀÛØ¶>òóìy¿(É?çkGÖW:ÃG`àN68Ã2Í`éºuXÚ;Ö¶^Ns=îÂ³Ã6æNYl@¦ãL°S
gÂ pr@ÝÊ&ÿIÒ¼-5lv½VÚF0:¶_Æâ(ðÍ3!¨0Ð¡Á0©U/Úa ÐÁTèfkþ\I Sê¬¹TaóÂáC³QyÑ>Á,j«)±þ2¡¦rÄSgBDåUJüð»iÕ_ä(=5[-Ä*ºÐPúÕÈ¥JJhX§ÔÒÂ¶ ¥JJÛjêí¤yÀvxU»êSí)S¦í¤xÀø¨eÀ¦êS¦ÙóµÁ z)¶¥wã{©OØ8·FÐêòâh¿+fï×Þ4¹8E W²!ÿ@û91Vôù±ýÖº:ecÿÃ_áìÕ_Sã)çmÜÒÃò÷«ö»Ú«éù*Þ?*!£<xî-óÒÉÏLÿ§LÈ"0#£BHæWy­"bÌÓ|y©tÀ?çÚ¨Y¹ûG5#ÅYK¤ánoÎÃÁùÉ3ÉçeQnéJ­"Z"­fJ¯UÄpÅÊð¾È¼è-ÿVä2ì0ÎdißQöÝ2ÊÉç$±D"?J(&´ÎùüODN4."ï´ÿ»l©^§(Ù¢gT=èÈi ¿ZÏ×Òîy¦Îìô)â>h·è)Xá@`úM0PõònêD1c	æN`fÄò«
 ÕÞÄûÀk,Üª8´-?'×Gm¬¯ïºwpºéÍ?éoKÍ,±ÁJýD©ûV×é¸0ÌÏü2KbAÂ*ÁäÌ
õ$þVi® `Ép]<åCh>ù(J/¦Jf9º0ÄÑ/1 Ð­­ÙHÜÞ¶¡kCßeF·h/ÂÂU*äá-éâáÂë¼®¾R+ÚälQÿ9Tr®òãÍçP KMm:\ÓäN+w\¤=È×t\©S68Kí¤°Ãièwa~4¦çªÁñB	§ò½xMáBîï&ô>w>ÔËÍòÆÏ×üö
½»<þ©VrSt¦7 zâ:¸KÖù9g·¿Ä½"àEÈÆå^Ì¡¼N±´¶@}P ódg8;EFµ·oÌd®vf¸¦¢6ªÝ0ÏQáä#VF£/H;¶Î½N[MË­4ô¤¤äñCÀþÐãìö¼K;Vö+ÝðB%%¥#ªºsPtP1ÁaÌÀ¥,µ­âcgèVÔ@èI
²5À°Ê*>î|Ã¤r·iKêt` ¿CºaÜ(IÇû·¾¹~ï_;³IÛÝ\ 2JòáýÃAµ@û<##Õ:`%Øæ,\ßÙÜs÷·?p§ìPÖêL$eÕKÊz²¡4ZTK Î¢s[/ýEÏ5E73ÈÝTè \«E
õýqâ[Ë°çOðÌ¯o%euÄ óÐÍÑÙ³L'¸ S	Kd×`&Vy1«áI%èG¼êsbR |:ð³%§ÏyÞ«÷³Çê¹òMpR·@,L>öÇkþØ=ÿæ$6±UB.mð=*"£+ÿx°¤Êöud³IíU»Üz÷^;[¹ßMï6kuNñQ>8y)xòºÚ°÷sDÊ5¨ü$ëùôÇé\Ëo!+&:´ªÍ±ÆµpË«²çÕ`¬Á!rgJª×SÄz`gÿP;µ
é<+ÕuLi¼BM»¹¸>ÝXq»éèHÃ.±}µµÏ)>ò<Ò¸{EC$Ö­_ÿfçîjÂ}nÆDZ,¨¤jØc X:ëÆªSÒôÙ?5ù¼eö©¿üX{¥ócÉ_º%Rò¾/U~aY¯@î<tÄUÈíY4«8ô/Öü ÍªçD¯³¶R£BÖ=> HNêØïÜs×Öo©êÓI$Ð:\IÝjÎU>Zå½_È{÷ ésIòA§{í»TÉX©l%ÂÈÑMµtÓ9¿ÝXõ^ýèx-¥¹ÝÇïØ}èÕ_|TH<Òý6ÿùÀ¥7²lùØMM`§¬jµ_4ÓlJÌ0-xõ\O=²¶6Øãðeâ ÂjÝÏNW¼³Ã¿9;\~bMSÐÜÙö>a¦Cr×Z£öhÞ5òýÚ k\éÒYÍ¯S/»%Æ=ÇÂ:´b?ô÷'ÁH03oÞ*
±\_¦	í¯>^1*g?Vg±>dà[dyBæÌõWî å"4_óúXÌè`d9\P'V ¶ÿá¹º>êï9ÒÉäîË¯¾ç_?`
/¿úàó×Ï]
Qmÿ¥Z	Ìü$÷ë»hbU2¢»Î*i½?uÅ·0æSîêo6NòûÆD)nº¸A&c&åú²GlðËñ¤Ö»«â3~°Ó]µuÖ¦vÍXXâKlnM@QÙ{ä^VF³jâ©©­öß¹ñc/£6öÀaÊ}÷îs}iSVå¯jU{mq ó4ÿÜ±D´äW¾ö·çÑõÙô2c<ÿÝÍ×ª<22
jè9wé£wO0K"¦@ÉCGéRhí¦½ÔwÞ»J*% jû6D¯ìÁ¶lÑäÙÜ
§¢`Q	é+ª?d É
KNËÀx²³|C :}ÍLI:væFSí·=ÖGnmguÆ<pÊÓ/OèÜ±3?üØú-Ü¼üÄ^T[¡ÆÇöè(·XH?ÂC¾2x<x:¹ãMÙSE>êân²4»¥^¸Q¾]QR
V\H­ÝúÔµÍV.y4È¼ éZi=4®9uÃKnÆë#éÈÕLYEr¿ÉæúÁ}î§?¢»ÄP%2ý°8úCÅ´ÈºÖØÒ,3lmóVjè¨5ÝäM«]oE×Gà%·ÞÉS-þKûG.wóorY/0aRH®X	Ð\8ÿXÕEB@5#Üÿ0ÑedFÅ7ÀÒÍÜ"Lw>ÀU#Zd9)C­\tV{GÍúÔLiÎWàd)E'üÉ 0ÉZ6uú=2"bÄèÙ¥1'¶¦9ië«
23ü&»ðZËak¥T¬ZA[µ&B®@k1h¾âÜ´rë£4u²ké3}ê¡\,M:faVCUuîå¯/?ñsþI5j.ÖÔg@fü6Ï¶5t¹d×,Ôç²Ï×ñI«Ü÷5þñùëÉû÷­F*}Ë{~UW}ãÛ]P¶.¹BE^ÉYÏc²²`X¨	àà»m\ ¥×§ßöß¾ðå¿+®ÔêÍÀMi²a©îPÒ«÷½xêPH/Tm9æh¨ß|«ÈnA'/Pj ¯jÏWÕ_QË1©ÊyyuïU­¥Ýé¢GýÉsí«Ù]
k0ÿ¨°í^Côu+çÍ­ÜF¾ý)öL/Qpe§[=zçìÁ»wCnæ·~áQÚUÝ¨JüT±wGû62däß®zàaw¨ÅZ«Åí´å
2záf»9ÀÂEI&gX³<j&%_v¢¹?+o 
ø!#Sû.¶wï¶¶&
zÄ×ÐM%1§Æ'¡ÄeT¾04Ê=7mmí¶Ò¥ÅADòð §[þô0ªiÓÕú½ZYí2#¿|0?4¥ì^µ(_åâ«ÓApX\Þ8ýççÞ«¥ä`üøIÌX¢k5½ôéKÆ	×¦hnJ?ÈS¤CGµDbxèn®¡Ë$~õO m}@ÃË;ýow½°ï¡¿@þææGÙsaÀÂþè°n¸ÀM\ìà8§:ÓÐjY¶<´~§ z-d~~ýw9¼ïÖwüß¼ìµg{M(IËw?õñb$Aa¡dwOK
=â8+¨ßv'*g !SE?Âïbt¾eÿw¯ú¥ÉU²<l3__¡¦ÌÍX×oÛü	rpaH	kçÞ´rë#bj½Ut7«,¸áæÕ~úÏz1ñZàä.zÁÌØGïéP%Íêç?õåeÿÔØÑÁìÓç)MÌ>[ 
î¾´Uá8:D>² ñ!hod&}ÂJúZjÐUN¹u|ãC>Råò«Ý(È%¡ÌR×ûQêg¡3vx"Á£Rè$»IçL(XÚ(«u?0¬"£ËU=ú¡§é`d%wç(h6/Õ¸K¢¿ôFö+ôÎÆn*mZ¢ñø½¿%å÷^uÀZIdÁ¡7|3Ì¶æú5%"Æ¢èYdb« ëJÍî%es×;Öª³PÚY¥Ù%lb1RÚñ%J*=;náÊ­JÃÁÅmg¡$?Ï¬¼¹`ó¶ßÄMP§N²V÷cÉi¶ñàGïþt0ûr¢ín?ýäÒünk.`]%Yó#('¿ù>TÿI³ñ=+±áÞëz^¬É#@u_ùä#,oUq=¨Óm¦ßPÉ¯Ý}´ù®a!Óßw¯/8L¯ýBäþpÁZÌ¥Ð©ª&ø }Ï>"RºóWï<êân%®<¿}àË},®8j~¶§]z(
Ã&IÞá_ E!#Ù¯Û+0ÂÎ$¼8òû8[ßÝß+ùf`[,OEIXâ=I@üê5Î.Y¬Ä¡-Ü9oëÏ(ÓÄ9Ké3>÷áôÃ_duFå¤gÂ¶Ï>îá¨#ÿ]¬ÕÓ
(¢$¥%SÿìPÏ`
f2ò>âÓ÷&º3kÊ¨þ3iÚ=Só>XØßqi8pßÍüð£>£(¸¢y*µ
fæÎ|üÓn6J»ÀØAÔËeô²¤däc¸un=dJÕaÜ=#è\Y"­Öó5-ìÏDºhSVÚy	«³Áâ
Â¥£rBdÿ6Ò%zjZÉ~;DëÍôtÜñé#±8kOÓÔp¿a7ÙJn*Iç2VUGtó±¦@.ÙðæsÌÒdsÓ@ãO±A¡83¬¦Xa&«0º°|DPü rïøîìÐgGò©>ÌFH¾le82êcsô¶ÆJÃqAÍã¢×6Ä©JJÊIªÁ dcäczZR:¨Îp£+ÇGÄ(£Íu>ÄO»¶ÄíùÙS ,¿dè5ÉÛ-EJ²ÄbÁ]ùõ>(ûÿG>ëä®S&"óc!ýÕâ#ü)ä¦£GðÅ@+:ÒeýeÚ&aE`è4å±ØwùÉÐMXA2Â¶»­0¬­ÒXDFè8ÈuÀÐiþò²[ã»!§VdÛj}²4	22:t«âÒ
Sá)Å¸ñ2ÿè°XgÕJVîzÍV*ÑÓäUfwßøI"0bt=ANíîÂ"¢+ÍGøiÛZMd±ï'UçwäæÐ×Q¹ê|ÅÉIÉ)çDÎûGçD'#§LèúÇpÒ0E`@L|')SúG`â£þ14L"'Åã¤eÀþX¹Ïg÷wiÕ4Ü°côØÙ³&÷Ð<NßS_¿ÊW9&C[ëGfÀÄG¦²ù7_ÿ>ÃPIÿ]³¼!¬ûE)ÿg¡¼@PUÔoNuÓ_Th(Ý*Ó¾&Õ§×)²±ýþ×]äkyÿënûâ?üS}:ºf)ÄÎÀÚ$qLÚÓZ¹o÷AIªÓgoú}mÔvv!èAúN|ÝYa·CÛéþÑ ½¬áá)-´³R%2Zn¨$¨VÔY,	4<T4¨ÂR;ò­¡ÂªjEåÅª¶VÛRF³¿Ohø¨ÁKúd³íXVÖP§ úXëY¤~Îr}LÀíãBÑÈ¢#-äzü0>&¦Ä4¤ÖÌÞÎÈ¢js±ö§ytÎF½Ùkmý2C`  ÚIDAT3X"ÑÌöì#pYQEê[öIo?ëè£ªh!%¾þXÊ}CØdîc×ÝfÊJz§Ú@R+÷Z«Æ¡Å'¢PÉ{*Â(÷wHy,2ÂH#VÀ}JúÍ$¥ÖPÌ:NQ5¢Cg¡7´e3ûXf£*&Íu¶¦ôõ@SkS«Fq0b²
;oþñj¹Ñ6Ú)ãÌÝz7"£ëßóÓÝLÅÒõôK9ï}ÏO³$é¼>Â¼_þ{´PhÑFËz1´ÿËO}SëëàÚ¥Y×Ð°&ÕJõGEôèj£ñQUæÉìîÐsj[_M· ù@j?yã¥ýÕæ_X7%Øç°:&E¦8Ä Ì¸ëÑ§jJ|ýjö»îþ#R¨!Ú8PnãY@;ÑI¬Ð$¿á.uIkPSÍ¡$kUåU¨PÎý_^?ZxÃ/¬éê­Éº>cÄ°Ð©v} ¶\¦Fã£Àóà°g~øÙhîqØaTËlvÍdû)bsu[ÖðN¶ùn:a+Q;U/ &ÿ<_XeS¨OÞãÈâ®_¼+=nµ1S-(q¬Êöà#Éíïs#´Ù?Î>YúÉ/y(0³±]o>øHÉµúì#DI0KÎJúÄ V±àpÐ­d¿G8û/aFæ£R-ûfÍ¥:1ò¿}Ëaø!·Kby.Ò+MâÙ8á<=·LCNv¦m¦97ÀNÕ,²Õ\A!­Ðy}ÚXÑ¸ á°áÎKeO³Ù7«½ÎÉÐ¬h#ûL!DÜ4Úæ{Lea²¦´Z*Ö,1H¹[ò(5m`¿KTeìÍ~ñ;ÿÄr~5PüÃ²ëÁtK-»®7}V^¦!Úó~f{%Aà³j9àc7²VõT6Uj¨C@­BA¢NJ¨ìÒ=½T	Ö~òï¿ÂY-õ]Ïÿ©aEkhö¼NA¨ÐâýTêÆÛ_m¦WCÕÔÔð#`Õîúé_ÆNqÄÃÕ m+`$¦ú@&£Ê9Ø£1hy©f©E²oü½ÿIÑ©PBÆÀRë[HØ\öMÂÎ¢ææªÖ´>úÆcô·ë¡ãgW°")N½ÿÁI¸Æ÷5\eî,<øÄO}%³T{Û½µ
ÌT5Ö^ÿ·o¥_éK*37¨CyèCA+â&f¬W¡§hþV	Î{77Ó1Y<Õ¼ÄUdãüö÷q§¦x¶U	ñ%³hkxVîÕÑjq$=¥¤Àat¨[ÝÛR5îüLnÖøy·R«²»i>ÝM+Åí[HL#l·}èìmÁcÜaføkÃ¹Ê57WKÍÝufª_è |¿VKó^ÿ>ý¡ÐX@7å~+'{fàæ DÄ×)öqI7EÞc5u­Ô@÷\\ëÜy¡´
5ZÔ;jeFÊf§Ìr'4ØTß·ÍWhrMaìd3k%H¡Y>C[/8VCD:,¿p.ï´ÙCs32Ðl~yí:ÖGNn¿sµÊ-.e9åÂñ'é¥¾n4ùí1 åVoí,×SSyj£¸­ÔëêýM.ûó+/}Ó½o~z?Í|Ó½ýyòæ§Ýc :Í =HúÌ
óçÜ¥°5/î:óË~íúÂÏRá²½S¹/Õ?p¦óUDù©÷ýST]xß¿bO(ØøòþÉgûñÙÑØñSî¦£Ëïº1Ý¾í,óâ×¾ñÂïÉO·ø¯{17¤((¤¥:ñGû~ùÎGþºòªºVîü·swÒ{@yÿ]Vä»8·[(vU]4P©¦E/¯¹jÀãð[^>ü"g ¿ø§?¢ä~ªÅBú,°Y[úÏJµÀA$tõ-Ï^wÛ'B"ìNÆáwÇêDÒîÑsÓ]´ºÛ~Xþ©_CÉÄ?Zÿ¸KNbÙiA»*ÍØ¯ÕjF'ÃLæ½=q#ÿåÉÿ´gäÿìëÝ=»óT¨9üèo~gd7¤Ó'Ó »´pï?sQ 
¾}×?6/8|aûhC¾ð,÷^ùdªNî¼? îq/ô	C]·''ì¦ìgÓÛØ°óÆEÊ á9ÕEù®ÛïJ­c'ÖvH øÈÈÈÝc?|xßO}ß³9Ãÿåû54´©X-]n¼ï_Ùç«¥Úo¾Î¦ÙÖàrè¡ó·I-¦~+UfYËÀnËúÒ,0ûSI²ë7Þfü£o¤¾ð=g6åÍx/Xª4«¡Ù¦óí;Íf¿ïÈEÖâþÙòeÿË'í?3@² Øúh
¨_ÏÈò*þc }4UUQµfAÌ$mm±e|Ç`(i¦ö7záoê3»Üó8EÃRsû¿ß[Ñ¬DÚÞêBIx¦$7<qø­O>a@ÿá_DÃÜÑÙÆK,T	îûÊl3jþäWþ´C(¤-ØGà#_#ëð·¦ÇXùÇÄÿ&IàþÊ¾ùÙý­!µòG/¸÷×¾âúì·¥:Ý-]ö?­wh&3¾ùÿ;ÿÃ·ý$Ó©>Ó£Á¾LÔÊ`:rÆ$|-={Û.d²é9¿V³oÃBÜ­ÒF[ÙmÉHXÌt;î4ß¢$ÙæÆ¡.	ËcÜÆøÌ+×ýÏE¯Õ	L/³Ó¤<]ãþBIRÓ_%=tÑÐÄÃÌ»8Î>iú_&1ß«ÖJð]hªkQ½îÒ÷5c+½Hî óáß=ú>
qüÌ¯ÍNIb9¡«z·àoó¬JÆªµ{=ÔyñéýÝ_Q³µ·ÞòìÒun¢öõ&	[tY[S6äV
­­	ÂO£IðÖ564é #ûIbuz¶~³ÙF7qYÔìwû%¦bXiLz5£«õQÚæEOBUJk$vC _qÖGpÁþ4ø¯$ÆJÅÂ£¾y!]õ'Ît2hKüÉ¯8Öx¬=	º¨Û¨}2]Ñ47¯IM?Üh8<L³f?Çøi(Tî'Õl. <Shh#êÍæ
kjúîSm×Oü»¨ÏfòVÔ\RJV¹	QYq+%¹êÁxÒÏT²òÙB1iØ|a5¦ã¸I'êG²<²_(_hRÃ
qøH`¿õÆû?ó+3\Kå(KéTH@÷?=í )9ØÊ¼ýÎ³ô5üh8<|D¾ímþ¤ç+ñeß¶²ÖhÍåÖÙXo×/8'Jæ`LÃiÜZ#¯5×`Â¢d&ët
ûgªßû°uÊAA³åv±IÃí[+û£m6Dã#]Ïßûû¥ `(2ïSYóf^&Ì<z¯»@w»¤¢9!fy¬rÍZ!÷Ô¬lÒW:µ']è×©LÚðöuúp4K2L²cEÆÇj%£Çß0ÃÊ¯ú/HÖGÀùø eòá­éxôÔ¨ªrm!ï·þæ§?|øôyîcÁtÎÈÇP:72ïý{ö?Ý}ôå.ÏýÆG©?~¦ÑnÃ¹[8|%û¿ÝÐÙ±cÔîYï½§ùþ×Cõ×òØ.Ó¢NÇ5Yî[X*Û0@a '8,mB7Z¢SJð«u&8=ÙûúØlòAËW¬,G|Ðbú?¾ÉÖõJjÎ¦æÚoÃÎcÄPDI:ÔpËüní£_ãÂ³vÏë³Ù:r¯¢FTÀ|À×T/?¥¦ç*t#µRÕiÖ*Æ~â"c
m×çÒ[È/ÑÒJ³éDö·U(loú- :Z«Ã)æÞÎ=[e°AÔ*&$ó`¡Y S­túÍMÖ ñyäå@@è3¥Ç·ÎýEÛªmX>ÕÂÜÍþ*ÏBm+Õì*øYk§(ä³í3Acr!\¦Vöø¥ú±g%¢È>
M¢ª]oÿÿ¾ð¹OÛÇZj¾ðÝñæÃÝ2¤a^1Íùð$û²_y=m-Ô4¿å9ùÿS@Rmg³Ç?½)ìÓV*øõûJ²µóQiÎûBFùè§¬Êuó«ÃÐ+¡¿¨Y ~¹Q%NU0ô]àT+V JÔ ®x°s4%Ðo¦ÚGf¨Ù*ÚÅ90ØpÈJ&¡g&>êÀòæÐöGåÖ ÛLUª¡
Î°jRÔï£3Tqß}\ÕïzS}æúýVf
ýkæ
¥dÚ/@ÌûÙÁ¶I×²6p¹/Ô 4,¬f5©ÙV§)/Ø·´yPXmjvC)mE¡()0`:õüVdmirGÀ uúªâÄ×LTã*ºÉÇ(ÀÝ>m¾<"°êö{µ«îèdß)+V¾&§lL|´mºzrtÀÊG`â£ï¢ÉÀ)Û&m®"°òøhå»h2pÀ¶ÀÄGÛ¦«'G§¬|&>Zù."°m"0ñÑ¶éêÉÑ)+V¾&§lLß§¼«y_atøÍlk[¢k®°h³J«9®¶ªhLå,ñe³{9ß&ßÿ/ßzÃ·f%-ß§X´Ì4ï·ÞðOÞüË¤§fSè°Rk{*,Ú¬©µ7¯½ÿ+Q¦¥ù÷ý\OaOÞöÅ_ÎÞcÚS[U@¦r?ùÑ)¾z¿£}â?|?¹î±ä6Þ¢ã½%ÍiÞãÞ~ñý½½4ÂTUfíï'×}óß¿¾§©A@Daö:Ù?ä=&é{Cm¥ùçÿí³oÈû3ôöÏ>øþ¯ÜÝ§{5SÜ´uó¼¯?}¿.Öð`Ôí(¼7t3H:¿n,ºfSH J­åµ®}ØÓâëQ¨·ùoïühzJPÛhû¿+Â[¹Qhjv[mIXé~öÂu¯P!è*-lQª¤´°¹æÒæ¥ÍuZÍ"ÁD>QÓgkØP(µ³´p¡ÂÀÙ)ö¤-ÄÄ²wê*tÀ ë#¿·¢L­æØr4×Ólì¬Á!¯é]³BZomç:]ºê±0å} íÝ]ÚG»¨Ò«$Å_ÖvK	µõ÷¾Î¾ûª|ÙWËT_?räûG²XwpRïû¬fî24Æ¶Ôì>·á}öÇéëá~û6§ö?f·ã§ÜÔj\yÍFÔ,goû,L
ÖÊ@¢­¸«"£ÌW·ñ?­[jI1 8²ãðgñNÔ
&óñ'®º,åÐRbr«¤>I2KiYöqnN9«ÒG(Nkzç+êqËMNí·å·ÒÜ!}Üwæ¶|ÂÝ^ýÖ·:¬>¶Ëýw§zÃ4£0ùÛÛQ÷cjF§<É^LiûívgÞ·»[dóÙ¿ÚÌuò0Nª=x¸ö4?vÛ0¦ÒÚô,¦Þ@qkzaÕ2ïWnùu:D§eb@FfKTÏLjâÏlwªÑæë;ºLAÀøgyÿ#®+ýµQÖÅlkä÷ÑÜx°nc &»nPÏ1(;ÐÌSdÓéä=(U¥ûh|·LÙMÊ¿JþØkõÃáæ=wKº¸'_xýët1ß-"sy_ûOÍ±CGo¿íÿgaJFN(n:üYªÝÕÐ¼Pgnª?¤¢d!1-|¡ã9%eùÆc>yÏoØÛ1SOF`Õhçö75oIºëî?*5 ã?ýË°\ç%u d®nÈ4l©y¢õàUÞ ¤°ÿÄ*gÛ5@4´Ý\k¬Ôm ¢!Ø"ßÏ&¸Y|s»ÝVÌdÿQRÔM5«!ýªnh¨'¨ºß¾M#Î:!½
dÐrÑákt.2gñyf)ÒõÜ
ñÉÇ,8ÁÙ.Ú÷äcÎÔùwì÷üG"#ÚòGö&pç¬£!I[Ü@é3KíñrD«"nhë#°11[6kýÏx	;\Ã?D³Zóg»i¶i
Råf7[>ú¢Y²XàìÆKõ¾#òôRÖÎe61I×nmu½öàa&ùýIÖÜíY#Í³÷,5ÔÜL§3õ?Öm»VòÀ< ×8IWÈ	é×ÓfÌ]Pü{¾;ÔÐ%ð_múËçÎ³°ô+Øµ¸@DöþG>tË/8¹ÜkØke $*éa(tfërØhÔí2e¶¾ÝÝ3Í(Ä/¾ï³ò¨Ì¨öeÅÙÒëvuVÝÑLçñQ ì¬²6+ÿñYysÃ]eî8¤3vï@[éôÑ]ÃÔæyî(ö[ÕÈ®ÕmªÒ)µÔ!\,ûùnÂàMp¥AÛÒCi1(Ç6þ;8çcãÍÚà¤z¬DK¡6ÅmÎ¤BîÉVÖ
ß5Ñ­Étèalënkk3úgVõE`×t½öÇ¸®ÆùlÊ"®BW!¿S îl´N3ð¿÷«5fsÞ}2»»ÑÈÚ@ý·97hçª¨	ÍØ­jªe
¹áõà#¥:UxâË¯;RE*ÕèNßYxð"bCµ~5¬Â6+OoZQ¡y´}ýæÔÚÀ/Ë]+Ö+ 0ßü!Ã}+ý5·6W¨Ê+J,f0}¤0kÒ@Â³Ê4KaÖÚó¥¾Uâ\¯»~1¹Ù­ZÑ	Y+ÞÌLÛ,
NçÞÙRÍþ$Ð­®ª<gííï«RîUl-f1q·?g[«´Àuvc³]e¬7_ê2ww<?«:÷Â»Ì®üX+2ê³&íëñågÿ«©%%ý)	a§Ú
Xå®A¾|8I~#S¥y´YÈò%È²YÚãØJæa¥=0ÊýÙíùVê¼ÊUÃD¡ð*¶ÕAºPÕp
*(Än×­¥Dà#Kk:^ &ì¼É:¸Ãå1Mt;¦,-ll;è6c#Ü\ErºÐûÖ;OFÏ+í6
j)·¤$_yQ!g%ÁòÁ×P%ÿü³ÿýèî# o~z¿ª½ý¢ÿõÂûþÕõ6ïAløâ7\FIïIkZiWÁòühßïs£íÉ7Ýð»¯|byYÓÿ$w-©Í]GIùBF³5£a¢Tæ4Õ/<ú¢»R<­BñÒ!Í¤ýéRÔÍÜé,/ð[iì:h¦U°Eà£@#4ïC%zÊ@³îAIæÀ¦YõKßuæ=µY5wù²J>ó½»vöoßò_úPéqÁ¼ùÒýÎ?±Fûo½ñ~ËcÌ¸ËÎ5¤Ð÷÷²½v/\÷,{[ñÈâý·ÜÃºñ5?$=þ¿á¾ÕRÍ\u,ÑÍ,lãÑ;tÙ÷^O.|Öê}ò/G6f£µ`ýÁÓû¡§O%ÿôïM?ag`Í­=®b0ópvFvÍtT×úö\.Ídµq½ÜrÚöÁÌN&i¿Jê0KùLÀGp³múÉm¹òÿßÎÕÆqDáQB©vpaFE6q¬*ISà.pUÊ Ãé@ 'ÐAR¸0.D¸1"¤Ti,rl"°
¥0Iì&JÒùf¿½§çÙ½»ù;0ñn±ÝùÞ7ß¾÷öíÏ)TÂä [sEQ`×Þ7>ÕàÞqxº¾Ûë,VÁ%1ÄaT[ß}º}ayÆ¨ëèÎÜª½«M¨bHóÔÇ÷ÕÅýþ_íû?'àÎ¹±]b~o¾»þÉ¼ûþ4äÉ¹ëÛBûêÁÖCa#Ü<³5H `ÀªÈw zïyi=Æ\IQÛ{ÖZ¹¦Ym;óSûã$(íÛá`ÿ,Î0;£G~Ø)DýË­ {¿ÛY¤ÈÖácSRyÊ×'¸7Ró¹Ý¿#D6¿ùÐ¸ï¿]|iNwVq¶´=h¡7£ÛUÏ>¾?ûüãÏ$ýBc£Á9 âqU¨$2+Å ÂaÐnvl¾lÜwK¬"õ-LÅÕæG?-?j_=z¿ÁwúÛ çÃÏû""ãC^TpdÐÇnRA{ÁÐÞL´ÑÚO>V×WËçåêXÎ)`RwwíÍJèÂQæÍ¢`d83ÏH¨@£7×Øt4%)Ç(ÆïSég2Â&.6qyY tÃë+[=`X7ÆøpÍ~jzóÉ/XoÌ~õüêí/NÖlb¬b0V*/µÈ¸Èà°¬¡qòHÕ¡}¸açºP
ú¹ø1	+ÈgÅH¾cì1×Øÿòï&­i¿BF¨bbX 	ë	ÈQ²fìIl ÑWDctÞ·ÜðÜ¤Ngì>[±4­6Æ2e0õt~¯$m¬HÊ(iÌß¼]è å£càÚUÐH£"ÈX§§>(t´B;ðÅæþ~ÖÅOüDc =÷Û{K¦Ètz/Úx6W.jä6ºT6n§Ï6¥v$'4k
°ðÍ§vÈ~½æÓVAèýNh@¶	[í÷éRG|õã§ÆÅÀòS¦dÑÜ6qÑBµ9#	[@C2ºûeLY4L+bòJpþrÞ)Ä·N»Vc*%IéíÈÞ0»ÕØÈÑ#jíYÃkEâkHPücTÊåã2qð
*Ì«ìÔUÅàÓþYC2¢Z÷è6d	¿±T#0Ç90¥.H|ªM]ÝæÇ¡5+C&aÍmåÅñ×øX¢?çAè@V>L¹Ê<ÔåªÒ§>"ã^Ç>ëöJyIüsðrWì%6pÂ Nó	ôÊzË/¾4É!ÃEIÓqwÝ+Waõ|ÚN0W¥Ç­ö8+ý:»¬EMjkN¢­pfÖÑÏQ|IÕS 	[/¸AvèÑV
< (H÷{¶'dg*we­WjZ:r¾S`vÐý)ù¢»qøBÄa¡¨YÈ§AÂÎÐ©ÓGVÄÖIzyF Êéc+SôÃËý	¬nÔªMsjK2¢bT2Q
sQ°¼¾ògÖ7LL©È9eú"¦nä© ÈAAiCú#ôÕ,kqCúxÿöä<spA\«Û¿öNöÌ%<­¿åÿ&à¿¹dÌÁ;Ýù­+	Átlynp¥ÝêuÖìE2:Ãl{Â9Nàq "\RÒÝZ¤$XÁsÜÃõR[Ûtì¢V²ÚpOMu,âÉ qB±4ìpòØãóÔGb&qæãÓ­,ÈrÑÁ¤Ð¯wñ,!+¾´ç¨µ56;àht¡^Án­)jõNFYÊ¢a*ÉéNDÎâ½É\ÜØêfúHp¥ÆälåB÷éD'# ¸2Ú·­[øDF«¶d×°FvÀaØ_ÍèG´ã>¥AºæURÔ¦Ô[gx/S=Ó¸½é
Ðn.=I`j|ig®÷5oÀQÂPä9P°K:´ªEfÎ9; §Qy¬aßHÄ¾T¹aÓ¯'=¼QÂC\¡<I3î|ùk2×Gû:7±ê»t £ÆìÀèÃôÙ{¤}×¨ÁG´¸ùºk ¹XnEî¨;µêéáÿf-PÛ×ýMö4	*à¸dñÿFè	¥DÆÝÎn4; æ<#föäCÍ¦(0õÞÅ?Ü¹óV±LOOã/×ìys°¼Q,8CÎI ¦Ñ(Ð(Ð(¨@¦ÿÈ¢Þ(Ð(Ð(`L/hhxUøP¥y_I}?    IEND®B`-- strong 1.0.4 - Michael Ebens
-- Licensed under the zlib/libpng license. See LICENSE.txt.

-- PRIVATE FUNCTIONS --

local function swapChar(c)
  if c:isUpper() then return c:lower() end
  return c:upper()
end

local function iter(state)
  state.i = state.i + 1
  local v = state.t[state.i]
  if v then return v end
end

local function byteIter(state)
  state.i = state.i + 1
  local v = state.t[state.i]
  if v then return v:byte() end
end

-- METATABLE --

local mt = getmetatable("")
local string = mt.__index

-- OPERATORS --

function mt.__add(a, b) return a .. b end
function mt.__sub(a, b) return a:gsub(b, "") end
function mt.__mul(a, b) return a:rep(b) end
function mt.__div(a, b) return a:split(b, true) end
function mt.__mod(a, b)
   if type(b) == "table" then
      return a:format(unpack(b))
   else
      return a:format(b)
   end
end

-- INDEXING --

function mt:__index(key)
  if type(key) == "number" then
    local len = #self
    if key > len or key < -len or key == 0 then return nil end
    return self:sub(key, key)
  else
    return string[key]
  end
end

function mt:__call(i, j)
  if type(i) == "string" then
    return self:match(i, j)
  else
    local len = #self
    if i > len or i < -len or i == 0 then return nil end
    return self:sub(i, j or i)
  end
end

-- METHODS --

function string:bytes(all)
  if all then
    return { self:byte(1, -1) }
  else
    return byteIter, { t = self, i = 0 }
  end
end

function string:camelize(upper)
  self = self:lower():gsub("[ \t_%-](.)", string.upper)
  return upper and self:gsub("^%l", string.upper) or self 
end

function string:capitalize()
  return self:lower():gsub("^%l", string.upper)
end

function string:center(int, padstr)
  local len = #self
  local diff = padstr and math.floor((int - len) / #padstr) or int - len
  local left = len + math.ceil(diff / 2)
  return self:ljust(left, padstr):rjust(left + math.floor(diff / 2), padstr)
end

function string:chars()
  return iter, { t = self, i = 0 }
end

function string:chomp(pat)
  return self:gsub((pat or "[\n\r]") .. "+$", "")
end

function string:endsWith(suffix)
  return self:sub(-#suffix, -1) == suffix
end

function string:includes(pat, plain)
  return self:find(pat, 1, plain) ~= nil
end

-- insertion postion:
-- ---------------------
-- | A | B | C | D | E |
-- ---------------------
-- 1   2   3   4   5   6
-- -6 -5  -4  -3  -2  -1
function string:insert(index, other)
  index = (index < 0 and index + 1 or index) % (#self + 1)
  
  if index == 1 then
    return other .. self
  elseif index == 0 then
    return self .. other
  else
    return self:sub(1, index - 1) .. other .. self:sub(index)
  end
end

function string:isLower()
  return self:match("^%l+$") ~= nil
end

function string:isUpper()
  return self:match("^%u+$") ~= nil
end

-- this doesn't behave like Ruby in that it discards the separator
-- it's method of detecting newlines is a bit dodgy too: \n\n would count as 1 separator
function string:lines(sep, all)
  if type(sep) == "boolean" then all, sep = sep, nil end
  local lines = self:split(sep or "[\n\r]+")
  
  if all then
    return lines
  else
    return iter, { t = lines, i = 0 }
  end
end

function string:ljust(int, padstr)
  local len = #self
  
  if int > len then
    local num = padstr and math.floor((int - len) / #padstr) or int - len
    self = self .. (padstr or " ") * num
    len = #self
    if len < int then self = self .. padstr:sub(1, int - len) end
  end
  
  return self
end

function string:lstrip()
  return self:gsub("^%s+", "")
end

-- note: this doesn't behave like Ruby's String#next method
function string:next()
  if #self == 1 then
    return string.char(self:byte() + 1)
  else
    local bytes = self:bytes(true)
    for i = 1, #bytes do bytes[i] = bytes[i] + 1 end
    return string.char(unpack(bytes))
  end
end

function string:rjust(int, padstr)
  local len = #self
  
  if int > len then
    local num = padstr and math.floor((int - len) / #padstr) or int - len
    self = ((padstr or " ") * num) .. self
    len = #self
    if len < int then self = padstr:sub(1, int - len) .. self end
  end
  
  return self
end

function string:rstrip()
  return self:gsub("%s+$", "")
end

-- credits go to thelinx for most of this function
-- https://github.com/TheLinx/loveclass/blob/master/stringextensions.lua#L6
function string:split(pat, plain)
  local t = {}
  
  while true do
    local pos1, pos2 = self:find(pat, 1, plain or false)

    if not pos1 or pos1 > pos2 then
      t[#t + 1] = self
      return t
    end
    
    t[#t + 1] = self:sub(1, pos1 - 1)
    self = self:sub(pos2 + 1)
  end
end

function string:squeeze(other)
  if other then
    return self:gsub(other .. other .. "+", other)
  else
    local last, current
    local buffer = {}

    for i = 1, #self do
      current = self[i]
      
      if current ~= last then
        table.insert(buffer, current)
        last = current
      end
    end
    
    return table.concat(buffer)
  end
end

function string:startsWith(prefix)
  return self:sub(1, #prefix) == prefix
end

function string:strip()
  return self:lstrip():rstrip()
end

function string:swapcase()
  return self:gsub("%a", swapChar)
end

function string:underscore()
  return self:gsub("([A-Z]+)([A-Z][a-z])", "%1_%2"):
              gsub("([a-z%d])([A-Z])", "%1_%2"):
              gsub("[ \t]", "_"):
              lower()
end
local showTestWindow = false
local showAnotherWindow = false
local floatValue = 0;
local sliderFloat = { 0.1, 0.5 }
local clearColor = { 0.2, 0.2, 0.2 }
--local comboSelection = 1
local textValue = "text"

local combo = {value = 2, items = {'A', 'B', 'C'}}
function drawUI ()
--	open = nk.windowBegin("test", 100,100, 100,100)
	--open = nk.treePush('tab', "test")
	--nk.treePop()
--	nk.windowEnd()
end
function initLove2D ()

	draw = love.graphics
	keyboard = love.keyboard
	mouse = love.mouse
	timer = love.timer

end


function split(str, pat)
   str = str or ''
   local t = {}  -- NOTE: use {n = 0} in Lua-5.0
   local fpat = "(.-)" .. pat
   local last_end = 1
   local s, e, cap = str:find(fpat, 1)
   while s do
      if s ~= 1 or cap ~= "" then
         table.insert(t,cap)
      end
      last_end = e+1
      s, e, cap = str:find(fpat, last_end)
   end
   if last_end <= #str then
      cap = str:sub(last_end)
      table.insert(t, cap)
   end
   return t
end

function trim(s)
  return s:match "^%s*(.-)%s*$"
end


function drawInformation()


	love.graphics.print(math.floor(UI.mousex  / 30) .. "," .. math.floor(UI.mousey / 30), 500, 500)
	value, entity = getPointingAt("name")
	if value ~= "" then 
		h = 1
		for i, ev in pairs(entity) do
			love.graphics.print(i .. ", " .. tostring(ev), 590 , 400 + (h * 10))
			h = h +  1
		end
	end
end

-- a simplified http.get function
-- function http.get(u)
  -- local t = {}
  -- local respt = http.request{
    -- url = u,
    -- sink = ltn12.sink.table(t)
  -- }
  -- -- print (respt)
  -- return table.concat(t)
-- end
	variables = {}
	
function initUIObject ()

	UI = {}

	UI.keyreleased = nil
	UI.keypressed = nil
	UI.mouseup = nil
	UI.mousedown = nil
	UI.mousex = nil
	UI.mousey = nil

end

function initVariables ()

	
	variable = {}
	variable.name = "testvar"
	variable.value = ""
	table.insert(variables, variable)

	variable = {}
	variable.name = "move"
	variable.value = "true"
	table.insert(variables, variable)
	
end


function loadVariables ()

	if  line == "VARIABLES SECTION." then
		local section = "events"
		logFile:write("Starting to add variables!\n")
		repeat
			line = scriptFile:read() 
			if line ~= nil then

				if line:startsWith("END VARIABLES.") then break end
				
				local words = line:split(" ")

				for i, word in ipairs(words) do
					--finding toplevel commands
					word = word:strip()
					if word == "new"  then
						--processing a new command until another toplevel command is found
						toplevel = "new"
					end
					
				end
				if toplevel == "new" then
					eventDone = loadVariable(line)
				end
				
					
			end
		until line == nil
	
	end

end

function loadVariable(line)
	
	words = line:split(" ")
	
	for i, word in ipairs(words)  do
		--first word should be new
		--logFile:write(word .. "\n")
		word = word:strip()
		if word == "new" then
			setupNewVariable()
			word = nil
		end
		
		if word ~= nil then
			word = word:strip()
			--print(word)
			if word:startsWith("variable.") then
				--print(word)
				word = word:gsub("%.", "|")
				variableWords = split(word, "|")
				-- print (entityWords[2])
				if variableWords[2] == "name" then
					variable.name = words[i + 2]
				end
				if variableWords[2] == "value" then
					variable.value = words[i + 2]
				end
			end
		end
		if word == "add" then
			addVariable()
			logFile:flush()
			return true
			
		end
		if word == "new" then
			return true
		end
	end
	return false
	
	
end


function addVariable()

	table.insert(variables, variable)

end


function setupNewVariable ()

	variable = {}
	
	variable.name = "tempName"
	variable.value = ""
	
end


function SystemValues(word)
	if word == "mousePos" then print (word) end
	if word == "mouseX" then word = UI.mousex end
	if word == "mouseY" then word = UI.mousey end
	if word == "mousePos" then word = UI.mousex .. "," .. UI.mousey end
	if word == "keypressed" then word = UI.keypressed end
	if word == "keyreleased" then word = UI.keyreleased end
	
	return word
end

function UserValues(word)

	for i, var in ipairs(variables) do
		if var.name == word then
			word =  var.value
		end
	end
	return word
end

function UserValues2(word)

	local words = split(word,"|")

	if words[1] == "variable" then
		for i, var in ipairs(variables) do
			if var.name == words[2] then
				word =  var.value
			end
		end
	end
	return word
end

#Version history#

##1.8.1 (03/01/2013)
* Added optionnal `tunneling` feature (not fully compatible with `Jump Point Search` as of now)
* Fixed path request failure when stepping from an unwalkable location
* Fixed `getPath()` to keep continuously failing right after an wrong path request
* Fixed _PATH for compatibility with handheld devices
* Added handling for nil values pushed into heaps
* Added `Node` as a syntactic shortcut to `Node:new(...)`
* Added type & validity checking for grid objects
* Added type & validity checking for passed-in maps
* Changed pathfinder initialization args order
* `PathFinder:setFinder()` now handles nil
* New implementation of Astar, reused internally for Dijkstra Algorithm
* Added Telescope specs tests
* Added Travis-CI validation

##1.8.0 (01/26/2013)
* Moved the internal `Grid` module at the top level
* Separated path handling logic from the pathfinder class
* Added a new `Path` class
* Moved <tt>Pathfinder:filter</tt> and <tt>Pathfinder:fill</tt> to <tt>Path:filter</tt> and <tt>Path:fill</tt> 
* Changed <tt>Pathfinder:new</tt> args, to handle the explicit choice of a finder.
* Added <tt>Pathfinder:setGrid</tt> 
* Added <tt>Pathfinder:getGrid</tt> 
* Added <tt>Pathfinder:setWalkable</tt> 
* Added <tt>Pathfinder:getWalkable</tt>
* Changed <tt>Grid:isWalkableAt</tt> to handle a third-parameter for node walkability testing
* Added <tt>Grid:getWidth</tt>
* Added <tt>Grid:getHeight</tt>
* Added <tt>Grid:getMap</tt>
* Added <tt>Grid:getNodes</tt>
* Added <tt>Grid:getNodes</tt>
* Added <tt>Path:getLength</tt> for the `Path` class, for path length self-evaluation, as it fails with finders not handling heuristics.
* Added Dijkstra algorithm
* Added Breadth-First search algorithm
* Added Depth-First search algorithm
* Updated README and documentation

##1.7.0 (01/22/13)
* Added Astar search algorithm, along with Jump Point Search
* Implemented a common interface for the <tt>Pathfinder</tt> object
* Added argument type checking on pathfinder initialization
* Added <tt>Pathfinder:setFinder</tt>
* Added <tt>Pathfinder:getFinder</tt>
* Added <tt>Pathfinder:getFinders</tt>
* Added <tt>Pathfinder:getHeuristics</tt>
* Added <tt>Pathfinder:getModes</tt>
* Added <tt>Pathfinder:filter</tt> for path compression
* Removed <tt>autoFill</tt> feature (<tt>setAutoFill</tt>, <tt>getAutoFill</tt>)
* Faster heapify method in binary heaps module
* Updated docs, README, rockspecs

## 1.6.3 (01/19/13)
* Added <tt>Grid:iter</tt>
* Added <tt>Grid:each</tt>
* Added <tt>Grid:eachRange</tt>
* Added <tt>Grid:imap</tt>
* Added <tt>Grid:imapRange</tt>
* Added <tt>Grid:__call</tt>
* Added <tt>Pathfinder:version</tt>
* Added path iterator
* Improved node passability handling
* Added support for string maps
* Various code improvements
* Hardcoded documentation, generation with LDoc
* Updated README, rockspecs

## 1.6.2 (12/01/12)
* Third-party lib 30log replaced by an hardocded class system
* Third-party lib binary-heaps replaced by a lighter implementation
* Changed initialization pattern : three-args are needed, only the first one is mandatory.
* Added support for custom heuristics
* Removed <tt>getDiagonalMoves()</tt> and <tt>setDiagonalMoves()</tt>, replaced by <tt>getMode()</tt> and <tt>setMode()</tt>
* Internal improvements, reuse data.
* Updated Readme

## 1.6.1 (11/22/12)
* Added Cardinal/Intercardinal heuristic

## 1.6.0 (11/05/12)
* Added specialized grids : preprocessed/postprocessed grids
* Nodes walkability is no longer stored as an attribute, but computed on the fly with respect to the map passed to init Jumper

##1.5.2.2 (11/02/12)
* Bugfix on resetting nodes properties (Thanks to Srdjan MarkoviÄ)
* Bugfix on path cost return

##1.5.2.1 (10/27/12)
* Bugfix (Thanks to Srdjan MarkoviÄ)

##1.5.2 (10/25/12)
* Fixed "tunneling" issue in diagonal-mode

##1.5.1.3 (10/18/12)
* Third-party 30log requiring enhanced
* Huge documentation update (See Readme)

##1.5.1.2 (10/17/12) - Fix 
* Bugfix with the previous commit (requiring third-party would not work with Löve2D, now fixed)

##1.5.1.2 (10/16/12)
* Fix on internal grid width calculation
* Added path to 30log in package.path
* Some code cleaning


##1.5.1.1 (10/15/12)
* Smoothing renamed to filling, self-explanatory (See Readme for public interface changes)

##1.5.1 (10/09/12)
* Fix for pathfinding with no diagonal moves allowed : paths returned looks more "natural".

##1.5.0 (10/06/12)
* Added support for collision maps starting at locations different than (1,1).
* Heuristic name CHEBYSHEV was removed, now on will use DIAGONAL instead.
* Changes in Jumper's initialization arguments
* Various improvements
* Updated Readme

##1.4.1 (10/04/12)
* Third-parties are now git submodules.
* Bugfix with grid reset process
* Optimized the grid reset process. Successive calls to <tt>pather:getPath()</tt> yield faster.
* Removed <tt>grid:reset()</tt>

##1.3.3 (10/01/12)
* Removed useless lines of code

##1.3.2 (09/26/12)
* Compatibility issue with Gideros : Jumper couldn't be required, due to the way Gideros run projects.
* Updated Readme

##1.3.1 (09/25/12)
* Jumper no longer uses internally Lua's <tt>module</tt> function.
* Global env pollution bugfix

##1.3 (09/25/12)
* added autoSmooth feature : returned paths can now be automatically smoothered on return
* <tt>searchPath</tt> renamed to <tt>getPath</tt>
* Added chaining
* Slight enhancements in code, making profit of Lua's multiple return values ability
* Updated Readme
* Updated demos

##1.2 (08/28/12)
* Jumper now uses [30log](http://github.com/Yonaba/30log) as its object orientation library
* Global env pollution when requiring jumper now fixed (See init.lua)
* Updated Readme

##1.1.1 (08/27/12)
* Third party updated (Binary_Heaps v1.5)
* Code cleaning, Fixed indentation

##1.1 (08/01/12)
* Updated with third-party (with Binary_Heaps ported to 1.4)

##1.0 (06/14/12)
* Added Path smoother
* Better handling of straight moves
* Code cleaning

##0.3 (06/01/12)
* Bugfix with internal paths calls to third-parties.

##0.2 (05/28/12)
* Updated third-party libraries (Lua Class System, Binary Heaps)
* Added version_history.md

##0.1 (05/26/12)
* Initial release
			
// Place your settings in this file to overwrite default and user settings.
{
}<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Jumper documentation</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Jumper(v1.8.1)</h1>




<h2>Modules</h2>
<ul>
  <li><a href="modules/jumper.core.bheap.html">jumper.core.bheap</a></li>
  <li><a href="modules/jumper.core.heuristics.html">jumper.core.heuristics</a></li>
  <li><a href="modules/jumper.core.node.html">jumper.core.node</a></li>
  <li><a href="modules/jumper.core.path.html">jumper.core.path</a></li>
  <li><a href="modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="modules/jumper.pathfinder.html">jumper.pathfinder</a></li>
</ul>
<h2>Scripts</h2>
<ul>
  <li><a href="scripts/jumper.search.astar.html">jumper.search.astar</a></li>
  <li><a href="scripts/jumper.search.bfs.html">jumper.search.bfs</a></li>
  <li><a href="scripts/jumper.search.dfs.html">jumper.search.dfs</a></li>
  <li><a href="scripts/jumper.search.dijkstra.html">jumper.search.dijkstra</a></li>
  <li><a href="scripts/jumper.search.jps.html">jumper.search.jps</a></li>
  <li><a href="scripts/jumper.search.thetastar.html">jumper.search.thetastar</a></li>
</ul>

</div>

<div id="content">



  <h2>

<h2>Fast and lightweight pathfinding library for grid based games</h2>

</h2>

<h2>Modules</h2>
<table class="module_list">
	<tr>
		<td class="name" nowrap><a href="modules/jumper.core.bheap.html">jumper.core.bheap</a></td>
		<td class="summary"><strong>A light implementation of <code>binary heaps</code></strong>.</td>
	</tr>
	<tr>
		<td class="name" nowrap><a href="modules/jumper.core.heuristics.html">jumper.core.heuristics</a></td>
		<td class="summary"><strong>Heuristics for the search algorithm</strong>.</td>
	</tr>
	<tr>
		<td class="name" nowrap><a href="modules/jumper.core.node.html">jumper.core.node</a></td>
		<td class="summary"><strong>The <code>node</code> class</strong>.</td>
	</tr>
	<tr>
		<td class="name" nowrap><a href="modules/jumper.core.path.html">jumper.core.path</a></td>
		<td class="summary"><strong>The <code>path</code> class</strong>.</td>
	</tr>
	<tr>
		<td class="name" nowrap><a href="modules/jumper.grid.html">jumper.grid</a></td>
		<td class="summary"><strong>The <code>grid</code> class API</strong>.</td>
	</tr>
	<tr>
		<td class="name" nowrap><a href="modules/jumper.grid.html">jumper.grid</a></td>
		<td class="summary"><strong>The <code>grid</code> class API</strong>.</td>
	</tr>
	<tr>
		<td class="name" nowrap><a href="modules/jumper.pathfinder.html">jumper.pathfinder</a></td>
		<td class="summary"><strong>The <strong>pathfinder</strong> class API</strong>.</td>
	</tr>
</table>
<h2>Scripts</h2>
<table class="module_list">
	<tr>
		<td class="name" nowrap><a href="scripts/jumper.search.astar.html">jumper.search.astar</a></td>
		<td class="summary"><strong><code>A-star</code> algorithm</strong>.</td>
	</tr>
	<tr>
		<td class="name" nowrap><a href="scripts/jumper.search.bfs.html">jumper.search.bfs</a></td>
		<td class="summary"><strong><code>Breadth-First Search</code> algorithm</strong>.</td>
	</tr>
	<tr>
		<td class="name" nowrap><a href="scripts/jumper.search.dfs.html">jumper.search.dfs</a></td>
		<td class="summary"><strong><code>Depth First Search</code> algorithm</strong>.</td>
	</tr>
	<tr>
		<td class="name" nowrap><a href="scripts/jumper.search.dijkstra.html">jumper.search.dijkstra</a></td>
		<td class="summary"><strong><code>Dijkstra</code> algorithm</strong>.</td>
	</tr>
	<tr>
		<td class="name" nowrap><a href="scripts/jumper.search.jps.html">jumper.search.jps</a></td>
		<td class="summary"><strong><code>Jump Point Search</code> algorithm</strong>.</td>
	</tr>
	<tr>
		<td class="name" nowrap><a href="scripts/jumper.search.thetastar.html">jumper.search.thetastar</a></td>
		<td class="summary"><strong><code>Theta-star</code> algorithm</strong>.</td>
	</tr>
</table>

</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.3</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
/* BEGIN RESET

Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.2r1
*/
html {
    color: #000;
    background: #FFF;
}
body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td {
    margin: 0;
    padding: 0;
}
table {
    border-collapse: collapse;
    border-spacing: 0;
}
fieldset,img {
    border: 0;
}
address,caption,cite,code,dfn,em,strong,th,var,optgroup {
    font-style: inherit;
    font-weight: inherit;
}
del,ins {
    text-decoration: none;
}
li {
    list-style: bullet;
    margin-left: 20px;
}
caption,th {
    text-align: left;
}
h1,h2,h3,h4,h5,h6 {
    font-size: 100%;
    font-weight: bold;
}
q:before,q:after {
    content: '';
}
abbr,acronym {
    border: 0;
    font-variant: normal;
}
sup {
    vertical-align: baseline;
}
sub {
    vertical-align: baseline;
}
legend {
    color: #000;
}
input,button,textarea,select,optgroup,option {
    font-family: inherit;
    font-size: inherit;
    font-style: inherit;
    font-weight: inherit;
}
input,button,textarea,select {*font-size:100%;
}
/* END RESET */

body {
    margin-left: 1em;
    margin-right: 1em;
    font-family: arial, helvetica, geneva, sans-serif;
    background-color: #ffffff; margin: 0px;
}

code, tt { font-family: monospace; }
span.parameter { font-family:monospace; }
span.parameter:after { content:":"; }
span.types:before { content:"("; }
span.types:after { content:")"; }
.type { font-weight: bold; font-style:italic }

body, p, td, th { font-size: .95em; line-height: 1.2em;}

p, ul { margin: 10px 0 0 10px;}

strong { font-weight: bold;}

em { font-style: italic;}

h1 {
    font-size: 1.5em;
    margin: 0 0 20px 0;
}
h2, h3, h4 { margin: 15px 0 10px 0; }
h2 { font-size: 1.25em; }
h3 { font-size: 1.15em; }
h4 { font-size: 1.06em; }

a:link { font-weight: bold; color: #004080; text-decoration: none; }
a:visited { font-weight: bold; color: #006699; text-decoration: none; }
a:link:hover { text-decoration: underline; }

hr {
    color:#cccccc;
    background: #00007f;
    height: 1px;
}

blockquote { margin-left: 3em; }

ul { list-style-type: disc; }

p.name {
    font-family: "Andale Mono", monospace;
    padding-top: 1em;
}

pre.example {
    background-color: rgb(245, 245, 245);
    border: 1px solid silver;
    padding: 10px;
    margin: 10px 0 10px 0;
    font-family: "Andale Mono", monospace;
    font-size: .85em;
}

pre {
    background-color: rgb(245, 245, 245);
    border: 1px solid silver;
    padding: 10px;
    margin: 10px 0 10px 0;
    overflow: auto;
    font-family: "Andale Mono", monospace;
}


table.index { border: 1px #00007f; }
table.index td { text-align: left; vertical-align: top; }

#container {
    margin-left: 1em;
    margin-right: 1em;
    background-color: #f0f0f0;
}

#product {
    text-align: center;
    border-bottom: 1px solid #cccccc;
    background-color: #ffffff;
}

#product big {
    font-size: 2em;
}

#main {
    background-color: #f0f0f0;
    border-left: 2px solid #cccccc;
}

#navigation {
    float: left;
    width: 18em;
    vertical-align: top;
    background-color: #f0f0f0;
    overflow: visible;
}

#navigation h2 {
    background-color:#e7e7e7;
    font-size:1.1em;
    color:#000000;
    text-align: left;
    padding:0.2em;
    border-top:1px solid #dddddd;
    border-bottom:1px solid #dddddd;
}

#navigation ul
{
    font-size:1em;
    list-style-type: none;
    margin: 1px 1px 10px 1px;
}

#navigation li {
    text-indent: -1em;
    display: block;
    margin: 3px 0px 0px 22px;
}

#navigation li li a {
    margin: 0px 3px 0px -1em;
}

#content {
    margin-left: 18em;
    padding: 1em;
    width: 700px;
    border-left: 2px solid #cccccc;
    border-right: 2px solid #cccccc;
    background-color: #ffffff;
}

#about {
    clear: both;
    padding: 5px;
    border-top: 2px solid #cccccc;
    background-color: #ffffff;
}

@media print {
    body {
        font: 12pt "Times New Roman", "TimeNR", Times, serif;
    }
    a { font-weight: bold; color: #004080; text-decoration: underline; }

    #main {
        background-color: #ffffff;
        border-left: 0px;
    }

    #container {
        margin-left: 2%;
        margin-right: 2%;
        background-color: #ffffff;
    }

    #content {
        padding: 1em;
        background-color: #ffffff;
    }

    #navigation {
        display: none;
    }
    pre.example {
        font-family: "Andale Mono", monospace;
        font-size: 10pt;
        page-break-inside: avoid;
    }
}

table.module_list {
    border-width: 1px;
    border-style: solid;
    border-color: #cccccc;
    border-collapse: collapse;
}
table.module_list td {
    border-width: 1px;
    padding: 3px;
    border-style: solid;
    border-color: #cccccc;
}
table.module_list td.name { background-color: #f0f0f0; ; min-width: 200px; }
table.module_list td.summary { width: 100%; }


table.function_list {
    border-width: 1px;
    border-style: solid;
    border-color: #cccccc;
    border-collapse: collapse;
}
table.function_list td {
    border-width: 1px;
    padding: 3px;
    border-style: solid;
    border-color: #cccccc;
}
table.function_list td.name { background-color: #f0f0f0; ; min-width: 200px; }
table.function_list td.summary { width: 100%; }

dl.table dt, dl.function dt {border-top: 1px solid #ccc; padding-top: 1em;}
dl.table dd, dl.function dd {padding-bottom: 1em; margin: 10px 0 0 20px;}
dl.table h3, dl.function h3 {font-size: .95em;}

/* stop sublists from having initial vertical space */
ul ul { margin-top: 0px; }
ol ul { margin-top: 0px; }
ol ol { margin-top: 0px; }
ul ol { margin-top: 0px; }

/* styles for prettification of source */
.keyword {font-weight: bold; color: #6666AA; }
.number  { color: #AA6666; }
.string  { color: #8888AA; }
.comment { color: #666600; }
.prepro { color: #006666; }
.global { color: #800080; }
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Jumper documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Jumper(v1.8.1)</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
<li><a href="#Tables">Tables</a></li>
</ul>


<h2>Modules</h2>
<ul>
  <li><strong>jumper.core.bheap</strong></li>
  <li><a href="../modules/jumper.core.heuristics.html">jumper.core.heuristics</a></li>
  <li><a href="../modules/jumper.core.node.html">jumper.core.node</a></li>
  <li><a href="../modules/jumper.core.path.html">jumper.core.path</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.pathfinder.html">jumper.pathfinder</a></li>
</ul>
<h2>Scripts</h2>
<ul>
  <li><a href="../scripts/jumper.search.astar.html">jumper.search.astar</a></li>
  <li><a href="../scripts/jumper.search.bfs.html">jumper.search.bfs</a></li>
  <li><a href="../scripts/jumper.search.dfs.html">jumper.search.dfs</a></li>
  <li><a href="../scripts/jumper.search.dijkstra.html">jumper.search.dijkstra</a></li>
  <li><a href="../scripts/jumper.search.jps.html">jumper.search.jps</a></li>
  <li><a href="../scripts/jumper.search.thetastar.html">jumper.search.thetastar</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>jumper.core.bheap</code></h1>

<p><strong>A light implementation of <code>binary heaps</code></strong>.</p>
<p> While running a search, some algorithms have to maintains a list of nodes called <strong>open list</strong>.
 Finding in this list the lowest cost node from the node being processed can be quite slow,
 (as it requires to skim through the collection of nodes stored in this list)
 especially when dozens of nodes are being processed (large maps). </p>

<p> The current module implements a <a href="http://www.policyalmanac.org/games/binaryHeaps.htm">binary heap</a> data structure,
 from which the internal open list will be instantiated. As such, looking up for lower-cost
 node will run faster, and globally makes the search algorithm run faster.</p>

<p> This module should normally not be used explicitely. The algorithm uses it internally.</p>
    <h3>Info:</h3>
    <ul>
        <li><strong>Copyright</strong>: 2012-2013</li>
        <li><strong>License</strong>: <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a></li>
        <li><strong>Author</strong>: Roland Yonaba</li>
    </ul>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#heap:empty">heap:empty&nbsp;()</a></td>
	<td class="summary">Checks if a <a href="../modules/jumper.core.bheap.html#heap">heap</a>  is empty</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#heap:clear">heap:clear&nbsp;()</a></td>
	<td class="summary">Clears the <a href="../modules/jumper.core.bheap.html#heap">heap</a>  (removes all items queued in the heap)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#heap:push">heap:push&nbsp;(item)</a></td>
	<td class="summary">Adds a new item in the <a href="../modules/jumper.core.bheap.html#heap">heap</a> </td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#heap:pop">heap:pop&nbsp;()</a></td>
	<td class="summary">Pops from the <a href="../modules/jumper.core.bheap.html#heap">heap</a> .</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#heap:heapify">heap:heapify&nbsp;([item])</a></td>
	<td class="summary">Restores the <a href="../modules/jumper.core.bheap.html#heap">heap</a>  property.</td>
	</tr>
</table>
<h2><a href="#Tables">Tables</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#heap">heap</a></td>
	<td class="summary">The <a href="../modules/jumper.core.bheap.html#heap">heap</a>  class</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Functions"></a>Functions</h2>

    <dl class="function">
    <dt>
    <a name = "heap:empty"></a>
    <strong>heap:empty&nbsp;()</strong>
    </dt>
    <dd>
    Checks if a <a href="../modules/jumper.core.bheap.html#heap">heap</a>  is empty


    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">bool</span></span>
        <code>true</code> of no item is queued in the heap, <code>false</code> otherwise
    </ol>




</dd>
    <dt>
    <a name = "heap:clear"></a>
    <strong>heap:clear&nbsp;()</strong>
    </dt>
    <dd>
    Clears the <a href="../modules/jumper.core.bheap.html#heap">heap</a>  (removes all items queued in the heap)






</dd>
    <dt>
    <a name = "heap:push"></a>
    <strong>heap:push&nbsp;(item)</strong>
    </dt>
    <dd>
    Adds a new item in the <a href="../modules/jumper.core.bheap.html#heap">heap</a>

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">item</span>
        <span class="types"><span class="type">object</span></span>
       a new object to be queued in the heap</li>
    </ul>





</dd>
    <dt>
    <a name = "heap:pop"></a>
    <strong>heap:pop&nbsp;()</strong>
    </dt>
    <dd>
    Pops from the <a href="../modules/jumper.core.bheap.html#heap">heap</a> .
 Removes and returns the lowest cost item (with respect to the comparison function used) from the <a href="../modules/jumper.core.bheap.html#heap">heap</a> .


    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">object</span></span>
        an object stored in the heap
    </ol>




</dd>
    <dt>
    <a name = "heap:heapify"></a>
    <strong>heap:heapify&nbsp;([item])</strong>
    </dt>
    <dd>
    Restores the <a href="../modules/jumper.core.bheap.html#heap">heap</a>  property.
 Reorders the <a href="../modules/jumper.core.bheap.html#heap">heap</a>  with respect to the comparison function being used.
 When given arg <code>item</code>, will sort that very item in the <a href="../modules/jumper.core.bheap.html#heap">heap</a> .
 Otherwise, the whole <a href="../modules/jumper.core.bheap.html#heap">heap</a>  will be sorted.

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">item</span>
        <span class="types"><span class="type">object</span></span>
       the modified object</li>
    </ul>





</dd>
</dl>
    <h2><a name="Tables"></a>Tables</h2>

    <dl class="function">
    <dt>
    <a name = "heap"></a>
    <strong>heap</strong>
    </dt>
    <dd>
    The <a href="../modules/jumper.core.bheap.html#heap">heap</a>  class






</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.3</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Jumper documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Jumper(v1.8.1)</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
</ul>


<h2>Modules</h2>
<ul>
  <li><a href="../modules/jumper.core.bheap.html">jumper.core.bheap</a></li>
  <li><strong>jumper.core.heuristics</strong></li>
  <li><a href="../modules/jumper.core.node.html">jumper.core.node</a></li>
  <li><a href="../modules/jumper.core.path.html">jumper.core.path</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.pathfinder.html">jumper.pathfinder</a></li>
</ul>
<h2>Scripts</h2>
<ul>
  <li><a href="../scripts/jumper.search.astar.html">jumper.search.astar</a></li>
  <li><a href="../scripts/jumper.search.bfs.html">jumper.search.bfs</a></li>
  <li><a href="../scripts/jumper.search.dfs.html">jumper.search.dfs</a></li>
  <li><a href="../scripts/jumper.search.dijkstra.html">jumper.search.dijkstra</a></li>
  <li><a href="../scripts/jumper.search.jps.html">jumper.search.jps</a></li>
  <li><a href="../scripts/jumper.search.thetastar.html">jumper.search.thetastar</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>jumper.core.heuristics</code></h1>

<p><strong>Heuristics for the search algorithm</strong>.</p>
<p> A <a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html">heuristic</a>
 provides an <em>estimate of the optimal cost</em> from a given location to a target.
 As such, it guides the pathfinder to the goal, helping it to decide which route is the best.</p>

<p> This script holds the definition of built-in heuristics available.</p>

<p> Distance functions are internally used by the <a href="../modules/jumper.core.heuristics.html#jumper.pathfinder">pathfinder</a>  to evaluate the optimal path
 from the start location to the goal. These functions share the same prototype:
 <ul>
 <pre class="example">
 local function myHeuristic(dx, dy)
   -- function body
 end
 </pre></ul>
 Jumper features some built-in distance heuristics, named <code>MANHATTAN</code>, <code>EUCLIDIAN</code>, <code>DIAGONAL</code>, <code>CARDINTCARD</code>.
 You can also supply your own heuristic function, using the template given above.</p>
    <h3>Usage:</h3>
    <ul>
        <pre class="example">  -- Example
  local Distance = require (&apos;jumper.core.heuristics&apos;)
  local Grid = require (&quot;jumper.grid&quot;)
  local Pathfinder = require (&quot;jumper.pathfinder&quot;)
  local walkable = 0
  -- Placeholder: local map = {...}
  local grid = Grid(map)
  local myFinder = Pathfinder(&apos;ASTAR&apos;, grid, walkable)

  -- Use Euclidian heuristic to evaluate distance
  myFinder:setHeuristic(&apos;EUCLIDIAN&apos;)
  -- etc ...
</pre>
    </ul>
    <h3>Info:</h3>
    <ul>
        <li><strong>Copyright</strong>: 2012-2013</li>
        <li><strong>License</strong>: MIT</li>
        <li><strong>Author</strong>: Roland Yonaba</li>
    </ul>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#Heuristics.MANHATTAN">Heuristics.MANHATTAN&nbsp;(dx, dy)</a></td>
	<td class="summary">Manhattan distance.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Heuristics.EUCLIDIAN">Heuristics.EUCLIDIAN&nbsp;(dx, dy)</a></td>
	<td class="summary">Euclidian distance.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Heuristics.DIAGONAL">Heuristics.DIAGONAL&nbsp;(dx, dy)</a></td>
	<td class="summary">Diagonal distance.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Heuristics.CARDINTCARD">Heuristics.CARDINTCARD&nbsp;(dx, dy)</a></td>
	<td class="summary">Cardinal/Intercardinal distance.</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Functions"></a>Functions</h2>

    <dl class="function">
    <dt>
    <a name = "Heuristics.MANHATTAN"></a>
    <strong>Heuristics.MANHATTAN&nbsp;(dx, dy)</strong>
    </dt>
    <dd>
    Manhattan distance.
 <br/>This heuristic is the default one being used by the <a href="../modules/jumper.core.heuristics.html#jumper.pathfinder">pathfinder</a>  object.
 <br/>Evaluates as <code>distance = |dx|+|dy|</code>

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">dx</span>
        <span class="types"><span class="type">int</span></span>
       the difference endX-startX</li>
      <li><span class="parameter">dy</span>
        <span class="types"><span class="type">int</span></span>
       the difference endY-startY</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">number</span></span>
        the distance from location <code>startX, startY</code> to location <code>endX, endY</code>
 <ul>
 <pre class="example">
 -- First method
 pathfinder:setHeuristic('MANHATTAN')<br/>
 -- Second method
 local Distance = require ('jumper.core.heuristics')
 pathfinder:setHeuristic(Distance.MANHATTAN)
 </pre></ul>
    </ol>




</dd>
    <dt>
    <a name = "Heuristics.EUCLIDIAN"></a>
    <strong>Heuristics.EUCLIDIAN&nbsp;(dx, dy)</strong>
    </dt>
    <dd>
    Euclidian distance.
 <br/>Evaluates as <code>distance = squareRoot(dx*dx+dy*dy)</code>

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">dx</span>
        <span class="types"><span class="type">int</span></span>
       the difference endX-startX</li>
      <li><span class="parameter">dy</span>
        <span class="types"><span class="type">int</span></span>
       the difference endY-startY</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">number</span></span>
        the distance from location <code>startX, startY</code> to location <code>endX, endY</code>
 <ul>
 <pre class="example">
 -- First method
 pathfinder:setHeuristic('EUCLIDIAN')<br/>
 -- Second method
 local Distance = require ('jumper.core.heuristics')
 pathfinder:setHeuristic(Distance.EUCLIDIAN)
 </pre></ul>
    </ol>




</dd>
    <dt>
    <a name = "Heuristics.DIAGONAL"></a>
    <strong>Heuristics.DIAGONAL&nbsp;(dx, dy)</strong>
    </dt>
    <dd>
    Diagonal distance.
 <br/>Evaluates as <code>distance = max(|dx|, abs|dy|)</code>

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">dx</span>
        <span class="types"><span class="type">int</span></span>
       the difference endX-startX</li>
      <li><span class="parameter">dy</span>
        <span class="types"><span class="type">int</span></span>
       the difference endY-startY</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">number</span></span>
        the distance from location <code>startX, startY</code> to location <code>endX, endY</code>
 <ul>
 <pre class="example">
 -- First method
 pathfinder:setHeuristic('DIAGONAL')<br/>
 -- Second method
 local Distance = require ('jumper.core.heuristics')
 pathfinder:setHeuristic(Distance.DIAGONAL)
 </pre></ul>
    </ol>




</dd>
    <dt>
    <a name = "Heuristics.CARDINTCARD"></a>
    <strong>Heuristics.CARDINTCARD&nbsp;(dx, dy)</strong>
    </dt>
    <dd>
    Cardinal/Intercardinal distance.
 <br/>Evaluates as <code>distance = min(dx, dy)*squareRoot(2) + max(dx, dy) - min(dx, dy)</code>

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">dx</span>
        <span class="types"><span class="type">int</span></span>
       the difference endX-startX</li>
      <li><span class="parameter">dy</span>
        <span class="types"><span class="type">int</span></span>
       the difference endY-startY</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">number</span></span>
        the distance from location <code>startX, startY</code> to location <code>endX, endY</code>
 <ul>
 <pre class="example">
 -- First method
 pathfinder:setHeuristic('CARDINTCARD')<br/>
 -- Second method
 local Distance = require ('jumper.core.heuristics')
 pathfinder:setHeuristic(Distance.CARDINTCARD)
 </pre></ul>
    </ol>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.3</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Jumper documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Jumper(v1.8.1)</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
<li><a href="#Tables">Tables</a></li>
</ul>


<h2>Modules</h2>
<ul>
  <li><a href="../modules/jumper.core.bheap.html">jumper.core.bheap</a></li>
  <li><a href="../modules/jumper.core.heuristics.html">jumper.core.heuristics</a></li>
  <li><strong>jumper.core.node</strong></li>
  <li><a href="../modules/jumper.core.path.html">jumper.core.path</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.pathfinder.html">jumper.pathfinder</a></li>
</ul>
<h2>Scripts</h2>
<ul>
  <li><a href="../scripts/jumper.search.astar.html">jumper.search.astar</a></li>
  <li><a href="../scripts/jumper.search.bfs.html">jumper.search.bfs</a></li>
  <li><a href="../scripts/jumper.search.dfs.html">jumper.search.dfs</a></li>
  <li><a href="../scripts/jumper.search.dijkstra.html">jumper.search.dijkstra</a></li>
  <li><a href="../scripts/jumper.search.jps.html">jumper.search.jps</a></li>
  <li><a href="../scripts/jumper.search.thetastar.html">jumper.search.thetastar</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>jumper.core.node</code></h1>

<p><strong>The <code>node</code> class</strong>.</p>
<p> The <a href="../modules/jumper.core.node.html#jumper.core.node">node</a>  class represents a cell on a collision map. Basically, for each single cell
 in the collision map passed-in upon initialization, a <a href="../modules/jumper.core.node.html#jumper.core.node">node</a>  object would be generated
 and then stored within the <a href="../modules/jumper.core.node.html#jumper.grid">grid</a>  object.</p>

<p> In the following implementation, nodes can be compared using the <code>&lt;</code> operator. The comparison is
 made on the basis of their <code>f</code> cost. From a processed node, the <a href="../modules/jumper.core.node.html#jumper.pathfinder">pathfinder</a>  would expand the search
 to the next neighbouring node having the lowest <code>f</code> cost. This comparison is internally used within the
 <em>open list</em> <code>heap</code> to quickly sort all nodes queued inside the heap.
 </p>
    <h3>Info:</h3>
    <ul>
        <li><strong>Copyright</strong>: 2012-2013</li>
        <li><strong>License</strong>: <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a></li>
        <li><strong>Author</strong>: Roland Yonaba</li>
    </ul>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#node:new">node:new&nbsp;(x, y)</a></td>
	<td class="summary">Inits a new <a href="../modules/jumper.core.node.html#jumper.core.node">node</a>  object</td>
	</tr>
</table>
<h2><a href="#Tables">Tables</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#node">node</a></td>
	<td class="summary">Internal <a href="../modules/jumper.core.node.html#jumper.core.node">node</a>  Class</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Functions"></a>Functions</h2>

    <dl class="function">
    <dt>
    <a name = "node:new"></a>
    <strong>node:new&nbsp;(x, y)</strong>
    </dt>
    <dd>
    Inits a new <a href="../modules/jumper.core.node.html#jumper.core.node">node</a>  object

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">x</span>
        <span class="types"><span class="type">int</span></span>
       the x-coordinate of the node on the collision map</li>
      <li><span class="parameter">y</span>
        <span class="types"><span class="type">int</span></span>
       the y-coordinate of the node on the collision map</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

          <span class="types"><a class="type" href="../modules/jumper.core.node.html#jumper.core.node">node</a></span>
        a new <a href="../modules/jumper.core.node.html#jumper.core.node">node</a>  object
    </ol>




</dd>
</dl>
    <h2><a name="Tables"></a>Tables</h2>

    <dl class="function">
    <dt>
    <a name = "node"></a>
    <strong>node</strong>
    </dt>
    <dd>
    Internal <a href="../modules/jumper.core.node.html#jumper.core.node">node</a>  Class

    <h3>Fields:</h3>
    <ul>
      <li><span class="parameter">x</span>
       the x-coordinate of the node on the collision map</li>
      <li><span class="parameter">y</span>
       the y-coordinate of the node on the collision map</li>
    </ul>





</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.3</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Jumper documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Jumper(v1.8.1)</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
<li><a href="#Tables">Tables</a></li>
</ul>


<h2>Modules</h2>
<ul>
  <li><a href="../modules/jumper.core.bheap.html">jumper.core.bheap</a></li>
  <li><a href="../modules/jumper.core.heuristics.html">jumper.core.heuristics</a></li>
  <li><a href="../modules/jumper.core.node.html">jumper.core.node</a></li>
  <li><strong>jumper.core.path</strong></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.pathfinder.html">jumper.pathfinder</a></li>
</ul>
<h2>Scripts</h2>
<ul>
  <li><a href="../scripts/jumper.search.astar.html">jumper.search.astar</a></li>
  <li><a href="../scripts/jumper.search.bfs.html">jumper.search.bfs</a></li>
  <li><a href="../scripts/jumper.search.dfs.html">jumper.search.dfs</a></li>
  <li><a href="../scripts/jumper.search.dijkstra.html">jumper.search.dijkstra</a></li>
  <li><a href="../scripts/jumper.search.jps.html">jumper.search.jps</a></li>
  <li><a href="../scripts/jumper.search.thetastar.html">jumper.search.thetastar</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>jumper.core.path</code></h1>

<p><strong>The <code>path</code> class</strong>.</p>
<p> The <a href="../modules/jumper.core.path.html#jumper.core.path">path</a>  class represents a path from a <code>start</code> location to a <code>goal</code>.
 An instance from this class would be a result of a request addressed to <code>pathfinder:getPath</code>.
 A <a href="../modules/jumper.core.path.html#jumper.core.path">path</a>  is basically a set of <code>nodes</code>, aligned in a specific order, defining a way to follow for moving agents.</p>
    <h3>Info:</h3>
    <ul>
        <li><strong>Copyright</strong>: 2012-2013</li>
        <li><strong>License</strong>: <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a></li>
        <li><strong>Author</strong>: Roland Yonaba</li>
    </ul>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#path:new">path:new&nbsp;()</a></td>
	<td class="summary">Inits a new <a href="../modules/jumper.core.path.html#jumper.core.path">path</a>  object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#path:iter">path:iter&nbsp;()</a></td>
	<td class="summary">Iterates on each single <a href="../modules/jumper.core.path.html#jumper.core.node">node</a>  along a <a href="../modules/jumper.core.path.html#jumper.core.path">path</a> .</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#path:nodes">path:nodes&nbsp;()</a></td>
	<td class="summary">Iterates on each single <a href="../modules/jumper.core.path.html#jumper.core.node">node</a>  along a <a href="../modules/jumper.core.path.html#jumper.core.path">path</a> .</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#path:getLength">path:getLength&nbsp;()</a></td>
	<td class="summary">Evaluates the <a href="../modules/jumper.core.path.html#jumper.core.path">path</a>  length</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#path:fill">path:fill&nbsp;()</a></td>
	<td class="summary">Path filling function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#path:filter">path:filter&nbsp;()</a></td>
	<td class="summary">Path compression.</td>
	</tr>
</table>
<h2><a href="#Tables">Tables</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#path">path</a></td>
	<td class="summary">The <a href="../modules/jumper.core.path.html#jumper.core.path">path</a>  class</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Functions"></a>Functions</h2>

    <dl class="function">
    <dt>
    <a name = "path:new"></a>
    <strong>path:new&nbsp;()</strong>
    </dt>
    <dd>
    Inits a new <a href="../modules/jumper.core.path.html#jumper.core.path">path</a>  object.


    <h3>Returns:</h3>
    <ol>

          <span class="types"><a class="type" href="../modules/jumper.core.path.html#jumper.core.path">path</a></span>
        a <a href="../modules/jumper.core.path.html#jumper.core.path">path</a>  object
    </ol>




</dd>
    <dt>
    <a name = "path:iter"></a>
    <strong>path:iter&nbsp;()</strong>
    </dt>
    <dd>
    Iterates on each single <a href="../modules/jumper.core.path.html#jumper.core.node">node</a>  along a <a href="../modules/jumper.core.path.html#jumper.core.path">path</a> .  At each step of iteration,
 returns a <a href="../modules/jumper.core.path.html#jumper.core.node">node</a>  and plus a count value. Aliased as <a href="../modules/jumper.core.path.html#path:nodes">path:nodes</a>


    <h3>Returns:</h3>
    <ol>
        <li>
          <span class="types"><a class="type" href="../modules/jumper.core.path.html#jumper.core.node">node</a></span>
        a <a href="../modules/jumper.core.path.html#jumper.core.node">node</a> </li>
        <li>
          <span class="types"><span class="type">int</span></span>
        the count for the number of nodes</li>
    </ol>


    <h3>see also:</h3>
    <ul>
         <a href="../modules/jumper.core.path.html#path:nodes">path:nodes</a>
    </ul>


</dd>
    <dt>
    <a name = "path:nodes"></a>
    <strong>path:nodes&nbsp;()</strong>
    </dt>
    <dd>
    Iterates on each single <a href="../modules/jumper.core.path.html#jumper.core.node">node</a>  along a <a href="../modules/jumper.core.path.html#jumper.core.path">path</a> .  At each step of iteration,
 returns a <a href="../modules/jumper.core.path.html#jumper.core.node">node</a>  and plus a count value. Aliased for <a href="../modules/jumper.core.path.html#path:iter">path:iter</a>


    <h3>Returns:</h3>
    <ol>
        <li>
          <span class="types"><a class="type" href="../modules/jumper.core.path.html#jumper.core.node">node</a></span>
        a <a href="../modules/jumper.core.path.html#jumper.core.node">node</a> </li>
        <li>
          <span class="types"><span class="type">int</span></span>
        the count for the number of nodes</li>
    </ol>


    <h3>see also:</h3>
    <ul>
         <a href="../modules/jumper.core.path.html#path:iter">path:iter</a>
    </ul>


</dd>
    <dt>
    <a name = "path:getLength"></a>
    <strong>path:getLength&nbsp;()</strong>
    </dt>
    <dd>
    Evaluates the <a href="../modules/jumper.core.path.html#jumper.core.path">path</a>  length


    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">number</span></span>
        the <a href="../modules/jumper.core.path.html#jumper.core.path">path</a>  length
    </ol>




</dd>
    <dt>
    <a name = "path:fill"></a>
    <strong>path:fill&nbsp;()</strong>
    </dt>
    <dd>
    Path filling function.  Interpolates between non contiguous locations along a <a href="../modules/jumper.core.path.html#jumper.core.path">path</a>
 to build a fully continuous <a href="../modules/jumper.core.path.html#jumper.core.path">path</a> . This maybe useful when using <code>Jump Point Search</code> finder.
 Does the opposite of <a href="../modules/jumper.core.path.html#path:filter">path:filter</a>




    <h3>see also:</h3>
    <ul>
         <a href="../modules/jumper.core.path.html#path:filter">path:filter</a>
    </ul>


</dd>
    <dt>
    <a name = "path:filter"></a>
    <strong>path:filter&nbsp;()</strong>
    </dt>
    <dd>
    Path compression.  Given a <a href="../modules/jumper.core.path.html#jumper.core.path">path</a> , eliminates useless nodes to return a lighter <a href="../modules/jumper.core.path.html#jumper.core.path">path</a> . Does
 the opposite of <a href="../modules/jumper.core.path.html#path:fill">path:fill</a>




    <h3>see also:</h3>
    <ul>
         <a href="../modules/jumper.core.path.html#path:fill">path:fill</a>
    </ul>


</dd>
</dl>
    <h2><a name="Tables"></a>Tables</h2>

    <dl class="function">
    <dt>
    <a name = "path"></a>
    <strong>path</strong>
    </dt>
    <dd>
    The <a href="../modules/jumper.core.path.html#jumper.core.path">path</a>  class






</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.3</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Jumper documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Jumper(v1.8.1)</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
<li><a href="#Tables">Tables</a></li>
</ul>


<h2>Modules</h2>
<ul>
  <li><a href="../modules/jumper.core.bheap.html">jumper.core.bheap</a></li>
  <li><a href="../modules/jumper.core.heuristics.html">jumper.core.heuristics</a></li>
  <li><a href="../modules/jumper.core.node.html">jumper.core.node</a></li>
  <li><a href="../modules/jumper.core.path.html">jumper.core.path</a></li>
  <li><strong>jumper.grid</strong></li>
  <li><strong>jumper.grid</strong></li>
  <li><a href="../modules/jumper.pathfinder.html">jumper.pathfinder</a></li>
</ul>
<h2>Scripts</h2>
<ul>
  <li><a href="../scripts/jumper.search.astar.html">jumper.search.astar</a></li>
  <li><a href="../scripts/jumper.search.bfs.html">jumper.search.bfs</a></li>
  <li><a href="../scripts/jumper.search.dfs.html">jumper.search.dfs</a></li>
  <li><a href="../scripts/jumper.search.dijkstra.html">jumper.search.dijkstra</a></li>
  <li><a href="../scripts/jumper.search.jps.html">jumper.search.jps</a></li>
  <li><a href="../scripts/jumper.search.thetastar.html">jumper.search.thetastar</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>jumper.grid</code></h1>

<p><strong>The <code>grid</code> class API</strong>.</p>
<p> Implementation of a <a href="../modules/jumper.grid.html#jumper.grid">grid</a>  class, which represents the 2D map (graph) on which a <a href="../modules/jumper.grid.html#jumper.pathfinder">pathfinder</a>  will perform.</p>

<p> During a search, the pathfinder evaluates <strong>costs values</strong> for each node being processed, in order to
 select, after each step of iteration, what node should be expanded next to reach the target
 optimally. Those values are cached within an array of nodes inside the <a href="../modules/jumper.grid.html#jumper.grid">grid</a>  object.</p>
    <h3>Usage:</h3>
    <ul>
        <pre class="example">-- Usage Example
-- First, set a collision map
local map = {
	{0,1,0,1,0},
	{0,1,0,1,0},
	{0,1,1,1,0},
	{0,0,0,0,0},
}
-- Value for walkable tiles
local walkable = 0

-- Library setup
local Grid = require (&quot;jumper.grid&quot;) -- The grid class

-- Creates a grid object
local grid = Grid(map)
</pre>
    </ul>
    <h3>Info:</h3>
    <ul>
        <li><strong>Copyright</strong>: 2012-2013</li>
        <li><strong>License</strong>: <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a></li>
        <li><strong>Author</strong>: Roland Yonaba</li>
    </ul>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#grid:new">grid:new&nbsp;(map[, processOnDemand])</a></td>
	<td class="summary">Inits a new <a href="../modules/jumper.grid.html#jumper.grid">grid</a>  object</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#grid:isWalkableAt">grid:isWalkableAt&nbsp;(x, y, walkable)</a></td>
	<td class="summary">Checks walkability.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#grid:getWidth">grid:getWidth&nbsp;()</a></td>
	<td class="summary">Gets the <a href="../modules/jumper.grid.html#jumper.grid">grid</a>  width.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#grid:getHeight">grid:getHeight&nbsp;()</a></td>
	<td class="summary">Gets the <a href="../modules/jumper.grid.html#jumper.grid">grid</a>  height.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#grid:getMap">grid:getMap&nbsp;()</a></td>
	<td class="summary">Gets the collision map.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#grid:getNodes">grid:getNodes&nbsp;()</a></td>
	<td class="summary">Gets the <a href="../modules/jumper.grid.html#jumper.grid">grid</a>  nodes.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#grid:getNeighbours">grid:getNeighbours&nbsp;(node, walkable[, allowDiagonal[, tunnel]])</a></td>
	<td class="summary">Returns the neighbours of a given <code>node</code> on a <a href="../modules/jumper.grid.html#jumper.grid">grid</a> </td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#grid:iter">grid:iter&nbsp;([lx[, ly[, ex[, ey]]]])</a></td>
	<td class="summary">Iterates on nodes on the grid.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#grid:each">grid:each&nbsp;(f[, ...])</a></td>
	<td class="summary">Each transformation.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#grid:eachRange">grid:eachRange&nbsp;(lx, ly, ex, ey, f[, ...])</a></td>
	<td class="summary">Each in range transformation.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#grid:imap">grid:imap&nbsp;(f[, ...])</a></td>
	<td class="summary">Map transformation.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#grid:imapRange">grid:imapRange&nbsp;(lx, ly, ex, ey, f[, ...])</a></td>
	<td class="summary">Map in range transformation.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#grid:getNodeAt">grid:getNodeAt&nbsp;(x, y)</a></td>
	<td class="summary">Returns the <code>node</code>[x,y] on a <a href="../modules/jumper.grid.html#jumper.grid">grid</a> .</td>
	</tr>
</table>
<h2><a href="#Tables">Tables</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#grid">grid</a></td>
	<td class="summary">The <a href="../modules/jumper.grid.html#jumper.grid">grid</a>  class</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Functions"></a>Functions</h2>

    <dl class="function">
    <dt>
    <a name = "grid:new"></a>
    <strong>grid:new&nbsp;(map[, processOnDemand])</strong>
    </dt>
    <dd>
    Inits a new <a href="../modules/jumper.grid.html#jumper.grid">grid</a>  object

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">map</span>
        <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.5">table</a> or <a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
       A collision map - (2D array) with consecutive integer indices or a string with line-break symbol as a row delimiter.</li>
      <li><span class="parameter">processOnDemand</span>
        <span class="types"><span class="type">bool</span></span>
       whether or not caching nodes in the internal grid should be processed on-demand</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

          <span class="types"><a class="type" href="../modules/jumper.grid.html#jumper.grid">grid</a></span>
        a new <a href="../modules/jumper.grid.html#jumper.grid">grid</a>  object
    </ol>




</dd>
    <dt>
    <a name = "grid:isWalkableAt"></a>
    <strong>grid:isWalkableAt&nbsp;(x, y, walkable)</strong>
    </dt>
    <dd>
    Checks walkability.  Tests if <code>node</code> [x,y] exists on the collision map and is walkable

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">x</span>
        <span class="types"><span class="type">int</span></span>
       the x-coordinate of the node</li>
      <li><span class="parameter">y</span>
        <span class="types"><span class="type">int</span></span>
       the y-coordinate of the node</li>
      <li><span class="parameter">walkable</span>
        <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a>, <span class="type">int</span> or <span class="type">function</span></span>
       the value for walkable nodes on the passed-in map array.
 If this parameter is a function, it should be prototyped as <code>f(value)</code>, returning a boolean:
 <code>true</code> when value matches a <em>walkable</em> node, <code>false</code> otherwise. If this parameter is not given and
 node [x,y] exists, this function return <code>true</code>.</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">bool</span></span>
        <code>true</code> if the node exist and is walkable, <code>false</code> otherwise
    </ol>




</dd>
    <dt>
    <a name = "grid:getWidth"></a>
    <strong>grid:getWidth&nbsp;()</strong>
    </dt>
    <dd>
    Gets the <a href="../modules/jumper.grid.html#jumper.grid">grid</a>  width.


    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">int</span></span>
        the <a href="../modules/jumper.grid.html#jumper.grid">grid</a>  object width
    </ol>




</dd>
    <dt>
    <a name = "grid:getHeight"></a>
    <strong>grid:getHeight&nbsp;()</strong>
    </dt>
    <dd>
    Gets the <a href="../modules/jumper.grid.html#jumper.grid">grid</a>  height.


    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">int</span></span>
        the <a href="../modules/jumper.grid.html#jumper.grid">grid</a>  object height
    </ol>




</dd>
    <dt>
    <a name = "grid:getMap"></a>
    <strong>grid:getMap&nbsp;()</strong>
    </dt>
    <dd>
    Gets the collision map.


    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">{{value},...}</span></span>
        the collision map previously passed to the <a href="../modules/jumper.grid.html#jumper.grid">grid</a>  object on initalization
    </ol>




</dd>
    <dt>
    <a name = "grid:getNodes"></a>
    <strong>grid:getNodes&nbsp;()</strong>
    </dt>
    <dd>
    Gets the <a href="../modules/jumper.grid.html#jumper.grid">grid</a>  nodes.


    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">{{node},...}</span></span>
        the <a href="../modules/jumper.grid.html#jumper.grid">grid</a>  nodes
    </ol>




</dd>
    <dt>
    <a name = "grid:getNeighbours"></a>
    <strong>grid:getNeighbours&nbsp;(node, walkable[, allowDiagonal[, tunnel]])</strong>
    </dt>
    <dd>
    Returns the neighbours of a given <code>node</code> on a <a href="../modules/jumper.grid.html#jumper.grid">grid</a>

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">node</span>
        <span class="types"><span class="type">node</span></span>
       <code>node</code> object</li>
      <li><span class="parameter">walkable</span>
        <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a>, <span class="type">int</span> or <span class="type">function</span></span>
       the value for walkable nodes on the passed-in map array.
 If this parameter is a function, it should be prototyped as <code>f(value)</code>, returning a boolean:
 <code>true</code> when value matches a <em>walkable</em> node, <code>false</code> otherwise.</li>
      <li><span class="parameter">allowDiagonal</span>
        <span class="types"><span class="type">bool</span></span>
       whether or not adjacent nodes (8-directions moves) are allowed</li>
      <li><span class="parameter">tunnel</span>
        <span class="types"><span class="type">bool</span></span>
       Whether or not the pathfinder can tunnel though walls diagonally</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">{node,...}</span></span>
        an array of nodes neighbouring a passed-in node on the collision map
    </ol>




</dd>
    <dt>
    <a name = "grid:iter"></a>
    <strong>grid:iter&nbsp;([lx[, ly[, ex[, ey]]]])</strong>
    </dt>
    <dd>
    Iterates on nodes on the grid.  When given no args, will iterate on every single node
 on the grid, in case the grid is pre-processed. Passing <code>lx, ly, ex, ey</code> args will iterate
 on nodes inside a bounding-rectangle delimited by those coordinates.

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">lx</span>
        <span class="types"><span class="type">int</span></span>
       the leftmost x-coordinate coordinate of the rectangle</li>
      <li><span class="parameter">ly</span>
        <span class="types"><span class="type">int</span></span>
       the topmost y-coordinate of the rectangle</li>
      <li><span class="parameter">ex</span>
        <span class="types"><span class="type">int</span></span>
       the rightmost x-coordinate of the rectangle</li>
      <li><span class="parameter">ey</span>
        <span class="types"><span class="type">int</span></span>
       the bottom-most y-coordinate of the rectangle</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">node</span></span>
        a node on the collision map, upon each iteration step
    </ol>




</dd>
    <dt>
    <a name = "grid:each"></a>
    <strong>grid:each&nbsp;(f[, ...])</strong>
    </dt>
    <dd>
    Each transformation.  Executes a function on each <code>node</code> in the <a href="../modules/jumper.grid.html#jumper.grid">grid</a> , passing the <code>node</code> as the first arg to function <code>f</code>.

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">f</span>
        <span class="types"><span class="type">function</span></span>
       a function prototyped as <code>f(node,...)</code></li>
      <li><span class="parameter">...</span>
        <span class="types"><span class="type">vararg</span></span>
       args to be passed to function <code>f</code></li>
    </ul>





</dd>
    <dt>
    <a name = "grid:eachRange"></a>
    <strong>grid:eachRange&nbsp;(lx, ly, ex, ey, f[, ...])</strong>
    </dt>
    <dd>
    Each in range transformation.  Executes a function on each <code>node</code> in the range of a rectangle of cells, passing the <code>node</code> as the first arg to function <code>f</code>.

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">lx</span>
        <span class="types"><span class="type">int</span></span>
       the leftmost x-coordinate coordinate of the rectangle</li>
      <li><span class="parameter">ly</span>
        <span class="types"><span class="type">int</span></span>
       the topmost y-coordinate of the rectangle</li>
      <li><span class="parameter">ex</span>
        <span class="types"><span class="type">int</span></span>
       the rightmost x-coordinate of the rectangle</li>
      <li><span class="parameter">ey</span>
        <span class="types"><span class="type">int</span></span>
       the bottom-most y-coordinate of the rectangle</li>
      <li><span class="parameter">f</span>
        <span class="types"><span class="type">function</span></span>
       a function prototyped as <code>f(node,...)</code></li>
      <li><span class="parameter">...</span>
        <span class="types"><span class="type">vararg</span></span>
       args to be passed to function <code>f</code></li>
    </ul>





</dd>
    <dt>
    <a name = "grid:imap"></a>
    <strong>grid:imap&nbsp;(f[, ...])</strong>
    </dt>
    <dd>
    Map transformation.  Maps function <code>f(node,...)</code> on each <code>node</code> in a given range, passing the <code>node</code> as the first arg to function <code>f</code>. The passed-in function should return a <code>node</code> object.

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">f</span>
        <span class="types"><span class="type">function</span></span>
       a function prototyped as <code>f(node,...)</code></li>
      <li><span class="parameter">...</span>
        <span class="types"><span class="type">vararg</span></span>
       args to be passed to function <code>f</code></li>
    </ul>





</dd>
    <dt>
    <a name = "grid:imapRange"></a>
    <strong>grid:imapRange&nbsp;(lx, ly, ex, ey, f[, ...])</strong>
    </dt>
    <dd>
    Map in range transformation.  Maps <code>f(node,...)</code> on each <code>nod</code>e in the range of a rectangle of cells, passing the <code>node</code> as the first arg to function <code>f</code>. The passed-in function should return a <code>node</code> object.

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">lx</span>
        <span class="types"><span class="type">int</span></span>
       the leftmost x-coordinate coordinate of the rectangle</li>
      <li><span class="parameter">ly</span>
        <span class="types"><span class="type">int</span></span>
       the topmost y-coordinate of the rectangle</li>
      <li><span class="parameter">ex</span>
        <span class="types"><span class="type">int</span></span>
       the rightmost x-coordinate of the rectangle</li>
      <li><span class="parameter">ey</span>
        <span class="types"><span class="type">int</span></span>
       the bottom-most y-coordinate of the rectangle</li>
      <li><span class="parameter">f</span>
        <span class="types"><span class="type">function</span></span>
       a function prototyped as <code>f(node,...)</code></li>
      <li><span class="parameter">...</span>
        <span class="types"><span class="type">vararg</span></span>
       args to be passed to function <code>f</code></li>
    </ul>





</dd>
    <dt>
    <a name = "grid:getNodeAt"></a>
    <strong>grid:getNodeAt&nbsp;(x, y)</strong>
    </dt>
    <dd>
    Returns the <code>node</code>[x,y] on a <a href="../modules/jumper.grid.html#jumper.grid">grid</a> .

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">x</span>
        <span class="types"><span class="type">int</span></span>
       the x-coordinate coordinate</li>
      <li><span class="parameter">y</span>
        <span class="types"><span class="type">int</span></span>
       the y-coordinate coordinate</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">node</span></span>
        a <code>node</code> object
 Gets the node at location <x,y> on a preprocessed grid
    </ol>




</dd>
</dl>
    <h2><a name="Tables"></a>Tables</h2>

    <dl class="function">
    <dt>
    <a name = "grid"></a>
    <strong>grid</strong>
    </dt>
    <dd>
    The <a href="../modules/jumper.grid.html#jumper.grid">grid</a>  class

    <h3>Fields:</h3>
    <ul>
      <li><span class="parameter">width</span>
       The grid width</li>
      <li><span class="parameter">height</span>
       The grid height</li>
      <li><span class="parameter">map</span>
       A reference to the collision map</li>
      <li><span class="parameter">nodes</span>
       A 2D array of nodes, each node matching a cell on the collision map</li>
    </ul>





</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.3</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Jumper documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Jumper(v1.8.1)</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
<li><a href="#Tables">Tables</a></li>
</ul>


<h2>Modules</h2>
<ul>
  <li><a href="../modules/jumper.core.bheap.html">jumper.core.bheap</a></li>
  <li><a href="../modules/jumper.core.heuristics.html">jumper.core.heuristics</a></li>
  <li><a href="../modules/jumper.core.node.html">jumper.core.node</a></li>
  <li><a href="../modules/jumper.core.path.html">jumper.core.path</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><strong>jumper.pathfinder</strong></li>
</ul>
<h2>Scripts</h2>
<ul>
  <li><a href="../scripts/jumper.search.astar.html">jumper.search.astar</a></li>
  <li><a href="../scripts/jumper.search.bfs.html">jumper.search.bfs</a></li>
  <li><a href="../scripts/jumper.search.dfs.html">jumper.search.dfs</a></li>
  <li><a href="../scripts/jumper.search.dijkstra.html">jumper.search.dijkstra</a></li>
  <li><a href="../scripts/jumper.search.jps.html">jumper.search.jps</a></li>
  <li><a href="../scripts/jumper.search.thetastar.html">jumper.search.thetastar</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>jumper.pathfinder</code></h1>

<p><strong>The <strong>pathfinder</strong> class API</strong>.</p>
<p> Implementation of the <a href="../modules/jumper.pathfinder.html#jumper.pathfinder">pathfinder</a>  class.</p>
    <h3>Usage:</h3>
    <ul>
        <pre class="example">-- Usage Example
-- First, set a collision map
local map = {
	{0,1,0,1,0},
	{0,1,0,1,0},
	{0,1,1,1,0},
	{0,0,0,0,0},
}
-- Value for walkable tiles
local walkable = 0

-- Library setup
local Grid = require (&quot;jumper.grid&quot;) -- The grid class
local Pathfinder = require (&quot;jumper.pathfinder&quot;) -- The pathfinder lass

-- Creates a grid object
local grid = Grid(map)
-- Creates a pathfinder object using Jump Point Search
local myFinder = Pathfinder(grid, &apos;JPS&apos;, walkable)

-- Define start and goal locations coordinates
local startx, starty = 1,1
local endx, endy = 5,1

-- Calculates the path, and its length
local path, length = myFinder:getPath(startx, starty, endx, endy)
if path then
  print((&apos;Path found! Length: %.2f&apos;):format(length))
	for node, count in path:iter() do
	  print((&apos;Step: %d - x: %d - y: %d&apos;):format(count, node.x, node.y))
	end
end

--&gt; Output:
--&gt; Path found! Length: 8.83
--&gt; Step: 1 - x: 1 - y: 1
--&gt; Step: 2 - x: 1 - y: 3
--&gt; Step: 3 - x: 2 - y: 4
--&gt; Step: 4 - x: 4 - y: 4
--&gt; Step: 5 - x: 5 - y: 3
--&gt; Step: 6 - x: 5 - y: 1
</pre>
    </ul>
    <h3>Info:</h3>
    <ul>
        <li><strong>Copyright</strong>: 2012-2013</li>
        <li><strong>License</strong>: <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a></li>
        <li><strong>Author</strong>: Roland Yonaba</li>
    </ul>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#pathfinder:new">pathfinder:new&nbsp;(grid[, finderName[, walkable]])</a></td>
	<td class="summary">Inits a new <a href="../modules/jumper.pathfinder.html#jumper.pathfinder">pathfinder</a>  object</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#pathfinder:setGrid">pathfinder:setGrid&nbsp;(grid)</a></td>
	<td class="summary">Sets a <a href="../modules/jumper.pathfinder.html#jumper.grid">grid</a>  object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#pathfinder:getGrid">pathfinder:getGrid&nbsp;()</a></td>
	<td class="summary">Returns the <a href="../modules/jumper.pathfinder.html#jumper.grid">grid</a>  object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#pathfinder:setWalkable">pathfinder:setWalkable&nbsp;(walkable)</a></td>
	<td class="summary">Sets the <code>walkable</code> value or function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#pathfinder:getWalkable">pathfinder:getWalkable&nbsp;()</a></td>
	<td class="summary">Gets the <code>walkable</code> value or function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#pathfinder:setFinder">pathfinder:setFinder&nbsp;(finderName)</a></td>
	<td class="summary">Sets a finder.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#pathfinder:getFinder">pathfinder:getFinder&nbsp;()</a></td>
	<td class="summary">Gets the name of the finder being used.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#pathfinder:getFinders">pathfinder:getFinders&nbsp;()</a></td>
	<td class="summary">Gets the list of all available finders names.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#pathfinder:setHeuristic">pathfinder:setHeuristic&nbsp;(heuristic)</a></td>
	<td class="summary">Set a heuristic.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#pathfinder:getHeuristic">pathfinder:getHeuristic&nbsp;()</a></td>
	<td class="summary">Gets the heuristic used.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#pathfinder:getHeuristics">pathfinder:getHeuristics&nbsp;()</a></td>
	<td class="summary">Gets the list of all available heuristics.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#pathfinder:setMode">pathfinder:setMode&nbsp;(mode)</a></td>
	<td class="summary">Changes the search mode.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#pathfinder:getMode">pathfinder:getMode&nbsp;()</a></td>
	<td class="summary">Gets the search mode.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#pathfinder:getModes">pathfinder:getModes&nbsp;()</a></td>
	<td class="summary">Gets the list of all available search modes.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#pathfinder:version">pathfinder:version&nbsp;()</a></td>
	<td class="summary">Returns version and release date.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#pathfinder:getPath">pathfinder:getPath&nbsp;(startX, startY, endX, endY[, tunnel])</a></td>
	<td class="summary">Calculates a path.</td>
	</tr>
</table>
<h2><a href="#Tables">Tables</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#pathfinder">pathfinder</a></td>
	<td class="summary">The <a href="../modules/jumper.pathfinder.html#jumper.pathfinder">pathfinder</a>  class</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Functions"></a>Functions</h2>

    <dl class="function">
    <dt>
    <a name = "pathfinder:new"></a>
    <strong>pathfinder:new&nbsp;(grid[, finderName[, walkable]])</strong>
    </dt>
    <dd>
    Inits a new <a href="../modules/jumper.pathfinder.html#jumper.pathfinder">pathfinder</a>  object

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">grid</span>
        <span class="types"><a class="type" href="../modules/jumper.pathfinder.html#jumper.grid">grid</a></span>
       a <a href="../modules/jumper.pathfinder.html#jumper.grid">grid</a>  object</li>
      <li><span class="parameter">finderName</span>
        <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
       the name of the <code>finder</code> (search algorithm) to be used for further searches.
 Defaults to <code>ASTAR</code> when not given. Use <a href="../modules/jumper.pathfinder.html#pathfinder:getFinders">pathfinder:getFinders</a> to get the full list of available finders..</li>
      <li><span class="parameter">walkable</span>
        <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a>, <span class="type">int</span> or <span class="type">function</span></span>
       the value for walkable nodes on the passed-in map array.
 If this parameter is a function, it should be prototyped as <code>f(value)</code>, returning a boolean:
 <code>true</code> when value matches a <em>walkable</em> node, <code>false</code> otherwise.</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

          <span class="types"><a class="type" href="../modules/jumper.pathfinder.html#jumper.pathfinder">pathfinder</a></span>
        a new <a href="../modules/jumper.pathfinder.html#jumper.pathfinder">pathfinder</a>  object
    </ol>




</dd>
    <dt>
    <a name = "pathfinder:setGrid"></a>
    <strong>pathfinder:setGrid&nbsp;(grid)</strong>
    </dt>
    <dd>
    Sets a <a href="../modules/jumper.pathfinder.html#jumper.grid">grid</a>  object.  Defines the <a href="../modules/jumper.pathfinder.html#jumper.grid">grid</a>  on which the <a href="../modules/jumper.pathfinder.html#jumper.pathfinder">pathfinder</a>  will make path searches.

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">grid</span>
        <span class="types"><a class="type" href="../modules/jumper.pathfinder.html#jumper.grid">grid</a></span>
       a <a href="../modules/jumper.pathfinder.html#jumper.grid">grid</a>  object</li>
    </ul>





</dd>
    <dt>
    <a name = "pathfinder:getGrid"></a>
    <strong>pathfinder:getGrid&nbsp;()</strong>
    </dt>
    <dd>
    Returns the <a href="../modules/jumper.pathfinder.html#jumper.grid">grid</a>  object.  Returns a reference to the internal <a href="../modules/jumper.pathfinder.html#jumper.grid">grid</a>  object used by the <a href="../modules/jumper.pathfinder.html#jumper.pathfinder">pathfinder</a>  object.


    <h3>Returns:</h3>
    <ol>

          <span class="types"><a class="type" href="../modules/jumper.pathfinder.html#jumper.grid">grid</a></span>
        the <a href="../modules/jumper.pathfinder.html#jumper.grid">grid</a>  object
    </ol>




</dd>
    <dt>
    <a name = "pathfinder:setWalkable"></a>
    <strong>pathfinder:setWalkable&nbsp;(walkable)</strong>
    </dt>
    <dd>
    Sets the <code>walkable</code> value or function.

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">walkable</span>
        <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a>, <span class="type">int</span> or <span class="type">function</span></span>
       the value for walkable nodes on the passed-in map array.
 If this parameter is a function, it should be prototyped as <code>f(value)</code>, returning a boolean:
 <code>true</code> when value matches a <em>walkable</em> node, <code>false</code> otherwise.</li>
    </ul>





</dd>
    <dt>
    <a name = "pathfinder:getWalkable"></a>
    <strong>pathfinder:getWalkable&nbsp;()</strong>
    </dt>
    <dd>
    Gets the <code>walkable</code> value or function.


    <h3>Returns:</h3>
    <ol>

          <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a>, <span class="type">int</span> or <span class="type">function</span></span>
        the <code>walkable</code> previously set
    </ol>




</dd>
    <dt>
    <a name = "pathfinder:setFinder"></a>
    <strong>pathfinder:setFinder&nbsp;(finderName)</strong>
    </dt>
    <dd>
    Sets a finder.  The finder refers to the search algorithm used by the <a href="../modules/jumper.pathfinder.html#jumper.pathfinder">pathfinder</a>  object.
 The default finder is <code>ASTAR</code>. Use <a href="../modules/jumper.pathfinder.html#pathfinder:getFinders">pathfinder:getFinders</a> to get the list of available finders.

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">finderName</span>
        <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
       the name of the finder to be used for further searches.</li>
    </ul>



    <h3>see also:</h3>
    <ul>
         <a href="../modules/jumper.pathfinder.html#pathfinder:getFinders">pathfinder:getFinders</a>
    </ul>


</dd>
    <dt>
    <a name = "pathfinder:getFinder"></a>
    <strong>pathfinder:getFinder&nbsp;()</strong>
    </dt>
    <dd>
    Gets the name of the finder being used.  The finder refers to the search algorithm used by the <a href="../modules/jumper.pathfinder.html#jumper.pathfinder">pathfinder</a>  object.


    <h3>Returns:</h3>
    <ol>

          <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        the name of the finder to be used for further searches.
    </ol>




</dd>
    <dt>
    <a name = "pathfinder:getFinders"></a>
    <strong>pathfinder:getFinders&nbsp;()</strong>
    </dt>
    <dd>
    Gets the list of all available finders names.


    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">{string,...}</span></span>
        array of finders names.
    </ol>




</dd>
    <dt>
    <a name = "pathfinder:setHeuristic"></a>
    <strong>pathfinder:setHeuristic&nbsp;(heuristic)</strong>
    </dt>
    <dd>
    Set a heuristic.  This is a function internally used by the <a href="../modules/jumper.pathfinder.html#jumper.pathfinder">pathfinder</a>  to get the optimal path during a search.
 Use <a href="../modules/jumper.pathfinder.html#pathfinder:getHeuristics">pathfinder:getHeuristics</a> to get the list of all available heuristics. One can also defined
 his own heuristic function.

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">heuristic</span>
        <span class="types"><span class="type">function</span> or <a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
       a heuristic function, prototyped as <code>f(dx,dy)</code> or a string.</li>
    </ul>



    <h3>see also:</h3>
    <ul>
         <a href="../modules/jumper.pathfinder.html#pathfinder:getHeuristics">pathfinder:getHeuristics</a>
    </ul>


</dd>
    <dt>
    <a name = "pathfinder:getHeuristic"></a>
    <strong>pathfinder:getHeuristic&nbsp;()</strong>
    </dt>
    <dd>
    Gets the heuristic used.  Returns the function itself.


    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">function</span></span>
        the heuristic function being used by the <a href="../modules/jumper.pathfinder.html#jumper.pathfinder">pathfinder</a>  object
    </ol>




</dd>
    <dt>
    <a name = "pathfinder:getHeuristics"></a>
    <strong>pathfinder:getHeuristics&nbsp;()</strong>
    </dt>
    <dd>
    Gets the list of all available heuristics.


    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">{string,...}</span></span>
        array of heuristic names.
    </ol>




</dd>
    <dt>
    <a name = "pathfinder:setMode"></a>
    <strong>pathfinder:setMode&nbsp;(mode)</strong>
    </dt>
    <dd>
    Changes the search mode.  Defines a new search mode for the <a href="../modules/jumper.pathfinder.html#jumper.pathfinder">pathfinder</a>  object.
 The default search mode is <code>DIAGONAL</code>, which implies 8-possible directions when moving (north, south, east, west and diagonals).
 In <code>ORTHOGONAL</code> mode, only 4-directions are allowed (north, south, east and west).
 Use <a href="../modules/jumper.pathfinder.html#pathfinder:getModes">pathfinder:getModes</a> to get the list of all available search modes.

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">mode</span>
        <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
       the new search mode.</li>
    </ul>



    <h3>see also:</h3>
    <ul>
         <a href="../modules/jumper.pathfinder.html#pathfinder:getModes">pathfinder:getModes</a>
    </ul>


</dd>
    <dt>
    <a name = "pathfinder:getMode"></a>
    <strong>pathfinder:getMode&nbsp;()</strong>
    </dt>
    <dd>
    Gets the search mode.


    <h3>Returns:</h3>
    <ol>

          <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        the current search mode
    </ol>




</dd>
    <dt>
    <a name = "pathfinder:getModes"></a>
    <strong>pathfinder:getModes&nbsp;()</strong>
    </dt>
    <dd>
    Gets the list of all available search modes.


    <h3>Returns:</h3>
    <ol>

          <span class="types"><span class="type">{string,...}</span></span>
        array of search modes.
    </ol>




</dd>
    <dt>
    <a name = "pathfinder:version"></a>
    <strong>pathfinder:version&nbsp;()</strong>
    </dt>
    <dd>
    Returns version and release date.


    <h3>Returns:</h3>
    <ol>
        <li>
          <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        the version of the current implementation</li>
        <li>
          <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        the release of the current implementation</li>
    </ol>




</dd>
    <dt>
    <a name = "pathfinder:getPath"></a>
    <strong>pathfinder:getPath&nbsp;(startX, startY, endX, endY[, tunnel])</strong>
    </dt>
    <dd>
    Calculates a path.  Returns the path from location <code>&lt;startX, startY&gt;</code> to location <code>&lt;endX, endY&gt;</code>.
 Both locations must exist on the collision map.

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">startX</span>
        <span class="types"><span class="type">number</span></span>
       the x-coordinate for the starting location</li>
      <li><span class="parameter">startY</span>
        <span class="types"><span class="type">number</span></span>
       the y-coordinate for the starting location</li>
      <li><span class="parameter">endX</span>
        <span class="types"><span class="type">number</span></span>
       the x-coordinate for the goal location</li>
      <li><span class="parameter">endY</span>
        <span class="types"><span class="type">number</span></span>
       the y-coordinate for the goal location</li>
      <li><span class="parameter">tunnel</span>
        <span class="types"><span class="type">bool</span></span>
       Whether or not the pathfinder can tunnel though walls diagonally (not compatible with <code>Jump Point Search</code>)</li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
          <span class="types"><span class="type">{node,...}</span></span>
        a path (array of <code>nodes</code>) when found, otherwise <code>nil</code></li>
        <li>
          <span class="types"><span class="type">number</span></span>
        the path length when found, <code>0</code> otherwise</li>
    </ol>




</dd>
</dl>
    <h2><a name="Tables"></a>Tables</h2>

    <dl class="function">
    <dt>
    <a name = "pathfinder"></a>
    <strong>pathfinder</strong>
    </dt>
    <dd>
    The <a href="../modules/jumper.pathfinder.html#jumper.pathfinder">pathfinder</a>  class






</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.3</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Jumper documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Jumper(v1.8.1)</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Scripts</h2>
<ul>
  <li><strong>jumper.search.astar</strong></li>
  <li><a href="../scripts/jumper.search.bfs.html">jumper.search.bfs</a></li>
  <li><a href="../scripts/jumper.search.dfs.html">jumper.search.dfs</a></li>
  <li><a href="../scripts/jumper.search.dijkstra.html">jumper.search.dijkstra</a></li>
  <li><a href="../scripts/jumper.search.jps.html">jumper.search.jps</a></li>
  <li><a href="../scripts/jumper.search.thetastar.html">jumper.search.thetastar</a></li>
</ul>
<h2>Modules</h2>
<ul>
  <li><a href="../modules/jumper.core.bheap.html">jumper.core.bheap</a></li>
  <li><a href="../modules/jumper.core.heuristics.html">jumper.core.heuristics</a></li>
  <li><a href="../modules/jumper.core.node.html">jumper.core.node</a></li>
  <li><a href="../modules/jumper.core.path.html">jumper.core.path</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.pathfinder.html">jumper.pathfinder</a></li>
</ul>

</div>

<div id="content">

<h1>Script <code>jumper.search.astar</code></h1>

<p><strong><code>A-star</code> algorithm</strong>.</p>
<p> Implementation of <a href="http://en.wikipedia.org/wiki/A-star">A*</a> search algorithm.</p>
    <h3>Info:</h3>
    <ul>
        <li><strong>Copyright</strong>: 2012-2013</li>
        <li><strong>License</strong>: <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a></li>
        <li><strong>Author</strong>: Roland Yonaba</li>
    </ul>



<br/>
<br/>




</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.3</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Jumper documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div 1)</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Scripts</h2>
<ul>
  <li><a href="../scripts/jumper.search.astar.html">jumper.search.astar</a></li>
  <li><strong>jumper.search.bfs</strong></li>
  <li><a href="../scripts/jumper.search.dfs.html">jumper.search.dfs</a></li>
  <li><a href="../scripts/jumper.search.dijkstra.html">jumper.search.dijkstra</a></li>
  <li><a href="../scripts/jumper.search.jps.html">jumper.se×D                                                                      arch.jps</a></li>
  <li><a href="../scripts/jumper.search.thetastar.html">jumper.search.thetastar</a></li>
</ul>
<h2>Modules</h2>
<ul>
  <li><a href="../modules/jumper.core.bheap.html">jumper.core.bheap</a></li>
  <li><a href="../modules/jumper.core.heuristics.html">jumper.core.heuristics</a></li>
  <li><a href="../modules/jumper.core.node.html">jumper.core.node</a></li>
  <li><a href="../modules/jumper.core.path.html">jumper.core.path</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.pathfinder.html">jumper.pathfinder</a></li>
</ul>

</div>

<div id="content">

<h1>Script <code>jumper.search.bfs</code></h1>

<p><strong><code>Breadth-First Search</code> algorithm</strong>.</p>
<p> Implementation of <a href="http://en.wikipedia.org/wiki/Breadth-first_search">Breadth-First Search</a> search algorithm.</p>
    <h3>Info:</h3>
    <ul>
        <li><strong>Copyright</strong>: 2012-2013</li>
        <li><strong>License</strong>: <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a></li>
        <li><strong>Author</strong>: Roland Yonaba</li>
    </ul>



<br/>
<br/>




</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.3</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Jumper documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Jumper(v1.8.1)</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Scripts</h2>
<ul>
  <li><a href="../scripts/jumper.search.astar.html">jumper.search.astar</a></li>
  <li><a href="../scripts/jumper.search.bfs.html">jumper.search.bfs</a></li>
  <li><strong>jumper.search.dfs</strong></li>
  <li><a href="../scripts/jumper.search.dijkstra.html">jumper.search.dijkstra</a></li>
  <li><a href="../scripts/jumper.search.jps.html">jumper.search.jps</a></li>
  <li><a href="../scripts/jumper.search.thetastar.html">jumper.search.thetastar</a></li>
</ul>
<h2>Modules</h2>
<ul>
  <li><a href="../modules/jumper.core.bheap.html">jumper.core.bheap</a></li>
  <li><a href="../modules/jumper.core.heuristics.html">jumper.core.heuristics</a></li>
  <li><a href="../modules/jumper.core.node.html">jumper.core.node</a></li>
  <li><a href="../modules/jumper.core.path.html">jumper.core.path</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.pathfinder.html">jumper.pathfinder</a></li>
</ul>

</div>

<div id="content">

<h1>Script <code>jumper.search.dfs</code></h1>

<p><strong><code>Depth First Search</code> algorithm</strong>.</p>
<p> Implementation of <a href="http://en.wikipedia.org/wiki/Depth-first_search">Depth First Search</a> search algorithm.</p>
    <h3>Info:</h3>
    <ul>
        <li><strong>Copyright</strong>: 2012-2013</li>
        <li><strong>License</strong>: <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a></li>
        <li><strong>Author</strong>: Roland Yonaba</li>
    </ul>



<br/>
<br/>




</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.3</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Jumper documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Jumper(v1.8.1)</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Scripts</h2>
<ul>
  <li><a href="../scripts/jumper.search.astar.html">jumper.search.astar</a></li>
  <li><a href="../scripts/jumper.search.bfs.html">jumper.search.bfs</a></li>
  <li><a href="../scripts/jumper.search.dfs.html">jumper.search.dfs</a></li>
  <li><strong>jumper.search.dijkstra</strong></li>
  <li><a href="../scripts/jumper.search.jps.html">jumper.search.jps</a></li>
  <li><a href="../scripts/jumper.search.thetastar.html">jumper.search.thetastar</a></li>
</ul>
<h2>Modules</h2>
<ul>
  <li><a href="../modules/jumper.core.bheap.html">jumper.core.bheap</a></li>
  <li><a href="../modules/jumper.core.heuristics.html">jumper.core.heuristics</a></li>
  <li><a href="../modules/jumper.core.node.html">jumper.core.node</a></li>
  <li><a href="../modules/jumper.core.path.html">jumper.core.path</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.pathfinder.html">jumper.pathfinder</a></li>
</ul>

</div>

<div id="content">

<h1>Script <code>jumper.search.dijkstra</code></h1>

<p><strong><code>Dijkstra</code> algorithm</strong>.</p>
<p> Implementation of <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra</a> search algorithm</p>
    <h3>Info:</h3>
    <ul>
        <li><strong>Copyright</strong>: 2012-2013</li>
        <li><strong>License</strong>: <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a></li>
        <li><strong>Author</strong>: Roland Yonaba</li>
    </ul>



<br/>
<br/>




</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.3</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Jumper documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Jumper(v1.8.1)</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Scripts</h2>
<ul>
  <li><a href="../scripts/jumper.search.astar.html">jumper.search.astar</a></li>
  <li><a href="../scripts/jumper.search.bfs.html">jumper.search.bfs</a></li>
  <li><a href="../scripts/jumper.search.dfs.html">jumper.search.dfs</a></li>
  <li><a href="../scripts/jumper.search.dijkstra.html">jumper.search.dijkstra</a></li>
  <li><strong>jumper.search.jps</strong></li>
  <li><a href="../scripts/jumper.search.thetastar.html">jumper.search.thetastar</a></li>
</ul>
<h2>Modules</h2>
<ul>
  <li><a href="../modules/jumper.core.bheap.html">jumper.core.bheap</a></li>
  <li><a href="../modules/jumper.core.heuristics.html">jumper.core.heuristics</a></li>
  <li><a href="../modules/jumper.core.node.html">jumper.core.node</a></li>
  <li><a href="../modules/jumper.core.path.html">jumper.core.path</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.pathfinder.html">jumper.pathfinder</a></li>
</ul>

</div>

<div id="content">

<h1>Script <code>jumper.search.jps</code></h1>

<p><strong><code>Jump Point Search</code> algorithm</strong>.</p>
<p> This file holds an implementation of <a href="http://harablog.wordpress.com/2011/09/07/jump-point-search/">Jump Point Search</a> algorithm.
 To quote its authors, <strong>Jump Point Search</strong> is basically
 "<em>an online symmetry breaking algorithm which speeds up pathfinding
 on uniform-cost grid maps by <strong>jumping over</strong> many locations that would otherwise
 need to be explicitly considered</em> ".</p>

<p> It neither requires preprocessing, nor generates memory overhead, and thus performs consistently fast than classical A*.</p>

<p> The following implementation was written with respect to the core pseudo-code given in
 its <a href="http://users.cecs.anu.edu.au/~dharabor/data/papers/harabor-grastien-aaai11.pdf">
 technical papers,</a> plus a wide
 range of optimizations and additional features.</p>
    <h3>Info:</h3>
    <ul>
        <li><strong>Copyright</strong>: 2012-2013</li>
        <li><strong>License</strong>: <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a></li>
        <li><strong>Author</strong>: Roland Yonaba</li>
    </ul>



<br/>
<br/>




</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.3</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Jumper documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Jumper(v1.8.1)</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Scripts</h2>
<ul>
  <li><a href="../scripts/jumper.search.astar.html">jumper.search.astar</a></li>
  <li><a href="../scripts/jumper.search.bfs.html">jumper.search.bfs</a></li>
  <li><a href="../scripts/jumper.search.dfs.html">jumper.search.dfs</a></li>
  <li><a href="../scripts/jumper.search.dijkstra.html">jumper.search.dijkstra</a></li>
  <li><a href="../scripts/jumper.search.jps.html">jumper.search.jps</a></li>
  <li><strong>jumper.search.thetastar</strong></li>
</ul>
<h2>Modules</h2>
<ul>
  <li><a href="../modules/jumper.core.bheap.html">jumper.core.bheap</a></li>
  <li><a href="../modules/jumper.core.heuristics.html">jumper.core.heuristics</a></li>
  <li><a href="../modules/jumper.core.node.html">jumper.core.node</a></li>
  <li><a href="../modules/jumper.core.path.html">jumper.core.path</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.grid.html">jumper.grid</a></li>
  <li><a href="../modules/jumper.pathfinder.html">jumper.pathfinder</a></li>
</ul>

</div>

<div id="content">

<h1>Script <code>jumper.search.thetastar</code></h1>

<p><strong><code>Theta-star</code> algorithm</strong>.</p>
<p> Implementation of <a href="http://aigamedev.com/open/tutorials/theta-star-any-angle-paths">Theta star</a> search algorithm.</p>
    <h3>Info:</h3>
    <ul>
        <li><strong>Copyright</strong>: 2012-2013</li>
        <li><strong>License</strong>: <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a></li>
        <li><strong>Author</strong>: Roland Yonaba</li>
    </ul>



<br/>
<br/>




</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.3</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
--- The Grid class.
-- Implementation of the `grid` class.
-- The `grid` is a implicit graph which represents the 2D
-- world map layout on which the `pathfinder` object will run.
-- During a search, the `pathfinder` object needs to save some critical values. These values are cached within each `node`
-- object, and the whole set of nodes are tight inside the `grid` object itself.

if (...) then

	-- Dependencies
  local _PATH = (...):gsub('%.grid$','')

	-- Local references
  local Utils = require (_PATH .. '.core.utils')
  local Assert = require (_PATH .. '.core.assert')
  local Node = require (_PATH .. '.core.node')

	-- Local references
  local pairs = pairs
  local assert = assert
  local next = next
	local setmetatable = setmetatable
  local floor = math.floor
	local coroutine = coroutine

  -- Offsets for straights moves
  local straightOffsets = {
    {x = 1, y = 0} --[[W]], {x = -1, y =  0}, --[[E]]
    {x = 0, y = 1} --[[S]], {x =  0, y = -1}, --[[N]]
  }

  -- Offsets for diagonal moves
  local diagonalOffsets = {
    {x = -1, y = -1} --[[NW]], {x = 1, y = -1}, --[[NE]]
    {x = -1, y =  1} --[[SW]], {x = 1, y =  1}, --[[SE]]
  }

	--- The `Grid` class.<br/>
	-- This class is callable.
	-- Therefore,_ <code>Grid(...)</code> _acts as a shortcut to_ <code>Grid:new(...)</code>.
	-- @type Grid
  local Grid = {}
  Grid.__index = Grid

  -- Specialized grids
  local PreProcessGrid = setmetatable({},Grid)
  local PostProcessGrid = setmetatable({},Grid)
  PreProcessGrid.__index = PreProcessGrid
  PostProcessGrid.__index = PostProcessGrid
  PreProcessGrid.__call = function (self,x,y)
    return self:getNodeAt(x,y)
  end
  PostProcessGrid.__call = function (self,x,y,create)
    if create then return self:getNodeAt(x,y) end
    return self._nodes[y] and self._nodes[y][x]
  end

  --- Inits a new `grid`
  -- @class function
  -- @tparam table|string map A collision map - (2D array) with consecutive indices (starting at 0 or 1)
	-- or a `string` with line-break chars (<code>\n</code> or <code>\r</code>) as row delimiters.
  -- @tparam[opt] bool cacheNodeAtRuntime When __true__, returns an empty `grid` instance, so that
	-- later on, indexing a non-cached `node` will cause it to be created and cache within the `grid` on purpose (i.e, when needed).
	-- This is a __memory-safe__ option, in case your dealing with some tight memory constraints.
	-- Defaults to __false__ when omitted.
  -- @treturn grid a new `grid` instance
	-- @usage
	-- -- A simple 3x3 grid
	-- local myGrid = Grid:new({{0,0,0},{0,0,0},{0,0,0}})
	--
	-- -- A memory-safe 3x3 grid
	-- myGrid = Grid('000\n000\n000', true)
  function Grid:new(map, cacheNodeAtRuntime)
		if type(map) == 'string' then
			assert(Assert.isStrMap(map), 'Wrong argument #1. Not a valid string map')
			map = Utils.strToMap(map)
		end
    assert(Assert.isMap(map),('Bad argument #1. Not a valid map'))
    assert(Assert.isBool(cacheNodeAtRuntime) or Assert.isNil(cacheNodeAtRuntime),
      ('Bad argument #2. Expected \'boolean\', got %s.'):format(type(cacheNodeAtRuntime)))
    if cacheNodeAtRuntime then
      return PostProcessGrid:new(map,walkable)
    end
    return PreProcessGrid:new(map,walkable)
  end

  --- Checks if `node` at [x,y] is __walkable__.
	-- Will check if `node` at location [x,y] both *exists* on the collision map and *is walkable*
  -- @class function
  -- @tparam int x the x-location of the node
  -- @tparam int y the y-location of the node
  -- @tparam[opt] string|int|func walkable the value for walkable locations in the collision map array (see @{Grid:new}).
	-- Defaults to __false__ when omitted.
  -- If this parameter is a function, it should be prototyped as __f(value)__ and return a `boolean`:
  -- __true__ when value matches a __walkable__ `node`, __false__ otherwise. If this parameter is not given
  -- while location [x,y] __is valid__, this actual function returns __true__.
  -- @tparam[optchain] int clearance the amount of clearance needed. Defaults to 1 (normal clearance) when not given.
  -- @treturn bool __true__ if `node` exists and is __walkable__, __false__ otherwise
	-- @usage
	-- -- Always true
	-- print(myGrid:isWalkableAt(2,3))
	--
	-- -- True if node at [2,3] collision map value is 0
	-- print(myGrid:isWalkableAt(2,3,0))
	--
	-- -- True if node at [2,3] collision map value is 0 and has a clearance higher or equal to 2
	-- print(myGrid:isWalkableAt(2,3,0,2))
	--
  function Grid:isWalkableAt(x, y, walkable, clearance)
    local nodeValue = self._map[y] and self._map[y][x]
    if nodeValue then
      if not walkable then return true end
    else
			return false
    end
		local hasEnoughClearance = not clearance and true or false
		if not hasEnoughClearance then
			if not self._isAnnotated[walkable] then return false end
			local node = self:getNodeAt(x,y)
			local nodeClearance = node:getClearance(walkable)
			hasEnoughClearance = (nodeClearance >= clearance)
		end
    if self._eval then
			return walkable(nodeValue) and hasEnoughClearance
		end
    return ((nodeValue == walkable) and hasEnoughClearance)
  end

  --- Returns the `grid` width.
  -- @class function
  -- @treturn int the `grid` width
	-- @usage print(myGrid:getWidth())
  function Grid:getWidth()
    return self._width
  end

  --- Returns the `grid` height.
  -- @class function
  -- @treturn int the `grid` height
	-- @usage print(myGrid:getHeight())
  function Grid:getHeight()
     return self._height
  end

  --- Returns the collision map.
  -- @class function
  -- @treturn map the collision map (see @{Grid:new})
	-- @usage local map = myGrid:getMap()
  function Grid:getMap()
    return self._map
  end

  --- Returns the set of nodes.
  -- @class function
  -- @treturn {{node,...},...} an array of nodes
	-- @usage local nodes = myGrid:getNodes()
  function Grid:getNodes()
    return self._nodes
  end

  --- Returns the `grid` bounds. Returned values corresponds to the upper-left
	-- and lower-right coordinates (in tile units) of the actual `grid` instance.
  -- @class function
  -- @treturn int the upper-left corner x-coordinate
  -- @treturn int the upper-left corner y-coordinate
  -- @treturn int the lower-right corner x-coordinate
  -- @treturn int the lower-right corner y-coordinate
	-- @usage local left_x, left_y, right_x, right_y = myGrid:getBounds()
	function Grid:getBounds()
		return self._min_x, self._min_y,self._max_x, self._max_y
	end

  --- Returns neighbours. The returned value is an array of __walkable__ nodes neighbouring a given `node`.
  -- @class function
  -- @tparam node node a given `node`
  -- @tparam[opt] string|int|func walkable the value for walkable locations in the collision map array (see @{Grid:new}).
	-- Defaults to __false__ when omitted.
  -- @tparam[optchain] bool allowDiagonal when __true__, allows adjacent nodes are included (8-neighbours).
	-- Defaults to __false__ when omitted.
  -- @tparam[optchain] bool tunnel When __true__, allows the `pathfinder` to tunnel through walls when heading diagonally.
  -- @tparam[optchain] int clearance When given, will prune for the neighbours set all nodes having a clearance value lower than the passed-in value
	-- Defaults to __false__ when omitted.
  -- @treturn {node,...} an array of nodes neighbouring a given node
	-- @usage
	-- local aNode = myGrid:getNodeAt(5,6)
	-- local neighbours = myGrid:getNeighbours(aNode, 0, true)
  function Grid:getNeighbours(node, walkable, allowDiagonal, tunnel, clearance)
		local neighbours = {}
    for i = 1,#straightOffsets do
      local n = self:getNodeAt(
        node._x + straightOffsets[i].x,
        node._y + straightOffsets[i].y
      )
      if n and self:isWalkableAt(n._x, n._y, walkable, clearance) then
        neighbours[#neighbours+1] = n
      end
    end

    if not allowDiagonal then return neighbours end

		tunnel = not not tunnel
    for i = 1,#diagonalOffsets do
      local n = self:getNodeAt(
        node._x + diagonalOffsets[i].x,
        node._y + diagonalOffsets[i].y
      )
      if n and self:isWalkableAt(n._x, n._y, walkable, clearance) then
				if tunnel then
					neighbours[#neighbours+1] = n
				else
					local skipThisNode = false
					local n1 = self:getNodeAt(node._x+diagonalOffsets[i].x, node._y)
					local n2 = self:getNodeAt(node._x, node._y+diagonalOffsets[i].y)
					if ((n1 and n2) and not self:isWalkableAt(n1._x, n1._y, walkable, clearance) and not self:isWalkableAt(n2._x, n2._y, walkable, clearance)) then
						skipThisNode = true
					end
					if not skipThisNode then neighbours[#neighbours+1] = n end
				end
      end
    end

    return neighbours
  end

  --- Grid iterator. Iterates on every single node
  -- in the `grid`. Passing __lx, ly, ex, ey__ arguments will iterate
  -- only on nodes inside the bounding-rectangle delimited by those given coordinates.
  -- @class function
  -- @tparam[opt] int lx the leftmost x-coordinate of the rectangle. Default to the `grid` leftmost x-coordinate (see @{Grid:getBounds}).
  -- @tparam[optchain] int ly the topmost y-coordinate of the rectangle. Default to the `grid` topmost y-coordinate (see @{Grid:getBounds}).
  -- @tparam[optchain] int ex the rightmost x-coordinate of the rectangle. Default to the `grid` rightmost x-coordinate (see @{Grid:getBounds}).
  -- @tparam[optchain] int ey the bottom-most y-coordinate of the rectangle. Default to the `grid` bottom-most y-coordinate (see @{Grid:getBounds}).
  -- @treturn node a `node` on the collision map, upon each iteration step
  -- @treturn int the iteration count
	-- @usage
	-- for node, count in myGrid:iter() do
	--   print(node:getX(), node:getY(), count)
	-- end
  function Grid:iter(lx,ly,ex,ey)
    local min_x = lx or self._min_x
    local min_y = ly or self._min_y
    local max_x = ex or self._max_x
    local max_y = ey or self._max_y

    local x, y
    y = min_y
    return function()
      x = not x and min_x or x+1
      if x > max_x then
        x = min_x
        y = y+1
      end
      if y > max_y then
        y = nil
      end
      return self._nodes[y] and self._nodes[y][x] or self:getNodeAt(x,y)
    end
  end

	--- Grid iterator. Iterates on each node along the outline (border) of a squared area
	-- centered on the given node.
	-- @tparam node node a given `node`
	-- @tparam[opt] int radius the area radius (half-length). Defaults to __1__ when not given.
	-- @treturn node a `node` at each iteration step
	-- @usage
	-- for node in myGrid:around(node, 2) do
	--   ...
	-- end
	function Grid:around(node, radius)
		local x, y = node._x, node._y
		radius = radius or 1
		local _around = Utils.around()
		local _nodes = {}
		repeat
			local state, x, y = coroutine.resume(_around,x,y,radius)
			local nodeAt = state and self:getNodeAt(x, y)
			if nodeAt then _nodes[#_nodes+1] = nodeAt end
		until (not state)
		local _i = 0
		return function()
			_i = _i+1
			return _nodes[_i]
		end
	end

  --- Each transformation. Calls the given function on each `node` in the `grid`,
	-- passing the `node` as the first argument to function __f__.
  -- @class function
  -- @tparam func f a function prototyped as __f(node,...)__
  -- @tparam[opt] vararg ... args to be passed to function __f__
	-- @treturn grid self (the calling `grid` itself, can be chained)
	-- @usage
	-- local function printNode(node)
	--   print(node:getX(), node:getY())
	-- end
	-- myGrid:each(printNode)
  function Grid:each(f,...)
    for node in self:iter() do f(node,...) end
		return self
  end

  --- Each (in range) transformation. Calls a function on each `node` in the range of a rectangle of cells,
	-- passing the `node` as the first argument to function __f__.
  -- @class function
  -- @tparam int lx the leftmost x-coordinate coordinate of the rectangle
  -- @tparam int ly the topmost y-coordinate of the rectangle
  -- @tparam int ex the rightmost x-coordinate of the rectangle
  -- @tparam int ey the bottom-most y-coordinate of the rectangle
  -- @tparam func f a function prototyped as __f(node,...)__
  -- @tparam[opt] vararg ... args to be passed to function __f__
	-- @treturn grid self (the calling `grid` itself, can be chained)
	-- @usage
	-- local function printNode(node)
	--   print(node:getX(), node:getY())
	-- end
	-- myGrid:eachRange(1,1,8,8,printNode)
  function Grid:eachRange(lx,ly,ex,ey,f,...)
    for node in self:iter(lx,ly,ex,ey) do f(node,...) end
		return self
  end

  --- Map transformation.
	-- Calls function __f(node,...)__ on each `node` in a given range, passing the `node` as the first arg to function __f__ and replaces
	-- it with the returned value. Therefore, the function should return a `node`.
  -- @class function
  -- @tparam func f a function prototyped as __f(node,...)__
  -- @tparam[opt] vararg ... args to be passed to function __f__
	-- @treturn grid self (the calling `grid` itself, can be chained)
	-- @usage
	-- local function nothing(node)
	--   return node
	-- end
	-- myGrid:imap(nothing)
  function Grid:imap(f,...)
    for node in self:iter() do
      node = f(node,...)
    end
		return self
  end

  --- Map in range transformation.
	-- Calls function __f(node,...)__ on each `node` in a rectangle range, passing the `node` as the first argument to the function and replaces
	-- it with the returned value. Therefore, the function should return a `node`.
	-- @class function
  -- @tparam int lx the leftmost x-coordinate coordinate of the rectangle
  -- @tparam int ly the topmost y-coordinate of the rectangle
  -- @tparam int ex the rightmost x-coordinate of the rectangle
  -- @tparam int ey the bottom-most y-coordinate of the rectangle
  -- @tparam func f a function prototyped as __f(node,...)__
  -- @tparam[opt] vararg ... args to be passed to function __f__
	-- @treturn grid self (the calling `grid` itself, can be chained)
	-- @usage
	-- local function nothing(node)
	--   return node
	-- end
	-- myGrid:imap(1,1,6,6,nothing)
  function Grid:imapRange(lx,ly,ex,ey,f,...)
    for node in self:iter(lx,ly,ex,ey) do
      node = f(node,...)
    end
		return self
  end

  -- Specialized grids
  -- Inits a preprocessed grid
  function PreProcessGrid:new(map)
    local newGrid = {}
    newGrid._map = map
    newGrid._nodes, newGrid._min_x, newGrid._max_x, newGrid._min_y, newGrid._max_y = Utils.arrayToNodes(newGrid._map)
    newGrid._width = (newGrid._max_x-newGrid._min_x)+1
    newGrid._height = (newGrid._max_y-newGrid._min_y)+1
		newGrid._isAnnotated = {}
    return setmetatable(newGrid,PreProcessGrid)
  end

  -- Inits a postprocessed grid
  function PostProcessGrid:new(map)
    local newGrid = {}
    newGrid._map = map
    newGrid._nodes = {}
    newGrid._min_x, newGrid._max_x, newGrid._min_y, newGrid._max_y = Utils.getArrayBounds(newGrid._map)
    newGrid._width = (newGrid._max_x-newGrid._min_x)+1
    newGrid._height = (newGrid._max_y-newGrid._min_y)+1
		newGrid._isAnnotated = {}		
    return setmetatable(newGrid,PostProcessGrid)
  end

  --- Returns the `node` at location [x,y].
  -- @class function
  -- @name Grid:getNodeAt
  -- @tparam int x the x-coordinate coordinate
  -- @tparam int y the y-coordinate coordinate
  -- @treturn node a `node`
	-- @usage local aNode = myGrid:getNodeAt(2,2)

  -- Gets the node at location <x,y> on a preprocessed grid
  function PreProcessGrid:getNodeAt(x,y)
    return self._nodes[y] and self._nodes[y][x] or nil
  end

  -- Gets the node at location <x,y> on a postprocessed grid
  function PostProcessGrid:getNodeAt(x,y)
    if not x or not y then return end
    if Utils.outOfRange(x,self._min_x,self._max_x) then return end
    if Utils.outOfRange(y,self._min_y,self._max_y) then return end
    if not self._nodes[y] then self._nodes[y] = {} end
    if not self._nodes[y][x] then self._nodes[y][x] = Node:new(x,y) end
    return self._nodes[y][x]
  end

  return setmetatable(Grid,{
    __call = function(self,...)
      return self:new(...)
    end
  })

end
--- <strong>The <code>grid</code> class API</strong>.
--
-- Implementation of a `grid` class, which represents the 2D map (graph) on which a `pathfinder` will perform.
--
-- During a search, the pathfinder evaluates __costs values__ for each node being processed, in order to
-- select, after each step of iteration, what node should be expanded next to reach the target
-- optimally. Those values are cached within an array of nodes inside the `grid` object.
--
-- @author Roland Yonaba
-- @copyright 2012-2013
-- @license <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a>
-- @module jumper.grid

--- @usage
local usage = [[
-- Usage Example
-- First, set a collision map
local map = {
	{0,1,0,1,0},
	{0,1,0,1,0},
	{0,1,1,1,0},
	{0,0,0,0,0},
}
-- Value for walkable tiles
local walkable = 0

-- Library setup
local Grid = require ("jumper.grid") -- The grid class

-- Creates a grid object
local grid = Grid(map)
]]

if (...) then
  local _PATH = (...):gsub('%.grid$','')
  local pairs = pairs
  local assert = assert
  local next = next
  local floor = math.floor
	local otype = type
  local Node = require (_PATH .. '.core.node')

  ---------------------------------------------------------------------
  -- Private utilities
	
	-- Is i and integer ?
	local isInt = function(i)
		return otype(i) =='number' and floor(i)==i
	end
	
	-- Override type to report integers
	local type = function(v)
		if isInt(v) then return 'int' end
		return otype(v)
	end
	
	-- Real count of for values in an array
	local size = function(t)
		local count = 0
		for k,v in pairs(t) do count = count+1 end
		return count
	end

	-- Checks array contents
	local check_contents = function(t,...)
		local n_count = size(t)
		if n_count < 1 then return false end
		local init_count = t[0] and 0 or 1
		local n_count = (t[0] and n_count-1 or n_count)
		local types = {...}
		if types then types = table.concat(types) end
		for i=init_count,n_count,1 do
			if not t[i] then return false end
			if types then
				if not types:match(type(t[i])) then return false end
			end
		end
		return true
	end

	-- Checks if m is a regular map
  local function isMap(m)
		if not check_contents(m, 'table') then return false end
		local lsize = size(m[next(m)])
		for k,v in pairs(m) do
			if not check_contents(m[k], 'string', 'int') then return false end
			if size(v)~=lsize then return false end
		end
		return true
  end

  -- Is arg a valid string map
  local function isStringMap(s)
    if type(m) ~= 'string' then return false end
    local w
    for row in s:gmatch('[^\n\r]+') do
      if not row then return false end
      w = w or #row
      if w ~= #row then return false end
    end
    return true
  end

  -- Parses a map
  local function parseStringMap(str)
		local map = {}
		local w, h
    for line in str:gmatch('[^\n\r]+') do
      if line then
        w = not w and #line or w
        assert(#line == w, 'Error parsing map, rows must have the same size!')
        h = (h or 0) + 1
        map[h] = {}
        for char in line:gmatch('.') do 
					map[h][#map[h]+1] = char 
				end
      end
    end
    return map
  end

  -- Postprocessing : Get map bounds
  local function getBounds(map)
    local min_bound_x, max_bound_x
    local min_bound_y, max_bound_y

      for y in pairs(map) do
        min_bound_y = not min_bound_y and y or (y<min_bound_y and y or min_bound_y)
        max_bound_y = not max_bound_y and y or (y>max_bound_y and y or max_bound_y)
        for x in pairs(map[y]) do
          min_bound_x = not min_bound_x and x or (x<min_bound_x and x or min_bound_x)
          max_bound_x = not max_bound_x and x or (x>max_bound_x and x or max_bound_x)
        end
      end
    return min_bound_x,max_bound_x,min_bound_y,max_bound_y
  end

  -- Preprocessing
  local function buildGrid(map)
    local min_bound_x, max_bound_x
    local min_bound_y, max_bound_y

    local nodes = {}
      for y in pairs(map) do
        min_bound_y = not min_bound_y and y or (y<min_bound_y and y or min_bound_y)
        max_bound_y = not max_bound_y and y or (y>max_bound_y and y or max_bound_y)
        nodes[y] = {}
        for x in pairs(map[y]) do
          min_bound_x = not min_bound_x and x or (x<min_bound_x and x or min_bound_x)
          max_bound_x = not max_bound_x and x or (x>max_bound_x and x or max_bound_x)
          nodes[y][x] = Node:new(x,y)
        end
      end
    return nodes,
			 (min_bound_x or 0), (max_bound_x or 0),
			 (min_bound_y or 0), (max_bound_y or 0)
  end

  -- Checks if a value is out of and interval [lowerBound,upperBound]
  local function outOfRange(i,lowerBound,upperBound)
    return (i< lowerBound or i > upperBound)
  end

  -- Offsets for straights moves
  local straightOffsets = {
    {x = 1, y = 0} --[[W]], {x = -1, y =  0}, --[[E]]
    {x = 0, y = 1} --[[S]], {x =  0, y = -1}, --[[N]]
  }

  -- Offsets for diagonal moves
  local diagonalOffsets = {
    {x = -1, y = -1} --[[NW]], {x = 1, y = -1}, --[[NE]]
    {x = -1, y =  1} --[[SW]], {x = 1, y =  1}, --[[SE]]
  }

  ---------------------------------------------------------------------
  --- The `grid` class
  -- @class table
  -- @name grid
  -- @field width The grid width
  -- @field height The grid height
  -- @field map A reference to the collision map
  -- @field nodes A 2D array of nodes, each node matching a cell on the collision map
  local Grid = {}
  Grid.__index = Grid

  -- Specialized grids
  local PreProcessGrid = setmetatable({},Grid)
  local PostProcessGrid = setmetatable({},Grid)
  PreProcessGrid.__index = PreProcessGrid
  PostProcessGrid.__index = PostProcessGrid
  PreProcessGrid.__call = function (self,x,y)
    return self:getNodeAt(x,y)
  end
  PostProcessGrid.__call = function (self,x,y,create)
    if create then return self:getNodeAt(x,y) end
    return self.nodes[y] and self.nodes[y][x]
  end

  --- Inits a new `grid` object
  -- @class function
  -- @name grid:new
  -- @tparam table|string map A collision map - (2D array) with consecutive integer indices or a string with line-break symbol as a row delimiter.
  -- @tparam[optchain] bool processOnDemand whether or not caching nodes in the internal grid should be processed on-demand
  -- @treturn grid a new `grid` object
  function Grid:new(map, processOnDemand)
		map = type(map)=='string' and parseStringMap(map) or map
    assert(isMap(map) or isStringMap(map),('Bad argument #1. Not a valid map'))
    assert(type(processOnDemand) == 'boolean' or not processOnDemand,
      ('Bad argument #2. Expected \'boolean\', got %s.'):format(type(processOnDemand)))

    if processOnDemand then
      return PostProcessGrid:new(map,walkable)
    end
    return PreProcessGrid:new(map,walkable)
  end

  --- Checks walkability. Tests if `node` [x,y] exists on the collision map and is walkable
  -- @class function
  -- @name grid:isWalkableAt
  -- @tparam int x the x-coordinate of the node
  -- @tparam int y the y-coordinate of the node
  -- @tparam string|int|function walkable the value for walkable nodes on the passed-in map array.
  -- If this parameter is a function, it should be prototyped as `f(value)`, returning a boolean:
  -- `true` when value matches a *walkable* node, `false` otherwise. If this parameter is not given and
  -- node [x,y] exists, this function return `true`.
  -- @treturn bool `true` if the node exist and is walkable, `false` otherwise
  function Grid:isWalkableAt(x, y, walkable)
    local nodeValue = self.map[y] and self.map[y][x]
    if nodeValue then
      if not walkable then return true end
    else 
			return false
    end
    if self.__eval then return walkable(nodeValue) end
    return (nodeValue == walkable)
  end

  --- Gets the `grid` width.
  -- @class function
  -- @name grid:getWidth
  -- @treturn int the `grid` object width
  function Grid:getWidth()
    return self.width
  end

  --- Gets the `grid` height.
  -- @class function
  -- @name grid:getHeight
  -- @treturn int the `grid` object height
  function Grid:getHeight()
     return self.height
  end

  --- Gets the collision map.
  -- @class function
  -- @name grid:getMap
  -- @treturn {{value},...} the collision map previously passed to the `grid` object on initalization
  function Grid:getMap()
    return self.map
  end

  --- Gets the `grid` nodes.
  -- @class function
  -- @name grid:getNodes
  -- @treturn {{node},...} the `grid` nodes
  function Grid:getNodes()
    return self.nodes
  end

  --- Returns the neighbours of a given `node` on a `grid`
  -- @class function
  -- @name grid:getNeighbours
  -- @tparam node node `node` object
  -- @tparam string|int|function walkable the value for walkable nodes on the passed-in map array.
  -- If this parameter is a function, it should be prototyped as `f(value)`, returning a boolean:
  -- `true` when value matches a *walkable* node, `false` otherwise.
  -- @tparam[opt] bool allowDiagonal whether or not adjacent nodes (8-directions moves) are allowed
  -- @tparam[optchain] bool tunnel Whether or not the pathfinder can tunnel though walls diagonally
  -- @treturn {node,...} an array of nodes neighbouring a passed-in node on the collision map
  function Grid:getNeighbours(node, walkable, allowDiagonal, tunnel)
		local neighbours = {}
    for i = 1,#straightOffsets do
      local n = self:getNodeAt(
        node.x + straightOffsets[i].x,
        node.y + straightOffsets[i].y
      )
      if n and self:isWalkableAt(n.x, n.y, walkable) then
        neighbours[#neighbours+1] = n
      end
    end

    if not allowDiagonal then return neighbours end
		
		tunnel = not not tunnel
    for i = 1,#diagonalOffsets do
      local n = self:getNodeAt(
        node.x + diagonalOffsets[i].x,
        node.y + diagonalOffsets[i].y
      )
      if n and self:isWalkableAt(n.x, n.y, walkable) then
				if tunnel then
					neighbours[#neighbours+1] = n
				else
					local skipThisNode = false
					local n1 = self:getNodeAt(node.x+diagonalOffsets[i].x, node.y)
					local n2 = self:getNodeAt(node.x, node.y+diagonalOffsets[i].y)
					if ((n1 and n2) and not self:isWalkableAt(n1.x, n1.y, walkable) and not self:isWalkableAt(n2.x, n2.y, walkable)) then
						skipThisNode = true
					end
					if not skipThisNode then neighbours[#neighbours+1] = n end
				end
      end
    end

    return neighbours
  end

  --- Iterates on nodes on the grid. When given no args, will iterate on every single node
  -- on the grid, in case the grid is pre-processed. Passing `lx, ly, ex, ey` args will iterate
  -- on nodes inside a bounding-rectangle delimited by those coordinates.
  -- @class function
  -- @name grid:iter
  -- @tparam[opt] int lx the leftmost x-coordinate coordinate of the rectangle
  -- @tparam[optchain] int ly the topmost y-coordinate of the rectangle
  -- @tparam[optchain] int ex the rightmost x-coordinate of the rectangle
  -- @tparam[optchain] int ey the bottom-most y-coordinate of the rectangle
  -- @treturn node a node on the collision map, upon each iteration step
  function Grid:iter(lx,ly,ex,ey)
    local min_x = lx or self.min_bound_x
    local min_y = ly or self.min_bound_y
    local max_x = ex or self.max_bound_x
    local max_y = ey or self.max_bound_y

    local x, y
    y = min_y
    return function()
      x = not x and min_x or x+1
      if x>max_x then
        x = min_x
        y = y+1
      end
      if y > max_y then
        y = nil
      end
      return self.nodes[y] and self.nodes[y][x] or self:getNodeAt(x,y)
    end
  end

  --- Each transformation. Executes a function on each `node` in the `grid`, passing the `node` as the first arg to function `f`.
  -- @class function
  -- @name grid:each
  -- @tparam function f a function prototyped as `f(node,...)`
  -- @tparam[opt] vararg ... args to be passed to function `f`
  function Grid:each(f,...)
    for node in self:iter() do f(node,...) end
  end

  --- Each in range transformation. Executes a function on each `node` in the range of a rectangle of cells, passing the `node` as the first arg to function `f`.
  -- @class function
  -- @name grid:eachRange
  -- @tparam int lx the leftmost x-coordinate coordinate of the rectangle
  -- @tparam int ly the topmost y-coordinate of the rectangle
  -- @tparam int ex the rightmost x-coordinate of the rectangle
  -- @tparam int ey the bottom-most y-coordinate of the rectangle
  -- @tparam function f a function prototyped as `f(node,...)`
  -- @tparam[opt] vararg ... args to be passed to function `f`
  function Grid:eachRange(lx,ly,ex,ey,f,...)
    for node in self:iter(lx,ly,ex,ey) do f(node,...) end
  end

  --- Map transformation. Maps function `f(node,...)` on each `node` in a given range, passing the `node` as the first arg to function `f`. The passed-in function should return a `node` object.
  -- @class function
  -- @name grid:imap
  -- @tparam function f a function prototyped as `f(node,...)`
  -- @tparam[opt] vararg ... args to be passed to function `f`
  function Grid:imap(f,...)
    for node in self:iter() do
      node = f(node,...)
    end
  end

  --- Map in range transformation. Maps `f(node,...)` on each `nod`e in the range of a rectangle of cells, passing the `node` as the first arg to function `f`. The passed-in function should return a `node` object.
  -- @class function
  -- @name grid:imapRange
  -- @tparam int lx the leftmost x-coordinate coordinate of the rectangle
  -- @tparam int ly the topmost y-coordinate of the rectangle
  -- @tparam int ex the rightmost x-coordinate of the rectangle
  -- @tparam int ey the bottom-most y-coordinate of the rectangle
  -- @tparam function f a function prototyped as `f(node,...)`
  -- @tparam[opt] vararg ... args to be passed to function `f`
  function Grid:imapRange(lx,ly,ex,ey,f,...)
    for node in self:iter(lx,ly,ex,ey) do
      node = f(node,...)
    end
  end


  -- Specialized grids
  -- Inits a preprocessed grid
  function PreProcessGrid:new(map)
    local newGrid = {}
    newGrid.map = map
    newGrid.nodes, newGrid.min_bound_x, newGrid.max_bound_x, newGrid.min_bound_y, newGrid.max_bound_y = buildGrid(newGrid.map)
    newGrid.width = (newGrid.max_bound_x-newGrid.min_bound_x)+1
    newGrid.height = (newGrid.max_bound_y-newGrid.min_bound_y)+1
    return setmetatable(newGrid,PreProcessGrid)
  end

  -- Inits a postprocessed grid
  function PostProcessGrid:new(map)
    local newGrid = {}
    newGrid.map = map
    newGrid.nodes = {}
    newGrid.min_bound_x, newGrid.max_bound_x, newGrid.min_bound_y, newGrid.max_bound_y = getBounds(newGrid.map)
    newGrid.width = (newGrid.max_bound_x-newGrid.min_bound_x)+1
    newGrid.height = (newGrid.max_bound_y-newGrid.min_bound_y)+1
    return setmetatable(newGrid,PostProcessGrid)
  end

  --- Returns the `node`[x,y] on a `grid`.
  -- @class function
  -- @name grid:getNodeAt
  -- @tparam int x the x-coordinate coordinate
  -- @tparam int y the y-coordinate coordinate
  -- @treturn node a `node` object
  -- Gets the node at location <x,y> on a preprocessed grid
  function PreProcessGrid:getNodeAt(x,y)
    return self.nodes[y] and self.nodes[y][x] or nil
  end

  -- Gets the node at location <x,y> on a postprocessed grid
  function PostProcessGrid:getNodeAt(x,y)
    if not x or not y then return end
    if outOfRange(x,self.min_bound_x,self.max_bound_x) then return end
    if outOfRange(y,self.min_bound_y,self.max_bound_y) then return end
    if not self.nodes[y] then self.nodes[y] = {} end
    if not self.nodes[y][x] then self.nodes[y][x] = Node:new(x,y) end
    return self.nodes[y][x]
  end

  return setmetatable(Grid,{
    __call = function(self,...)
      return self:new(...)
    end
  })

end


--[[
Copyright (c) 2012 Roland Yonaba

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--]]--- The Pathfinder class

--
-- Implementation of the `pathfinder` class.

local _VERSION = ""
local _RELEASEDATE = ""

if (...) then

  -- Dependencies
  local _PATH = (...):gsub('%.pathfinder$','')
	local Utils     = require (_PATH .. '.core.utils')
	local Assert    = require (_PATH .. '.core.assert')
  local Heap      = require (_PATH .. '.core.bheap')
  local Heuristic = require (_PATH .. '.core.heuristics')
  local Grid      = require (_PATH .. '.grid')
  local Path      = require (_PATH .. '.core.path')

  -- Internalization
  local t_insert, t_remove = table.insert, table.remove
	local floor = math.floor
  local pairs = pairs
  local assert = assert
	local type = type
  local setmetatable, getmetatable = setmetatable, getmetatable

	--- Finders (search algorithms implemented). Refers to the search algorithms actually implemented in Jumper.
	--
	-- <li>[A*](http://en.wikipedia.org/wiki/A*_search_algorithm)</li>
	-- <li>[Dijkstra](http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)</li>
	-- <li>[Theta Astar](http://aigamedev.com/open/tutorials/theta-star-any-angle-paths/)</li>
	-- <li>[BFS](http://en.wikipedia.org/wiki/Breadth-first_search)</li>
	-- <li>[DFS](http://en.wikipedia.org/wiki/Depth-first_search)</li>
	-- <li>[JPS](http://harablog.wordpress.com/2011/09/07/jump-point-search/)</li>
	-- @finder Finders
	-- @see Pathfinder:getFinders
  local Finders = {
    ['ASTAR']     = require (_PATH .. '.search.astar'),
    ['DIJKSTRA']  = require (_PATH .. '.search.dijkstra'),
    ['THETASTAR'] = require (_PATH .. '.search.thetastar'),
    ['BFS']       = require (_PATH .. '.search.bfs'),
    ['DFS']       = require (_PATH .. '.search.dfs'),
    ['JPS']       = require (_PATH .. '.search.jps')
  }

  -- Will keep track of all nodes expanded during the search
  -- to easily reset their properties for the next pathfinding call
  local toClear = {}

	--- Search modes. Refers to the search modes. In ORTHOGONAL mode, 4-directions are only possible when moving,
	-- including North, East, West, South. In DIAGONAL mode, 8-directions are possible when moving,
	-- including North, East, West, South and adjacent directions.
	--
	-- <li>ORTHOGONAL</li>
	-- <li>DIAGONAL</li>
	-- @mode Modes
	-- @see Pathfinder:getModes
  local searchModes = {['DIAGONAL'] = true, ['ORTHOGONAL'] = true}

  -- Performs a traceback from the goal node to the start node
  -- Only happens when the path was found

	--- The `Pathfinder` class.<br/>
	-- This class is callable.
	-- Therefore,_ <code>Pathfinder(...)</code> _acts as a shortcut to_ <code>Pathfinder:new(...)</code>.
	-- @type Pathfinder
  local Pathfinder = {}
  Pathfinder.__index = Pathfinder

  --- Inits a new `pathfinder`
  -- @class function
  -- @tparam grid grid a `grid`
  -- @tparam[opt] string finderName the name of the `Finder` (search algorithm) to be used for search.
	-- Defaults to `ASTAR` when not given (see @{Pathfinder:getFinders}).
  -- @tparam[optchain] string|int|func walkable the value for __walkable__ nodes.
  -- If this parameter is a function, it should be prototyped as __f(value)__, returning a boolean:
  -- __true__ when value matches a __walkable__ `node`, __false__ otherwise.
  -- @treturn pathfinder a new `pathfinder` instance
	-- @usage
	-- -- Example one
	-- local finder = Pathfinder:new(myGrid, 'ASTAR', 0)
	--
	-- -- Example two
	-- local function walkable(value)
	--   return value > 0
	-- end
	-- local finder = Pathfinder(myGrid, 'JPS', walkable)
  function Pathfinder:new(grid, finderName, walkable)
    local newPathfinder = {}
    setmetatable(newPathfinder, Pathfinder)
	  newPathfinder:setGrid(grid)
    newPathfinder:setFinder(finderName)
    newPathfinder:setWalkable(walkable)
    newPathfinder:setMode('DIAGONAL')
    newPathfinder:setHeuristic('MANHATTAN')
    newPathfinder:setTunnelling(false)
    return newPathfinder
  end

	--- Evaluates [clearance](http://aigamedev.com/open/tutorial/clearance-based-pathfinding/#TheTrueClearanceMetric)
	-- for the whole `grid`. It should be called only once, unless the collision map or the
	-- __walkable__ attribute changes. The clearance values are calculated and cached within the grid nodes.
  -- @class function
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage myFinder:annotateGrid()
	function Pathfinder:annotateGrid()
		assert(self._walkable, 'Finder must implement a walkable value')
		for x=self._grid._max_x,self._grid._min_x,-1 do
			for y=self._grid._max_y,self._grid._min_y,-1 do
				local node = self._grid:getNodeAt(x,y)
				if self._grid:isWalkableAt(x,y,self._walkable) then
					local nr = self._grid:getNodeAt(node._x+1, node._y)
					local nrd = self._grid:getNodeAt(node._x+1, node._y+1)
					local nd = self._grid:getNodeAt(node._x, node._y+1)
					if nr and nrd and nd then
						local m = nrd._clearance[self._walkable] or 0
						m = (nd._clearance[self._walkable] or 0)<m and (nd._clearance[self._walkable] or 0) or m
						m = (nr._clearance[self._walkable] or 0)<m and (nr._clearance[self._walkable] or 0) or m
						node._clearance[self._walkable] = m+1
					else
						node._clearance[self._walkable] = 1
					end
				else node._clearance[self._walkable] = 0
				end
			end
		end
		self._grid._isAnnotated[self._walkable] = true
		return self
	end

	--- Removes [clearance](http://aigamedev.com/open/tutorial/clearance-based-pathfinding/#TheTrueClearanceMetric)values.
	-- Clears cached clearance values for the current __walkable__.
  -- @class function
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage myFinder:clearAnnotations()
	function Pathfinder:clearAnnotations()
		assert(self._walkable, 'Finder must implement a walkable value')
		for node in self._grid:iter() do
			node:removeClearance(self._walkable)
		end
		self._grid._isAnnotated[self._walkable] = false
		return self
	end

  --- Sets the `grid`. Defines the given `grid` as the one on which the `pathfinder` will perform the search.
  -- @class function
  -- @tparam grid grid a `grid`
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage myFinder:setGrid(myGrid)
  function Pathfinder:setGrid(grid)
    assert(Assert.inherits(grid, Grid), 'Wrong argument #1. Expected a \'grid\' object')
    self._grid = grid
    self._grid._eval = self._walkable and type(self._walkable) == 'function'
    return self
  end

  --- Returns the `grid`. This is a reference to the actual `grid` used by the `pathfinder`.
  -- @class function
  -- @treturn grid the `grid`
	-- @usage local myGrid = myFinder:getGrid()
  function Pathfinder:getGrid()
    return self._grid
  end

  --- Sets the __walkable__ value or function.
  -- @class function
  -- @tparam string|int|func walkable the value for walkable nodes.
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage
	-- -- Value '0' is walkable
	-- myFinder:setWalkable(0)
	--
	-- -- Any value greater than 0 is walkable
	-- myFinder:setWalkable(function(n)
	--   return n>0
	-- end
  function Pathfinder:setWalkable(walkable)
    assert(Assert.matchType(walkable,'stringintfunctionnil'),
      ('Wrong argument #1. Expected \'string\', \'number\' or \'function\', got %s.'):format(type(walkable)))
    self._walkable = walkable
    self._grid._eval = type(self._walkable) == 'function'
    return self
  end

  --- Gets the __walkable__ value or function.
  -- @class function
  -- @treturn string|int|func the `walkable` value or function
	-- @usage local walkable = myFinder:getWalkable()
  function Pathfinder:getWalkable()
    return self._walkable
  end

  --- Defines the `finder`. It refers to the search algorithm used by the `pathfinder`.
  -- Default finder is `ASTAR`. Use @{Pathfinder:getFinders} to get the list of available finders.
  -- @class function
  -- @tparam string finderName the name of the `finder` to be used for further searches.
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage
	-- --To use Breadth-First-Search
	-- myFinder:setFinder('BFS')
	-- @see Pathfinder:getFinders
  function Pathfinder:setFinder(finderName)
		if not finderName then
			if not self._finder then
				finderName = 'ASTAR'
			else return
			end
		end
    assert(Finders[finderName],'Not a valid finder name!')
    self._finder = finderName
    return self
  end

  --- Returns the name of the `finder` being used.
  -- @class function
  -- @treturn string the name of the `finder` to be used for further searches.
	-- @usage local finderName = myFinder:getFinder()
  function Pathfinder:getFinder()
    return self._finder
  end

  --- Returns the list of all available finders names.
  -- @class function
  -- @treturn {string,...} array of built-in finders names.
	-- @usage
	-- local finders = myFinder:getFinders()
	-- for i, finderName in ipairs(finders) do
	--   print(i, finderName)
	-- end
  function Pathfinder:getFinders()
    return Utils.getKeys(Finders)
  end

  --- Sets a heuristic. This is a function internally used by the `pathfinder` to find the optimal path during a search.
  -- Use @{Pathfinder:getHeuristics} to get the list of all available `heuristics`. One can also define
  -- his own `heuristic` function.
  -- @class function
  -- @tparam func|string heuristic `heuristic` function, prototyped as __f(dx,dy)__ or as a `string`.
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
  -- @see Pathfinder:getHeuristics
	-- @see core.heuristics
	-- @usage myFinder:setHeuristic('MANHATTAN')
  function Pathfinder:setHeuristic(heuristic)
    assert(Heuristic[heuristic] or (type(heuristic) == 'function'),'Not a valid heuristic!')
    self._heuristic = Heuristic[heuristic] or heuristic
    return self
  end

  --- Returns the `heuristic` used. Returns the function itself.
  -- @class function
  -- @treturn func the `heuristic` function being used by the `pathfinder`
	-- @see core.heuristics
	-- @usage local h = myFinder:getHeuristic()
  function Pathfinder:getHeuristic()
    return self._heuristic
  end

  --- Gets the list of all available `heuristics`.
  -- @class function
  -- @treturn {string,...} array of heuristic names.
	-- @see core.heuristics
	-- @usage
	-- local heur = myFinder:getHeuristic()
	-- for i, heuristicName in ipairs(heur) do
	--   ...
	-- end
  function Pathfinder:getHeuristics()
    return Utils.getKeys(Heuristic)
  end

  --- Defines the search `mode`.
  -- The default search mode is the `DIAGONAL` mode, which implies 8-possible directions when moving (north, south, east, west and diagonals).
  -- In `ORTHOGONAL` mode, only 4-directions are allowed (north, south, east and west).
  -- Use @{Pathfinder:getModes} to get the list of all available search modes.
  -- @class function
  -- @tparam string mode the new search `mode`.
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
  -- @see Pathfinder:getModes
	-- @see Modes
	-- @usage myFinder:setMode('ORTHOGONAL')
  function Pathfinder:setMode(mode)
    assert(searchModes[mode],'Invalid mode')
    self._allowDiagonal = (mode == 'DIAGONAL')
    return self
  end

  --- Returns the search mode.
  -- @class function
  -- @treturn string the current search mode
	-- @see Modes
	-- @usage local mode = myFinder:getMode()
  function Pathfinder:getMode()
    return (self._allowDiagonal and 'DIAGONAL' or 'ORTHOGONAL')
  end

  --- Gets the list of all available search modes.
  -- @class function
  -- @treturn {string,...} array of search modes.
	-- @see Modes
	-- @usage local modes = myFinder:getModes()
	-- for modeName in ipairs(modes) do
	--   ...
	-- end
  function Pathfinder:getModes()
    return Utils.getKeys(searchModes)
  end

  --- Enables tunnelling. Defines the ability for the `pathfinder` to tunnel through walls when heading diagonally.
	-- This feature __is not compatible__ with Jump Point Search algorithm (i.e. enabling it will not affect Jump Point Search)
  -- @class function
  -- @tparam bool bool a boolean
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage myFinder:setTunnelling(true)
  function Pathfinder:setTunnelling(bool)
    assert(Assert.isBool(bool), ('Wrong argument #1. Expected boolean, got %s'):format(type(bool)))
		self._tunnel = bool
		return self
  end

  --- Returns tunnelling feature state.
  -- @class function
	-- @treturn bool tunnelling feature actual state
	-- @usage local isTunnellingEnabled = myFinder:getTunnelling()
  function Pathfinder:getTunnelling()
		return self._tunnel
  end

  --- Calculates a `path`. Returns the `path` from location __[startX, startY]__ to location __[endX, endY]__.
  -- Both locations must exist on the collision map. The starting location can be unwalkable.
  -- @class function
  -- @tparam int startX the x-coordinate for the starting location
  -- @tparam int startY the y-coordinate for the starting location
  -- @tparam int endX the x-coordinate for the goal location
  -- @tparam int endY the y-coordinate for the goal location
  -- @tparam int clearance the amount of clearance (i.e the pathing agent size) to consider
  -- @treturn path a path (array of nodes) when found, otherwise nil
	-- @usage local path = myFinder:getPath(1,1,5,5)
  function Pathfinder:getPath(startX, startY, endX, endY, clearance)
		self:reset()
    local startNode = self._grid:getNodeAt(startX, startY)
    local endNode = self._grid:getNodeAt(endX, endY)
    assert(startNode, ('Invalid location [%d, %d]'):format(startX, startY))
    assert(endNode and self._grid:isWalkableAt(endX, endY),
      ('Invalid or unreachable location [%d, %d]'):format(endX, endY))
    local _endNode = Finders[self._finder](self, startNode, endNode, clearance, toClear)
    if _endNode then
			return Utils.traceBackPath(self, _endNode, startNode)
    end
    return nil
  end

  --- Resets the `pathfinder`. This function is called internally between successive pathfinding calls, so you should not
	-- use it explicitely, unless under specific circumstances.
  -- @class function
	-- @treturn pathfinder self (the calling `pathfinder` itself, can be chained)
	-- @usage local path, len = myFinder:getPath(1,1,5,5)
	function Pathfinder:reset()
    for node in pairs(toClear) do node:reset() end
    toClear = {}
		return self
	end


  -- Returns Pathfinder class
	Pathfinder._VERSION = _VERSION
	Pathfinder._RELEASEDATE = _RELEASEDATE
  return setmetatable(Pathfinder,{
    __call = function(self,...)
      return self:new(...)
    end
  })

end
--- <strong>The <strong>pathfinder</strong> class API</strong>.
--
-- Implementation of the `pathfinder` class.
--
-- @author Roland Yonaba
-- @copyright 2012-2013
-- @license <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a>
-- @module jumper.pathfinder

local _VERSION = "1.8.1"
local _RELEASEDATE = "03/01/2013"

--- @usage
local usage = [[
-- Usage Example
-- First, set a collision map
local map = {
	{0,1,0,1,0},
	{0,1,0,1,0},
	{0,1,1,1,0},
	{0,0,0,0,0},
}
-- Value for walkable tiles
local walkable = 0

-- Library setup
local Grid = require ("jumper.grid") -- The grid class
local Pathfinder = require ("jumper.pathfinder") -- The pathfinder lass

-- Creates a grid object
local grid = Grid(map)
-- Creates a pathfinder object using Jump Point Search
local myFinder = Pathfinder(grid, 'JPS', walkable)

-- Define start and goal locations coordinates
local startx, starty = 1,1
local endx, endy = 5,1

-- Calculates the path, and its length
local path, length = myFinder:getPath(startx, starty, endx, endy)
if path then
  print(('Path found! Length: %.2f'):format(length))
	for node, count in path:iter() do
	  print(('Step: %d - x: %d - y: %d'):format(count, node.x, node.y))
	end
end

--> Output:
--> Path found! Length: 8.83
--> Step: 1 - x: 1 - y: 1
--> Step: 2 - x: 1 - y: 3
--> Step: 3 - x: 2 - y: 4
--> Step: 4 - x: 4 - y: 4
--> Step: 5 - x: 5 - y: 3
--> Step: 6 - x: 5 - y: 1
]]

if (...) then

  -- Internalization
  local t_insert, t_remove = table.insert, table.remove
	local floor = math.floor
  local pairs = pairs
  local assert = assert
  local setmetatable, getmetatable = setmetatable, getmetatable
	
	-- Type function ovverride, to support integers
	local otype = type
	local isInt = function(v) 
		return otype(v) == 'number' and floor(v) == v and 'int' or nil 
	end
	local type = function(v)
		return isInt(v) or otype(v)
	end
	
  -- Dependancies
  local _PATH = (...):gsub('%.pathfinder$','')
  local Heap      = require (_PATH .. '.core.bheap')
  local Heuristic = require (_PATH .. '.core.heuristics')
  local Grid      = require (_PATH .. '.grid')
  local Path      = require (_PATH .. '.core.path')

  -- Is arg a grid object
  local function isAGrid(grid)
    return getmetatable(grid) and getmetatable(getmetatable(grid)) == Grid
  end

  -- Available search algorithms
  local Finders = {
    ['ASTAR']     = require (_PATH .. '.search.astar'),	
    ['DIJKSTRA']  = require (_PATH .. '.search.dijkstra'),
    ['BFS']       = require (_PATH .. '.search.bfs'),
    ['DFS']       = require (_PATH .. '.search.dfs'),
    ['JPS']       = require (_PATH .. '.search.jps'),
  }

  -- Collect keys in an array
  local function collect_keys(t)
    local keys = {}
    for k,v in pairs(t) do keys[#keys+1] = k end
    return keys
  end

  -- Will keep track of all nodes expanded during the search
  -- to easily reset their properties for the next pathfinding call
  local toClear = {}

  -- Resets properties of nodes expanded during a search
  -- This is a lot faster than resetting all nodes
  -- between consecutive pathfinding requests
  local function reset()
    for node in pairs(toClear) do
      node.g, node.h, node.f = nil, nil, nil
      node.opened, node.closed, node.parent = nil, nil, nil
    end
    toClear = {}
  end

  -- Keeps track of the last computed path cost
  local lastPathCost = 0

  -- Availables search modes
  local searchModes = {['DIAGONAL'] = true, ['ORTHOGONAL'] = true}

  -- Performs a traceback from the goal node to the start node
  -- Only happens when the path was found
  local function traceBackPath(finder, node, startNode)
    local path = Path:new()
    path.grid = finder.grid
    lastPathCost = node.f or path:getLength()

    while true do
      if node.parent then
        t_insert(path,1,node)
        node = node.parent
      else
        t_insert(path,1,startNode)
        return path
      end
    end
  end

  --- The `pathfinder` class
  -- @class table
  -- @name pathfinder
  local Pathfinder = {}
  Pathfinder.__index = Pathfinder

  --- Inits a new `pathfinder` object
  -- @class function
  -- @name pathfinder:new
  -- @tparam grid grid a `grid` object
  -- @tparam[opt] string finderName the name of the `finder` (search algorithm) to be used for further searches.
	-- Defaults to `ASTAR` when not given. Use @{pathfinder:getFinders} to get the full list of available finders..
  -- @tparam[optchain] string|int|function walkable the value for walkable nodes on the passed-in map array.
  -- If this parameter is a function, it should be prototyped as `f(value)`, returning a boolean:
  -- `true` when value matches a *walkable* node, `false` otherwise.
  -- @treturn pathfinder a new `pathfinder` object
  function Pathfinder:new(grid, finderName, walkable)
    local newPathfinder = {}
    setmetatable(newPathfinder, Pathfinder)
	  newPathfinder:setGrid(grid)
    newPathfinder:setFinder(finderName)
    newPathfinder:setWalkable(walkable)
    newPathfinder:setMode('DIAGONAL')
    newPathfinder:setHeuristic('MANHATTAN')
    newPathfinder.openList = Heap()
    return newPathfinder
  end

  --- Sets a `grid` object. Defines the `grid` on which the `pathfinder` will make path searches.
  -- @class function
  -- @name pathfinder:setGrid
  -- @tparam grid grid a `grid` object
  function Pathfinder:setGrid(grid)
    assert(isAGrid(grid), 'Bad argument #1. Expected a \'grid\' object')
    self.grid = grid
    self.grid.__eval = self.walkable and type(self.walkable) == 'function'
    return self
  end

  --- Returns the `grid` object. Returns a reference to the internal `grid` object used by the `pathfinder` object.
  -- @class function
  -- @name pathfinder:getGrid
  -- @treturn grid the `grid` object
  function Pathfinder:getGrid()
    return self.grid
  end

  --- Sets the `walkable` value or function.
  -- @class function
  -- @name pathfinder:setWalkable
  -- @tparam string|int|function walkable the value for walkable nodes on the passed-in map array.
  -- If this parameter is a function, it should be prototyped as `f(value)`, returning a boolean:
  -- `true` when value matches a *walkable* node, `false` otherwise.
  function Pathfinder:setWalkable(walkable)
    assert(('stringintfunctionnil'):match(type(walkable)),
      ('Bad argument #2. Expected \'string\', \'number\' or \'function\', got %s.'):format(type(walkable)))
    self.walkable = walkable
    self.grid.__eval = type(self.walkable) == 'function'
    return self
  end

  --- Gets the `walkable` value or function.
  -- @class function
  -- @name pathfinder:getWalkable
  -- @treturn string|int|function the `walkable` previously set
  function Pathfinder:getWalkable()
    return self.walkable
  end

  --- Sets a finder. The finder refers to the search algorithm used by the `pathfinder` object.
  -- The default finder is `ASTAR`. Use @{pathfinder:getFinders} to get the list of available finders.
  -- @class function
  -- @name pathfinder:setFinder
  -- @tparam string finderName the name of the finder to be used for further searches.
  -- @see pathfinder:getFinders
  function Pathfinder:setFinder(finderName)
		local finderName = finderName
		if not finderName then
			if not self.finder then 
				finderName = 'ASTAR' 
			else return 
			end
		end
    assert(Finders[finderName],'Not a valid finder name!')
    self.finder = finderName
    return self
  end

  --- Gets the name of the finder being used. The finder refers to the search algorithm used by the `pathfinder` object.
  -- @class function
  -- @name pathfinder:getFinder
  -- @treturn string the name of the finder to be used for further searches.
  function Pathfinder:getFinder()
    return self.finder
  end

  --- Gets the list of all available finders names.
  -- @class function
  -- @name pathfinder:getFinders
  -- @treturn {string,...} array of finders names.
  function Pathfinder:getFinders()
    return collect_keys(Finders)
  end

  --- Set a heuristic. This is a function internally used by the `pathfinder` to get the optimal path during a search.
  -- Use @{pathfinder:getHeuristics} to get the list of all available heuristics. One can also defined
  -- his own heuristic function.
  -- @class function
  -- @name pathfinder:setHeuristic
  -- @tparam function|string heuristic a heuristic function, prototyped as `f(dx,dy)` or a string.
  -- @see pathfinder:getHeuristics
  function Pathfinder:setHeuristic(heuristic)
    assert(Heuristic[heuristic] or (type(heuristic) == 'function'),'Not a valid heuristic!')
    self.heuristic = Heuristic[heuristic] or heuristic
    return self
  end

  --- Gets the heuristic used. Returns the function itself.
  -- @class function
  -- @name pathfinder:getHeuristic
  -- @treturn function the heuristic function being used by the `pathfinder` object
  function Pathfinder:getHeuristic()
    return self.heuristic
  end

  --- Gets the list of all available heuristics.
  -- @class function
  -- @name pathfinder:getHeuristics
  -- @treturn {string,...} array of heuristic names.
  function Pathfinder:getHeuristics()
    return collect_keys(Heuristic)
  end

  --- Changes the search mode. Defines a new search mode for the `pathfinder` object.
  -- The default search mode is `DIAGONAL`, which implies 8-possible directions when moving (north, south, east, west and diagonals).
  -- In `ORTHOGONAL` mode, only 4-directions are allowed (north, south, east and west).
  -- Use @{pathfinder:getModes} to get the list of all available search modes.
  -- @class function
  -- @name pathfinder:setMode
  -- @tparam string mode the new search mode.
  -- @see pathfinder:getModes
  function Pathfinder:setMode(mode)
    assert(searchModes[mode],'Invalid mode')
    self.allowDiagonal = (mode == 'DIAGONAL')
    return self
  end

  --- Gets the search mode.
  -- @class function
  -- @name pathfinder:getMode
  -- @treturn string the current search mode
  function Pathfinder:getMode()
    return (self.allowDiagonal and 'DIAGONAL' or 'ORTHOGONAL')
  end

  --- Gets the list of all available search modes.
  -- @class function
  -- @name pathfinder:getModes
  -- @treturn {string,...} array of search modes.
  function Pathfinder:getModes()
    return collect_keys(searchModes)
  end

  --- Returns version and release date.
  -- @class function
  -- @name pathfinder:version
  -- @treturn string the version of the current implementation
  -- @treturn string the release of the current implementation
  function Pathfinder:version()
    return _VERSION, _RELEASEDATE
  end

  --- Calculates a path. Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  -- Both locations must exist on the collision map.
  -- @class function
  -- @name pathfinder:getPath
  -- @tparam number startX the x-coordinate for the starting location
  -- @tparam number startY the y-coordinate for the starting location
  -- @tparam number endX the x-coordinate for the goal location
  -- @tparam number endY the y-coordinate for the goal location
  -- @tparam[opt] bool tunnel Whether or not the pathfinder can tunnel though walls diagonally (not compatible with `Jump Point Search`)
  -- @treturn {node,...} a path (array of `nodes`) when found, otherwise `nil`
  -- @treturn number the path length when found, `0` otherwise
  function Pathfinder:getPath(startX, startY, endX, endY, tunnel)
		reset()
    local startNode = self.grid:getNodeAt(startX, startY)
    local endNode = self.grid:getNodeAt(endX, endY)
    assert(startNode, ('Invalid location [%d, %d]'):format(startX, startY))
    assert(endNode and self.grid:isWalkableAt(endX, endY),
      ('Invalid or unreachable location [%d, %d]'):format(endX, endY))
    local _endNode = Finders[self.finder](self, startNode, endNode, toClear, tunnel)
    if _endNode then 
			return traceBackPath(self, _endNode, startNode), lastPathCost
    end
    lastPathCost = 0
    return nil, lastPathCost
  end

  -- Returns Pathfinder class
  return setmetatable(Pathfinder,{
    __call = function(self,...)
      return self:new(...)
    end
  })

end

--[[
Copyright (c) 2012-2013 Roland Yonaba

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--]]
-- Various assertion function for API methods argument-checking

if (...) then
	
	-- Dependancies
	local _PATH = (...):gsub('%.core.assert$','')
	local Utils = require (_PATH .. '.core.utils')
	
	-- Local references
	local lua_type = type
	local floor = math.floor
	local concat = table.concat
	local next = next
	local pairs = pairs
	local getmetatable = getmetatable
	
	-- Is I an integer ?
	local function isInteger(i)
		return lua_type(i) ==('number') and (floor(i)==i)
	end
	
	-- Override lua_type to return integers
	local function type(v)
		return isInteger(v) and 'int' or lua_type(v)
	end
	
	-- Does the given array contents match a predicate type ?
	local function arrayContentsMatch(t,...)
		local n_count = Utils.arraySize(t)
		if n_count < 1 then return false end
		local init_count = t[0] and 0 or 1
		local n_count = (t[0] and n_count-1 or n_count)
		local types = {...}
		if types then types = concat(types) end
		for i=init_count,n_count,1 do
			if not t[i] then return false end
			if types then
				if not types:match(type(t[i])) then return false end
			end
		end
		return true
	end	
	
	-- Checks if arg is a valid array map
  local function isMap(m)
		if not arrayContentsMatch(m, 'table') then return false end
		local lsize = Utils.arraySize(m[next(m)])
		for k,v in pairs(m) do
			if not arrayContentsMatch(m[k], 'string', 'int') then return false end
			if Utils.arraySize(v)~=lsize then return false end
		end
		return true
  end	
	
	-- Checks if s is a valid string map
  local function isStringMap(s)
    if lua_type(s) ~= 'string' then return false end
    local w
    for row in s:gmatch('[^\n\r]+') do
      if not row then return false end
      w = w or #row
      if w ~= #row then return false end
    end
    return true
  end

	-- Does instance derive straight from class
	local function derives(instance, class)
		return getmetatable(instance) == class
	end
	
	-- Does instance inherits from class	
	local function inherits(instance, class)
		return (getmetatable(getmetatable(instance)) == class)
	end
	
	-- Is arg a boolean
	local function isBoolean(b) 
		return (b==true or b==false)
	end
	
	-- Is arg nil ?
	local function isNil(n)
		return (n==nil)
	end
	
	local function matchType(value, types)
		return types:match(type(value))	
	end
	
	return {
		arrayContentsMatch = arrayContentsMatch,
		derives = derives,
		inherits = inherits,
		isInteger = isInteger,
		isBool = isBoolean,
		isMap = isMap,
		isStrMap = isStringMap,
		isOutOfRange = isOutOfRange,
		isNil = isNil,
		type = type,
		matchType = matchType
	}

end


--- <strong>A light implementation of `binary heaps`</strong>.
-- While running a search, some algorithms have to maintains a list of nodes called __open list__.
-- Finding in this list the lowest cost node from the node being processed can be quite slow, 
-- (as it requires to skim through the collection of nodes stored in this list) 
-- especially when dozens of nodes are being processed (large maps). 
--
-- The current module implements a <a href="http://www.policyalmanac.org/games/binaryHeaps.htm">binary heap</a> data structure,
-- from which the internal open list will be instantiated. As such, looking up for lower-cost 
-- node will run faster, and globally makes the search algorithm run faster.
--
-- This module should normally not be used explicitely. The algorithm uses it internally.
--
-- @author Roland Yonaba
-- @copyright 2012-2013
-- @license <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a>
-- @module jumper.core.bheap

--[[
  Notes:
  Lighter implementation of binary heaps, based on :
    https://github.com/Yonaba/Binary-Heaps
--]]

local floor = math.floor

-- Lookup for value in a table
local indexOf = function(t,v)
  for i = 1,#t do
    if t[i] == v then return i end
  end
  return nil
end

-- Default comparison function
local function f_min(a,b) 
  return a < b 
end

-- Percolates up
local function percolate_up(heap, index)
  if index == 1 then return end
  local pIndex
  if index <= 1 then return end
  if index%2 == 0 then
    pIndex =  index/2
  else pIndex = (index-1)/2
  end
  if not heap.sort(heap.__heap[pIndex], heap.__heap[index]) then
    heap.__heap[pIndex], heap.__heap[index] = 
      heap.__heap[index], heap.__heap[pIndex]
    percolate_up(heap, pIndex)
  end
end

-- Percolates down
local function percolate_down(heap,index)
  local lfIndex,rtIndex,minIndex
  lfIndex = 2*index
  rtIndex = lfIndex + 1
  if rtIndex > heap.size then
    if lfIndex > heap.size then return
    else minIndex = lfIndex  end
  else
    if heap.sort(heap.__heap[lfIndex],heap.__heap[rtIndex]) then
      minIndex = lfIndex
    else
      minIndex = rtIndex
    end
  end
  if not heap.sort(heap.__heap[index],heap.__heap[minIndex]) then
    heap.__heap[index],heap.__heap[minIndex] = heap.__heap[minIndex],heap.__heap[index]
    percolate_down(heap,minIndex)
  end
end

-- Produces a new heap
local function newHeap(template,comp)
  return setmetatable({__heap = {},
    sort = comp or f_min, size = 0},
  template)
end

--- The `heap` class
-- @class table
-- @name heap
local heap = setmetatable({},
  {__call = function(self,...)
    return newHeap(self,...)
  end})
heap.__index = heap

--- Checks if a `heap` is empty
-- @class function
-- @name heap:empty
-- @treturn bool `true` of no item is queued in the heap, `false` otherwise
function heap:empty()
  return (self.size==0)
end

--- Clears the `heap` (removes all items queued in the heap)
-- @class function
-- @name heap:clear
function heap:clear()
  self.__heap = {}
  self.size = 0
  self.sort = self.sort or f_min
  return self
end

--- Adds a new item in the `heap`
-- @class function
-- @name heap:push
-- @tparam object item a new object to be queued in the heap
function heap:push(item)
	if item then
		self.size = self.size + 1
		self.__heap[self.size] = item
		percolate_up(self, self.size)
	end
  return self
end

--- Pops from the `heap`.
-- Removes and returns the lowest cost item (with respect to the comparison function used) from the `heap`.
-- @class function
-- @name heap:pop
-- @treturn object an object stored in the heap
function heap:pop()
  local root
  if self.size > 0 then
    root = self.__heap[1]
    self.__heap[1] = self.__heap[self.size]
    self.__heap[self.size] = nil
    self.size = self.size-1
    if self.size>1 then
      percolate_down(self, 1)
    end
  end
  return root
end

--- Restores the `heap` property.
-- Reorders the `heap` with respect to the comparison function being used. 
-- When given arg `item`, will sort that very item in the `heap`. 
-- Otherwise, the whole `heap` will be sorted. 
-- @class function
-- @name heap:heapify
-- @tparam[opt] object item the modified object 
function heap:heapify(item)
  if item then
    local i = indexOf(self.__heap,item)
    if i then 
      percolate_down(self, i)
      percolate_up(self, i)
    end
    return
  end
  for i = floor(self.size/2),1,-1 do
    percolate_down(self,i)
  end
  return self
end

return heap

--[[
Copyright (c) 2012-2013 Roland Yonaba
Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--]]--- <strong>Heuristics for the search algorithm</strong>.
-- A <a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html">heuristic</a> 
-- provides an *estimate of the optimal cost* from a given location to a target. 
-- As such, it guides the pathfinder to the goal, helping it to decide which route is the best.
--
-- This script holds the definition of built-in heuristics available.
--
-- Distance functions are internally used by the `pathfinder` to evaluate the optimal path
-- from the start location to the goal. These functions share the same prototype:
-- <ul>
-- <pre class="example">
-- local function myHeuristic(dx, dy)
--   -- function body
-- end
-- </pre></ul>
-- Jumper features some built-in distance heuristics, named `MANHATTAN`, `EUCLIDIAN`, `DIAGONAL`, `CARDINTCARD`.
-- You can also supply your own heuristic function, using the template given above.
-- @author Roland Yonaba
-- @copyright 2012-2013
-- @license MIT
-- @module jumper.core.heuristics

--- @usage
local usage = [[
  -- Example
  local Distance = require ('jumper.core.heuristics')
  local Grid = require ("jumper.grid")
  local Pathfinder = require ("jumper.pathfinder")
  local walkable = 0
  -- Placeholder: local map = {...}
  local grid = Grid(map)
  local myFinder = Pathfinder('ASTAR', grid, walkable)
  
  -- Use Euclidian heuristic to evaluate distance
  myFinder:setHeuristic('EUCLIDIAN') 
  -- etc ... 
]]

local abs = math.abs
local sqrt = math.sqrt
local sqrt2 = sqrt(2)
local max, min = math.max, math.min

local Heuristics = {}
  --- Manhattan distance.
  -- <br/>This heuristic is the default one being used by the `pathfinder` object.
  -- <br/>Evaluates as `distance = |dx|+|dy|`
  -- @class function
  -- @name Heuristics.MANHATTAN
  -- @tparam int dx the difference endX-startX
  -- @tparam int dy the difference endY-startY
  -- @treturn number the distance from location `startX, startY` to location `endX, endY`
  -- <ul>
  -- <pre class="example">
  -- -- First method
  -- pathfinder:setHeuristic('MANHATTAN')<br/>
  -- -- Second method
  -- local Distance = require ('jumper.core.heuristics')
  -- pathfinder:setHeuristic(Distance.MANHATTAN)
  -- </pre></ul>
  function Heuristics.MANHATTAN(dx,dy) return abs(dx)+abs(dy) end
  
  --- Euclidian distance.
  -- <br/>Evaluates as `distance = squareRoot(dx*dx+dy*dy)`
  -- @class function
  -- @name Heuristics.EUCLIDIAN
  -- @tparam int dx the difference endX-startX
  -- @tparam int dy the difference endY-startY
  -- @treturn number the distance from location `startX, startY` to location `endX, endY`
  -- <ul>
  -- <pre class="example">
  -- -- First method
  -- pathfinder:setHeuristic('EUCLIDIAN')<br/>
  -- -- Second method
  -- local Distance = require ('jumper.core.heuristics')
  -- pathfinder:setHeuristic(Distance.EUCLIDIAN)
  -- </pre></ul>  
  function Heuristics.EUCLIDIAN(dx,dy) return sqrt(dx*dx+dy*dy) end
  
  --- Diagonal distance.
  -- <br/>Evaluates as `distance = max(|dx|, abs|dy|)`
  -- @class function
  -- @name Heuristics.DIAGONAL
  -- @tparam int dx the difference endX-startX
  -- @tparam int dy the difference endY-startY
  -- @treturn number the distance from location `startX, startY` to location `endX, endY`
  -- <ul>
  -- <pre class="example">
  -- -- First method
  -- pathfinder:setHeuristic('DIAGONAL')<br/>
  -- -- Second method
  -- local Distance = require ('jumper.core.heuristics')
  -- pathfinder:setHeuristic(Distance.DIAGONAL)
  -- </pre></ul>   
  function Heuristics.DIAGONAL(dx,dy) return max(abs(dx),abs(dy)) end
  
  --- Cardinal/Intercardinal distance.
  -- <br/>Evaluates as `distance = min(dx, dy)*squareRoot(2) + max(dx, dy) - min(dx, dy)`
  -- @class function
  -- @name Heuristics.CARDINTCARD
  -- @tparam int dx the difference endX-startX
  -- @tparam int dy the difference endY-startY
  -- @treturn number the distance from location `startX, startY` to location `endX, endY`
  -- <ul>
  -- <pre class="example">
  -- -- First method
  -- pathfinder:setHeuristic('CARDINTCARD')<br/>
  -- -- Second method
  -- local Distance = require ('jumper.core.heuristics')
  -- pathfinder:setHeuristic(Distance.CARDINTCARD)
  -- </pre></ul>  
  function Heuristics.CARDINTCARD(dx,dy) 
    dx, dy = abs(dx), abs(dy)
    return min(dx,dy) * sqrt2 + max(dx,dy) - min(dx,dy)
  end

return Heuristics

--[[
Copyright (c) 2012-2013 Roland Yonaba

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--]]local addNode(self, node, nextNode, ed)
	if not self._pathDB[node] then self._pathDB[node] = {} end
	self._pathDB[node][ed] = (nextNode == ed and node or nextNode)
end

-- Path lookupTable
local lookupTable = {}
lookupTable.__index = lookupTable

function lookupTable:new()
	local lut = {_pathDB = {}}
	return setmetatable(lut, lookupTable)
end

function lookupTable:addPath(path)
	local st, ed = path._nodes[1], path._nodes[#path._nodes]
	for node, count in path:nodes() do
		local nextNode = path._nodes[count+1]
		if nextNode then addNode(self, node, nextNode, ed) end
	end
end

function lookupTable:hasPath(nodeA, nodeB)
	local found
	found = self._pathDB[nodeA] and self._path[nodeA][nodeB]
	if found then return true, true end
	found = self._pathDB[nodeB] and self._path[nodeB][nodeA]
	if found then return true, false end
	return false
end

return lookupTable--- <strong>The <code>node</code> class</strong>.
-- The `node` class represents a cell on a collision map. Basically, for each single cell
-- in the collision map passed-in upon initialization, a `node` object would be generated
-- and then stored within the `grid` object.
--
-- In the following implementation, nodes can be compared using the `<` operator. The comparison is
-- made on the basis of their `f` cost. From a processed node, the `pathfinder` would expand the search 
-- to the next neighbouring node having the lowest `f` cost. This comparison is internally used within the
-- *open list* `heap` to quickly sort all nodes queued inside the heap.
-- 
-- @author Roland Yonaba
-- @copyright 2012-2013
-- @license <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a>
-- @module jumper.core.node

if (...) then

	local assert = assert
	
  --- Internal `node` Class
  -- @class table
  -- @name node
  -- @field x the x-coordinate of the node on the collision map
  -- @field y the y-coordinate of the node on the collision map
  local Node = {}
  Node.__index = Node

  --- Inits a new `node` object
  -- @class function
  -- @name node:new
  -- @tparam int x the x-coordinate of the node on the collision map
  -- @tparam int y the y-coordinate of the node on the collision map
  -- @treturn node a new `node` object
  function Node:new(x,y)
    return setmetatable({x = x, y = y}, Node)
  end

  -- Enables the use of operator '<' to compare nodes.
  -- Will be used to sort a collection of nodes in a binary heap on the basis of their F-cost
  function Node.__lt(A,B) return (A.f < B.f) end

  return setmetatable(Node,
		{__call = function(self,...) 
			return Node:new(...) 
		end}
	)
end


--[[
Copyright (c) 2012-2013 Roland Yonaba

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--]]
--- <strong>The <code>path</code> class</strong>.
-- The `path` class represents a path from a `start` location to a `goal`.
-- An instance from this class would be a result of a request addressed to `pathfinder:getPath`.
-- A `path` is basically a set of `nodes`, aligned in a specific order, defining a way to follow for moving agents.
--
-- @author Roland Yonaba
-- @copyright 2012-2013
-- @license <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a>
-- @module jumper.core.path

if (...) then

  -- Internalization
  local abs, max = math.abs, math.max
	local t_insert, t_remove = table.insert, table.remove
	
  -- Depandancies
  local Heuristic = require ((...):gsub('%.path$','.heuristics'))

  --- The `path` class
  -- @class table
  -- @name path
  local Path = {}
  Path.__index = Path

  --- Inits a new `path` object.
  -- @class function
  -- @name path:new
  -- @treturn path a `path` object
  function Path:new()
    return setmetatable({}, Path)
  end

  --- Iterates on each single `node` along a `path`. At each step of iteration,
  -- returns a `node` and plus a count value. Aliased as @{path:nodes}
  -- @class function
  -- @name path:iter
  -- @treturn node a `node`
  -- @treturn int the count for the number of nodes
	-- @see path:nodes
  function Path:iter()
    local i,pathLen = 1,#self
    return function()
      if self[i] then
        i = i+1
        return self[i-1],i-1
      end
    end
  end
  
  --- Iterates on each single `node` along a `path`. At each step of iteration,
  -- returns a `node` and plus a count value. Aliased for @{path:iter}
  -- @class function
  -- @name path:nodes
  -- @treturn node a `node`
  -- @treturn int the count for the number of nodes
	-- @see path:iter	
	Path.nodes = Path.iter
	
  --- Evaluates the `path` length
  -- @class function
  -- @name path:getLength
  -- @treturn number the `path` length
  function Path:getLength()
    local len = 0
    for i = 2,#self do
      local dx = self[i].x - self[i-1].x
      local dy = self[i].y - self[i-1].y
      len = len + Heuristic.EUCLIDIAN(dx, dy)
    end
    return len
  end

  --- Path filling function. Interpolates between non contiguous locations along a `path`
  -- to build a fully continuous `path`. This maybe useful when using `Jump Point Search` finder.
  -- Does the opposite of @{path:filter}
  -- @class function
  -- @name path:fill
  -- @see path:filter
  function Path:fill()
    local i = 2
    local xi,yi,dx,dy
    local N = #self
    local incrX, incrY
    while true do
      xi,yi = self[i].x,self[i].y
      dx,dy = xi-self[i-1].x,yi-self[i-1].y
      if (abs(dx) > 1 or abs(dy) > 1) then
        incrX = dx/max(abs(dx),1)
        incrY = dy/max(abs(dy),1)
        t_insert(self, i, self.grid:getNodeAt(self[i-1].x + incrX, self[i-1].y +incrY))
        N = N+1
      else i=i+1
      end
      if i>N then break end
    end
  end

  --- Path compression. Given a `path`, eliminates useless nodes to return a lighter `path`. Does
  -- the opposite of @{path:fill}
  -- @class function
  -- @name path:filter
  -- @see path:fill
  function Path:filter()
    local i = 2
    local xi,yi,dx,dy, olddx, olddy
    xi,yi = self[i].x, self[i].y
    dx, dy = xi - self[i-1].x, yi-self[i-1].y
    while true do
      olddx, olddy = dx, dy
      if self[i+1] then
        i = i+1
        xi, yi = self[i].x, self[i].y
        dx, dy = xi - self[i-1].x, yi - self[i-1].y
        if olddx == dx and olddy == dy then
          t_remove(self, i-1)
          i = i - 1
        end
      else break end
    end
  end

  return setmetatable(Path,
    {__call = function(self,...)
      return Path:new(...)
    end
  })
end

--[[
Copyright (c) 2012-2013 Roland Yonaba

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--]]
-- Various utilities for Jumper top-level modules

if (...) then

	-- Dependencies
	local _PATH = (...):gsub('%.utils$','')
	local Path = require (_PATH .. '.path')
	local Node = require (_PATH .. '.node')

	-- Local references
	local pairs = pairs
	local type = type
	local t_insert = table.insert
	local assert = assert
	local coroutine = coroutine

	-- Raw array items count
	local function arraySize(t)
		local count = 0
		for k,v in pairs(t) do
			count = count+1
		end
		return count
	end

	-- Parses a string map and builds an array map
  local function stringMapToArray(str)
		local map = {}
		local w, h
    for line in str:gmatch('[^\n\r]+') do
      if line then
        w = not w and #line or w
        assert(#line == w, 'Error parsing map, rows must have the same size!')
        h = (h or 0) + 1
        map[h] = {}
        for char in line:gmatch('.') do
					map[h][#map[h]+1] = char
				end
      end
    end
    return map
  end

	-- Collects and returns the keys of a given array
  local function getKeys(t)
    local keys = {}
    for k,v in pairs(t) do keys[#keys+1] = k end
    return keys
  end

	-- Calculates the bounds of a 2d array
  local function getArrayBounds(map)
    local min_x, max_x
    local min_y, max_y
      for y in pairs(map) do
        min_y = not min_y and y or (y<min_y and y or min_y)
        max_y = not max_y and y or (y>max_y and y or max_y)
        for x in pairs(map[y]) do
          min_x = not min_x and x or (x<min_x and x or min_x)
          max_x = not max_x and x or (x>max_x and x or max_x)
        end
      end
    return min_x,max_x,min_y,max_y
  end

  -- Converts an array to a set of nodes
  local function arrayToNodes(map)
    local min_x, max_x
    local min_y, max_y
    local nodes = {}
      for y in pairs(map) do
        min_y = not min_y and y or (y<min_y and y or min_y)
        max_y = not max_y and y or (y>max_y and y or max_y)
        nodes[y] = {}
        for x in pairs(map[y]) do
          min_x = not min_x and x or (x<min_x and x or min_x)
          max_x = not max_x and x or (x>max_x and x or max_x)
          nodes[y][x] = Node:new(x,y)
        end
      end
    return nodes,
			 (min_x or 0), (max_x or 0),
			 (min_y or 0), (max_y or 0)
  end

	-- Iterator, wrapped within a coroutine
	-- Iterates around a given position following the outline of a square
	local function around()
		local iterf = function(x0, y0, s)
			local x, y = x0-s, y0-s
			coroutine.yield(x, y)
			repeat
				x = x + 1
				coroutine.yield(x,y)
			until x == x0+s
			repeat
				y = y + 1
				coroutine.yield(x,y)
			until y == y0 + s
			repeat
				x = x - 1
				coroutine.yield(x, y)
			until x == x0-s
			repeat
				y = y - 1
				coroutine.yield(x,y)
			until y == y0-s+1
		end
		return coroutine.create(iterf)
	end

	-- Extract a path from a given start/end position
  local function traceBackPath(finder, node, startNode)
    local path = Path:new()
    path._grid = finder._grid
    while true do
      if node._parent then
        t_insert(path._nodes,1,node)
        node = node._parent
      else
        t_insert(path._nodes,1,startNode)
        return path
      end
    end
  end

	-- Lookup for value in a table
	local indexOf = function(t,v)
		for i = 1,#t do
			if t[i] == v then return i end
		end
		return nil
	end

	-- Is i out of range
  local function outOfRange(i,low,up)
    return (i< low or i > up)
  end
	
	return {
		arraySize = arraySize,
		getKeys = getKeys,
		indexOf = indexOf,
		outOfRange = outOfRange,
		getArrayBounds = getArrayBounds,
		arrayToNodes = arrayToNodes,
		strToMap = stringMapToArray,
		around = around,
		drAround = drAround,
		traceBackPath = traceBackPath
	}

end
--- <strong>`A-star` algorithm</strong>.
-- Implementation of <a href="http://en.wikipedia.org/wiki/A-star">A*</a> search algorithm.
--
-- @author Roland Yonaba
-- @copyright 2012-2013
-- @license <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a>
-- @script jumper.search.astar


-- This implementation of A-star was based on Nash A. & al. pseudocode
-- Added override args to support dijkstra and thetaStar
-- http://aigamedev.com/open/tutorials/theta-star-any-angle-paths/

if (...) then

	s = require ((...):match('(.+)%.search.astar$') .. '.core.heuristics')
	
	-- Updates G-cost
	local function computeCost(node, neighbour, finder)
		local mCost = Heuristics.EUCLIDIAN(neighbour.x - node.x, neighbour.y - node.y)
		if node.g + mCost < neighbour.g then
			neighbour.parent = node
			neighbour.g = node.g + mCost
		end	
	end
	
	-- Updates vertex node-neighbour
	local function updateVertex(finder, node, neighbour, endNode, heuristic, overrideCostEval)
		local oldG = neighbour.g
		local cmpCost = overrideCostEval or computeCost
		cmpCost(node, neighbour, finder)
		if neighbour.g < oldG then
			if neighbour.opened then
				neighbour.opened = false
			end
			neighbour.h = heuristic(endNode.x - neighbour.x, endNode.y - neighbour.y)
			neighbour.f = neighbour.g + neighbour.h
			finder.openList:push(neighbour)
			neighbour.opened = true
		end	
	end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, toClear, tunnel, overrideHeuristic, overrideCostEval)
		local heuristic = overrideHeuristic or finder.heuristic
		
		finder.openList:clear()
		startNode.g = 0
		startNode.h = heuristic(endNode.x - startNode.x, endNode.y - startNode.y)
		startNode.f = startNode.g + startNode.h
		finder.openList:push(startNode)
		toClear[startNode] = true
		startNode.opened = true
		
		while not finder.openList:empty() do
			local node = finder.openList:pop()
			node.closed = true
			if node == endNode then
				return node
			end
			local neighbours = finder.grid:getNeighbours(node, finder.walkable, finder.allowDiagonal, tunnel)
			for i, neighbour in ipairs(neighbours) do
				if not neighbour.closed then
					toClear[neighbour] = true
					if not neighbour.opened then
						neighbour.g = huge
						neighbour.parent = nil					
					end
					updateVertex(finder, node, neighbour, endNode, heuristic, overrideCostEval)
				end			
			end		
		end		
		
		return nil
	end
	
end

--[[
Copyright (c) 2012-2013 Roland Yonaba

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--]]
--- <strong>`Breadth-First Search` algorithm</strong>.
-- Implementation of <a href="http://en.wikipedia.org/wiki/Breadth-first_search">Breadth-First Search</a> search algorithm.
--
-- @author Roland Yonaba
-- @copyright 2012-2013
-- @license <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a>
-- @script jumper.search.bfs



if (...) then
  -- Internalization
  local t_remove = table.remove

  local function breadth_first_search(finder, node, openList, toClear, tunnel)
    local neighbours = finder.grid:getNeighbours(node, finder.walkable, finder.allowDiagonal, tunnel)
    for i = 1,#neighbours do
      local neighbour = neighbours[i]
      if not neighbour.closed and not neighbour.opened then
        openList[#openList+1] = neighbour
        neighbour.opened = true
        neighbour.parent = node
        toClear[neighbour] = true
      end
    end

  end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, toClear, tunnel)

    local openList = {} -- We'll use a FIFO queue (simple array)
    openList[1] = startNode
    startNode.opened = true
    toClear[startNode] = true

    local node
    while (#openList > 0) do
      node = openList[1]
      t_remove(openList,1)
      node.closed = true

      if node == endNode then
        return node
      end

      breadth_first_search(finder, node, openList, toClear, tunnel)
    end

    return nil
  end

end

--[[
Copyright (c) 2012-2013 Roland Yonaba

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--]]
--- <strong>`Depth First Search` algorithm</strong>.
-- Implementation of <a href="http://en.wikipedia.org/wiki/Depth-first_search">Depth First Search</a> search algorithm.
--
-- @author Roland Yonaba
-- @copyright 2012-2013
-- @license <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a>
-- @script jumper.search.dfs



if (...) then
  -- Internalization
  local t_remove = table.remove

  local function depth_first_search(finder, node, openList, toClear)
    local neighbours = finder.grid:getNeighbours(node, finder.walkable, finder.allowDiagonal, tunnel)
    for i = 1,#neighbours do
      local neighbour = neighbours[i]
      if (not neighbour.closed and not neighbour.opened) then
        openList[#openList+1] = neighbour
        neighbour.opened = true
        neighbour.parent = node
        toClear[neighbour] = true
      end
    end

  end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, toClear, tunnel)

    local openList = {} -- We'll use a LIFO queue (simple array)
    openList[1] = startNode
    startNode.opened = true
    toClear[startNode] = true

    local node
    while (#openList > 0) do
      node = openList[#openList]
      t_remove(openList)
      node.closed = true

      if node == endNode then
        return node
      end

      depth_first_search(finder, node, openList, toClear, tunnel)
    end

    return nil
  end

end

--[[
Copyright (c) 2012-2013 Roland Yonaba

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--]]
--- <strong>`Dijkstra` algorithm</strong>.
-- Implementation of <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra</a> search algorithm
--
-- @author Roland Yonaba
-- @copyright 2012-2013
-- @license <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a>
-- @script jumper.search.dijkstra



if (...) then

  local astar_search = require ((...):gsub('%.dijkstra$','.astar'))
  -- Dijkstra is similar to aStar, with no heuristic
  local dijkstraHeuristic = function() return 0 end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, toClear, tunnel)
    return astar_search(finder, startNode, endNode, toClear, tunnel, dijkstraHeuristic)
  end

end

--[[
Copyright (c) 2012-2013 Roland Yonaba

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--]]
--- <strong>`Jump Point Search` algorithm</strong>.
-- This file holds an implementation of <a href="http://harablog.wordpress.com/2011/09/07/jump-point-search/">Jump Point Search</a> algorithm.
-- To quote its authors, __Jump Point Search__ is basically
-- "*an online symmetry breaking algorithm which speeds up pathfinding
-- on uniform-cost grid maps by __jumping over__ many locations that would otherwise
-- need to be explicitly considered* ".
--
-- It neither requires preprocessing, nor generates memory overhead, and thus performs consistently fast than classical A*.
--
-- The following implementation was written with respect to the core pseudo-code given in
-- its <a href="http://users.cecs.anu.edu.au/~dharabor/data/papers/harabor-grastien-aaai11.pdf">
-- technical papers,</a> plus a wide
-- range of optimizations and additional features.
--
-- @author Roland Yonaba
-- @copyright 2012-2013
-- @license <a href="http://www.opensource.org/licenses/mit-license.php">MIT</a>
-- @script jumper.search.jps


if (...) then

  -- Dependancies
  local _PATH = (...):match('(.+)%.search.jps$')
  local Heuristics = require (_PATH .. '.core.heuristics')

  -- Internalization
  local max, abs = math.max, math.abs

  -- Local helpers, these routines will stay private
  -- As they are internally used by the public interface

  -- Check if a node is reachable in diagonal-search mode
  -- Will prevent from "tunneling" issue when
  -- the goal node is neighbouring a starting location
  local step_first = false
  local function testFirstStep(finder, jNode, node)
    local is_reachable = true
    local jx, jy = jNode.x, jNode.y
    local dx,dy = jx-node.x, jy-node.y
    if dx <= -1 then
      if not finder.grid:isWalkableAt(jx+1,jy,finder.walkable) then is_reachable = false end
    elseif dx >= 1 then
      if not finder.grid:isWalkableAt(jx-1,jy,finder.walkable) then is_reachable = false end
    end
    if dy <= -1 then
      if not finder.grid:isWalkableAt(jx,jy+1,finder.walkable) then is_reachable = false end
    elseif dy >= 1 then
      if not finder.grid:isWalkableAt(jx,jy-1,finder.walkable) then is_reachable = false end
    end
    return not is_reachable
 end

  -- Resets properties of nodes expanded during a search
  -- This is a lot faster than resetting all nodes
  -- between consecutive pathfinding requests

  --[[
    Looks for the neighbours of a given node.
    Returns its natural neighbours plus forced neighbours when the given
    node has no parent (generally occurs with the starting node).
    Otherwise, based on the direction of move from the parent, returns
    neighbours while pruning directions which will lead to symmetric paths.

    In case diagonal moves are forbidden, when the given node has no
    parent, we return straight neighbours (up, down, left and right).
    Otherwise, we add left and right node (perpendicular to the direction
    of move) in the neighbours list.
  --]]
  local function findNeighbours(finder,node, tunnel)

    if node.parent then
      local neighbours = {}
      local x,y = node.x, node.y
      -- Node have a parent, we will prune some neighbours
      -- Gets the direction of move
      local dx = (x-node.parent.x)/max(abs(x-node.parent.x),1)
      local dy = (y-node.parent.y)/max(abs(y-node.parent.y),1)

        -- Diagonal move case
      if dx~=0 and dy~=0 then
        local walkY, walkX

        -- Natural neighbours
        if finder.grid:isWalkableAt(x,y+dy,finder.walkable) then
          neighbours[#neighbours+1] = finder.grid:getNodeAt(x,y+dy)
          walkY = true
        end
        if finder.grid:isWalkableAt(x+dx,y,finder.walkable) then
          neighbours[#neighbours+1] = finder.grid:getNodeAt(x+dx,y)
          walkX = true
        end
        if walkX or walkY then
          neighbours[#neighbours+1] = finder.grid:getNodeAt(x+dx,y+dy)
        end

        -- Forced neighbours
        if (not finder.grid:isWalkableAt(x-dx,y,finder.walkable)) and walkY then
          neighbours[#neighbours+1] = finder.grid:getNodeAt(x-dx,y+dy)
        end
        if (not finder.grid:isWalkableAt(x,y-dy,finder.walkable)) and walkX then
          neighbours[#neighbours+1] = finder.grid:getNodeAt(x+dx,y-dy)
        end

      else
        -- Move along Y-axis case
        if dx==0 then
          local walkY
          if finder.grid:isWalkableAt(x,y+dy,finder.walkable) then
            neighbours[#neighbours+1] = finder.grid:getNodeAt(x,y+dy)

            -- Forced neighbours are left and right ahead along Y
            if (not finder.grid:isWalkableAt(x+1,y,finder.walkable)) then
              neighbours[#neighbours+1] = finder.grid:getNodeAt(x+1,y+dy)
            end
            if (not finder.grid:isWalkableAt(x-1,y,finder.walkable)) then
              neighbours[#neighbours+1] = finder.grid:getNodeAt(x-1,y+dy)
            end
          end
          -- In case diagonal moves are forbidden : Needs to be optimized
          if not finder.allowDiagonal then
            if finder.grid:isWalkableAt(x+1,y,finder.walkable) then
              neighbours[#neighbours+1] = finder.grid:getNodeAt(x+1,y)
            end
            if finder.grid:isWalkableAt(x-1,y,finder.walkable)
              then neighbours[#neighbours+1] = finder.grid:getNodeAt(x-1,y)
            end
          end
        else
        -- Move along X-axis case
          if finder.grid:isWalkableAt(x+dx,y,finder.walkable) then
            neighbours[#neighbours+1] = finder.grid:getNodeAt(x+dx,y)

            -- Forced neighbours are up and down ahead along X
            if (not finder.grid:isWalkableAt(x,y+1,finder.walkable)) then
              neighbours[#neighbours+1] = finder.grid:getNodeAt(x+dx,y+1)
            end
            if (not finder.grid:isWalkableAt(x,y-1,finder.walkable)) then
              neighbours[#neighbours+1] = finder.grid:getNodeAt(x+dx,y-1)
            end
          end
          -- : In case diagonal moves are forbidden
          if not finder.allowDiagonal then
            if finder.grid:isWalkableAt(x,y+1,finder.walkable) then
              neighbours[#neighbours+1] = finder.grid:getNodeAt(x,y+1)
            end
            if finder.grid:isWalkableAt(x,y-1,finder.walkable) then
              neighbours[#neighbours+1] = finder.grid:getNodeAt(x,y-1)
            end
          end
        end
      end
      return neighbours
    end

    -- Node do not have parent, we return all neighbouring nodes
    return finder.grid:getNeighbours(node, finder.walkable, finder.allowDiagonal, tunnel)
  end

  --[[
    Searches for a jump point (or a turning point) in a specific direction.
    This is a generic translation of the algorithm 2 in the paper:
      http://users.cecs.anu.edu.au/~dharabor/data/papers/harabor-grastien-aaai11.pdf
    The current expanded node is a jump point if near a forced node

    In case diagonal moves are forbidden, when lateral nodes (perpendicular to
    the direction of moves are walkable, we force them to be turning points in other
    to perform a straight move.
  --]]
  local function jump(finder, node, parent, endNode)
	if not node then return end

    local x,y = node.x, node.y
    local dx, dy = x - parent.x,y - parent.y

    -- If the node to be examined is unwalkable, return nil
    if not finder.grid:isWalkableAt(x,y,finder.walkable) then return end

    -- If the node to be examined is the endNode, return this node
    if node == endNode then return node end

    -- Diagonal search case
    if dx~=0 and dy~=0 then
      -- Current node is a jump point if one of his leftside/rightside neighbours ahead is forced
      if (finder.grid:isWalkableAt(x-dx,y+dy,finder.walkable) and (not finder.grid:isWalkableAt(x-dx,y,finder.walkable))) or
         (finder.grid:isWalkableAt(x+dx,y-dy,finder.walkable) and (not finder.grid:isWalkableAt(x,y-dy,finder.walkable))) then
        return node
      end
    else
      -- Search along X-axis case
      if dx~=0 then
        if finder.allowDiagonal then
          -- Current node is a jump point if one of his upside/downside neighbours is forced
          if (finder.grid:isWalkableAt(x+dx,y+1,finder.walkable) and (not finder.grid:isWalkableAt(x,y+1,finder.walkable))) or
             (finder.grid:isWalkableAt(x+dx,y-1,finder.walkable) and (not finder.grid:isWalkableAt(x,y-1,finder.walkable))) then
            return node
          end
        else
          -- : in case diagonal moves are forbidden
          if finder.grid:isWalkableAt(x+1,y,finder.walkable) or finder.grid:isWalkableAt(x-1,y,finder.walkable) then return node end
        end
      else
      -- Search along Y-axis case
        -- Current node is a jump point if one of his leftside/rightside neighbours is forced
        if finder.allowDiagonal then
          if (finder.grid:isWalkableAt(x+1,y+dy,finder.walkable) and (not finder.grid:isWalkableAt(x+1,y,finder.walkable))) or
             (finder.grid:isWalkableAt(x-1,y+dy,finder.walkable) and (not finder.grid:isWalkableAt(x-1,y,finder.walkable))) then
            return node
          end
        else
          -- : in case diagonal moves are forbidden
          if finder.grid:isWalkableAt(x,y+1,finder.walkable) or finder.grid:isWalkableAt(x,y-1,finder.walkable) then return node end
        end
      end
    end

    -- Recursive horizontal/vertical search
    if dx~=0 and dy~=0 then
      if jump(finder,finder.grid:getNodeAt(x+dx,y),node,endNode) then return node end
      if jump(finder,finder.grid:getNodeAt(x,y+dy),node,endNode) then return node end
    end

    -- Recursive diagonal search
    if finder.allowDiagonal then
      if finder.grid:isWalkableAt(x+dx,y,finder.walkable) or finder.grid:isWalkableAt(x,y+dy,finder.walkable) then
        return jump(finder,finder.grid:getNodeAt(x+dx,y+dy),node,endNode)
      end
    end
end

  --[[
    Searches for successors of a given node in the direction of each of its neighbours.
    This is a generic translation of the algorithm 1 in the paper:
      http://users.cecs.anu.edu.au/~dharabor/data/papers/harabor-grastien-aaai11.pdf

    Also, we notice that processing neighbours in a reverse order producing a natural
    looking path, as the pathfinder tends to keep heading in the same direction.
    In case a jump point was found, and this node happened to be diagonal to the
    node currently expanded in a straight mode search, we skip this jump point.
  --]]
  local function identifySuccessors(finder,node,endNode,toClear, tunnel)

    -- Gets the valid neighbours of the given node
    -- Looks for a jump point in the direction of each neighbour
    local neighbours = findNeighbours(finder,node, tunnel)
    for i = #neighbours,1,-1 do

      local skip = false
      local neighbour = neighbours[i]
      local jumpNode = jump(finder,neighbour,node,endNode)

      -- : in case a diagonal jump point was found in straight mode, skip it.
      if jumpNode and not finder.allowDiagonal then
        if ((jumpNode.x ~= node.x) and (jumpNode.y ~= node.y)) then skip = true end
      end

			--[[
      -- Hacky trick to discard "tunneling" in diagonal mode search for the first step
      if jumpNode and finder.allowDiagonal and not step_first then
        if jumpNode.x == endNode.x and jumpNode.y == endNode.y then
          step_first = true
          if not skip then
            skip = testFirstStep(finder, jumpNode, node)
          end
        end
      end
			--]]
      -- Performs regular A-star on a set of jump points
      if jumpNode and not skip then
        -- Update the jump node and move it in the closed list if it wasn't there
        if not jumpNode.closed then
          local extraG = Heuristics.EUCLIDIAN(jumpNode.x-node.x,jumpNode.y-node.y)
          local newG = node.g + extraG
          if not jumpNode.opened or newG < jumpNode.g then
            toClear[jumpNode] = true -- Records this node to reset its properties later.
            jumpNode.g = newG
            jumpNode.h = jumpNode.h or
              (finder.heuristic(jumpNode.x-endNode.x,jumpNode.y-endNode.y))
            jumpNode.f = jumpNode.g+jumpNode.h
            jumpNode.parent = node
            if not jumpNode.opened then
              finder.openList:push(jumpNode)
              jumpNode.opened = true
              if not step_first then step_first = true end
            else
              finder.openList:heapify(jumpNode)
            end
          end
        end
      end
    end
  end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function(finder, startNode, endNode, toClear, tunnel)

    step_first = false
    startNode.g, startNode.f = 0,0
    finder.openList:clear()
    finder.openList:push(startNode)
    startNode.opened = true
    toClear[startNode] = true

    local node
    while not finder.openList:empty() do
      -- Pops the lowest F-cost node, moves it in the closed list
      node = finder.openList:pop()
      node.closed = true
        -- If the popped node is the endNode, return it
        if node == endNode then
          return node
        end
      -- otherwise, identify successors of the popped node
      identifySuccessors(finder, node, endNode, toClear, tunnel)
    end

    -- No path found, return nil
    return nil
  end

end

--[[
Copyright (c) 2012-2013 Roland Yonaba

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--]]
-- ThetaStar implementation
-- See: http://aigamedev.com/open/tutorials/theta-star-any-angle-paths for reference

if (...) then
	
	local _PATH = (...):gsub('%.search.thetastar$','')

	-- Depandancies
	local Heuristics   = require (_PATH .. '.core.heuristics')
	local astar_search = require (_PATH .. '.search.astar')

	-- Internalization
	local ipairs = ipairs
	local huge, abs = math._huge, math.abs
	
	-- Line Of Sight (Bresenham's line marching algorithm)
	-- http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm
	local lineOfSight = function (node, neighbour, finder, clearance)
		local x0, y0 = node._x, node._y
		local x1, y1 = neighbour._x, neighbour._y
		local dx = abs(x1-x0)
		local dy = abs(y1-y0)
		local err = dx - dy
		local sx = (x0 < x1) and 1 or -1
		local sy = (y0 < y1) and 1 or -1		

		while true do
			if not finder._grid:isWalkableAt(x0, y0, finder._walkable, finder._tunnel, clearance) then 
				return false 
			end
			if x0 == x1 and y0 == y1 then
				break
			end
			local e2 = 2*err
			if e2 > -dy then
				err = err - dy
				x0 = x0 + sx
			end
			if e2 < dx then
				err = err + dx
				y0 = y0 + sy
			end
		end
		return true
	end
	
	-- Theta star cost evaluation
	local function computeCost(node, neighbour, finder, clearance)
		local parent = node._parent or node
		local mpCost = Heuristics.EUCLIDIAN(neighbour, parent)
		if lineOfSight(parent, neighbour, finder, clearance) then
			if parent._g + mpCost < neighbour._g then
				neighbour._parent = parent
				neighbour._g = parent._g + mpCost
			end
		else
			local mCost = Heuristics.EUCLIDIAN(neighbour, node)
			if node._g + mCost < neighbour._g then
				neighbour._parent = node
				neighbour._g = node._g + mCost
			end
		end
	end

  -- Calculates a path.
  -- Returns the path from location `<startX, startY>` to location `<endX, endY>`.
  return function (finder, startNode, endNode, clearance, toClear, overrideHeuristic)
    return astar_search(finder, startNode, endNode, clearance, toClear, overrideHeuristic, computeCost)
	end

end--[[
    This file is a part of the J2H client
    J2H is a free MMO-game (not yet released)
    ----

    Copyright (C) 2008-2011  TsT <tst@worldmaster.fr>

    This program is free software: you can redistribute it and/or
    modify it under the terms of the GNU General Public License as
    published by the Free Software Foundation, either version 3 of
    the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
]]--

--[[
  Hello,
  If you found a bug or have a question, don't hesitate to contact me
  by email at <tst@worldmaster.fr> (in french or english please)
  Thanks,
  Have fun!
]]--

--[[ VERSION=0.1.0 20110425 ]]--

assert(love, "love required")
assert(love.graphics, "the love.graphics module was required")

if love and not love.screen then love.screen = {} end

-- function to copy some love.graphics.* functions
local import = function()
	local m = {}

	-- list of the love.graphics functions to copy
	local tocopy = {"getCaption", "setCaption", "checkMode", "getModes", "setMode", "toggleFullscreen", "getHeight", "getWidth"}

	for i,f in ipairs(tocopy) do
		if love.graphics and love.graphics[f] then
			m[f] = love.graphics[f]
		end
	end

	return m
end

local internal = {}
internal.lovegraphics = import()
internal.screens = {} -- empty screen list
internal.defaultscreen = "main"
internal.defaultvsync = false
internal.defaultfsaa = 0
internal.defaultfullscreen = false

------------------------------------------------
-- define the Screen object and his functions --
------------------------------------------------

local Screen = {}
Screen.__index = Screen
Screen.screens = {}

local function newScreen(name)
	local self = {}
	setmetatable(self, Screen)

	self.name = name

	self.type = "screen"
	self.title = ""
	self.height = 0
	self.width = 0
	self.vsync = false
	self.fsaa = 0

	table.insert(internal.screens, self) -- register the new screen into the screen list

	return self
end

function Screen:getCaption()
	return self.title
end

function Screen:setCaption(title)
	if self.isMain then
		internal.lovegraphics.setCaption(title)
	end
	self.title = title
end

function Screen:checkMode(width, height, fullscreen)
	if self.isMain then
        	return internal.lovegraphics.checkMode(width, height, fullscreen)
	end
	return true
end

function Screen:getModes()
	if self.isMain then
		return internal.lovegraphics.getModes()
	end
	return nil
end

function Screen:setMode(width, height, fullscreen, vsync, fsaa)
	width      = width      ~= nil and width      or self.width
	height     = height     ~= nil and height     or self.height
	fullscreen = fullscreen ~= nil and fullscreen or self.fullscreen
	vsync      = vsync      ~= nil and vsync      or self.vsync
	fsaa       = fsaa       ~= nil and fsaa       or self.fsaa

	local ok = true
	if self.isMain then
		ok = internal.lovegraphics.setMode(width, height, fullscreen, vsync, fsaa)
	end
	if ok then
		self.width = width
		self.height = height
		self.fullscreen = fullscreen
		self.vsync = vsync
		self.fsaa = fsaa
	end
	return ok
end

function Screen:toggleFullscreen()
	local ok = true
	if self.isMain then
		ok = internal.lovegraphics.toggleFullscreen()
	end
	if ok then
		self.fullscreen = not fullscreen
	end
	return ok
end

function Screen:getHeight()
	return self.height
end

function Screen:getWidth()
	return self.width
end

function Screen:getFullscreen()
	return self.fullscreen
end

function Screen:getVsync()
	return self.vsync
end

function Screen:getFsaa()
	return self.fsaa
end

function Screen:getMode(width, height, fullscreen, vsync, fsaa)
	width      = width      ~= nil and width      or self.width
	height     = height     ~= nil and height     or self.height
	fullscreen = fullscreen ~= nil and fullscreen or self.fullscreen
	vsync      = vsync      ~= nil and vsync      or self.vsync
	fsaa       = fsaa       ~= nil and fsaa       or self.fsaa
	return width, height, fullscreen, vsync, fsaa
end

---------------------------------
-- the love.screen.* functions --
---------------------------------

local function initCheck()
	if #internal.screens == 0 then
		error("ERROR: the screen list is empty. Remember to run the love.screen.init() before")
	end
end

local function getScreen(name)
	initCheck()
	name = name or internal.defaultscreen
	for i,v in ipairs(internal.screens) do
		if v.name == name then
			return v
		end
	end
	error("Unknown screen name")
end

local function getNumScreens()
	return #internal.screens
end

local function getScreens()
	initCheck()
        return internal.screens
end

local function init()
	local screen = newScreen(internal.defaultscreen)
	screen.isMain = true

	-- get the default settings from love.conf (usually defined in conf.lua)
	local t = {}
	if love and love.conf then
		t.screen = {}
		t.modules = {}
		-- load default settings
		love.conf(t)
	end

	-- apply default settings if not already set (for fullscreen, vsync and fsaa)
	if not t.screen then t.screen = {} end
	if not t.screen.fullscreen then t.screen.fullscreen = internal.defaultfullscreen end
	if not t.screen.vsync then t.screen.vsync = internal.defaultvsync end
	if not t.screen.fsaa then t.screen.fsaa = internal.defaultfsaa end

	-- title, width and height can be get drectly with love functions
	screen.title = love.window.getTitle()
	screen.width = love.graphics.getWidth()
	screen.height = love.graphics.getHeight()
	screen.fullscreen = t.screen.fullscreen
	screen.vsync = t.screen.vsync
	screen.fsaa = t.screen.fsaa
end


-- public functions

love.screen.newScreen = newScreen
love.screen.getScreen = getScreen
love.screen.getNumScreens = getNumScreens
love.screen.getScreens = getScreens
love.screen.init = init
--[[
    This file is a part of the J2H client
    J2H is a free MMO-game (not yet released)
    ----

    Copyright (C) 2008-2011  TsT <tst@worldmaster.fr>

    This program is free software: you can redistribute it and/or
    modify it under the terms of the GNU General Public License as
    published by the Free Software Foundation, either version 3 of
    the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
]]--

--[[
  Hello,
  If you found a bug or have a question, don't hesitate to contact me
  by email at <tst@worldmaster.fr> (in french or english please)
  Thanks,
  Have fun!
]]--

--[[ VERSION=0.1.0 20110425 ]]--

assert(love, "love required")
assert(love.graphics, "the love.graphics module was required")

if love and not love.screen then love.screen = {} end

-- function to copy some love.graphics.* functions
local import = function()
	local m = {}

	-- list of the love.graphics functions to copy
	local tocopy = {"getCaption", "setCaption", "checkMode", "getModes", "setMode", "toggleFullscreen", "getHeight", "getWidth"}

	for i,f in ipairs(tocopy) do
		if love.graphics and love.graphics[f] then
			m[f] = love.graphics[f]
		end
	end

	return m
end

local internal = {}
internal.lovegraphics = import()
internal.screens = {} -- empty screen list
internal.defaultscreen = "main"
internal.defaultvsync = false
internal.defaultfsaa = 0
internal.defaultfullscreen = false

------------------------------------------------
-- define the Screen object and his functions --
------------------------------------------------

local Screen = {}
Screen.__index = Screen
Screen.screens = {}

local function newScreen(name)
	local self = {}
	setmetatable(self, Screen)

	self.name = name

	self.type = "screen"
	self.title = ""
	self.height = 0
	self.width = 0
	self.vsync = false
	self.fsaa = 0

	table.insert(internal.screens, self) -- register the new screen into the screen list

	return self
end

function Screen:getCaption()
	return self.title
end

function Screen:setCaption(title)
	if self.isMain then
		internal.lovegraphics.setCaption(title)
	end
	self.title = title
end

function Screen:checkMode(width, height, fullscreen)
	if self.isMain then
        	return internal.lovegraphics.checkMode(width, height, fullscreen)
	end
	return true
end

function Screen:getModes()
	if self.isMain then
		return internal.lovegraphics.getModes()
	end
	return nil
end

function Screen:setMode(width, height, fullscreen, vsync, fsaa)
	width      = width      ~= nil and width      or self.width
	height     = height     ~= nil and height     or self.height
	fullscreen = fullscreen ~= nil and fullscreen or self.fullscreen
	vsync      = vsync      ~= nil and vsync      or self.vsync
	fsaa       = fsaa       ~= nil and fsaa       or self.fsaa

	local ok = true
	if self.isMain then
		ok = internal.lovegraphics.setMode(width, height, fullscreen, vsync, fsaa)
	end
	if ok then
		self.width = width
		self.height = height
		self.fullscreen = fullscreen
		self.vsync = vsync
		self.fsaa = fsaa
	end
	return ok
end

function Screen:toggleFullscreen()
	local ok = true
	if self.isMain then
		ok = internal.lovegraphics.toggleFullscreen()
	end
	if ok then
		self.fullscreen = not fullscreen
	end
	return ok
end

function Screen:getHeight()
	return self.height
end

function Screen:getWidth()
	return self.width
end

function Screen:getFullscreen()
	return self.fullscreen
end

function Screen:getVsync()
	return self.vsync
end

function Screen:getFsaa()
	return self.fsaa
end

function Screen:getMode(width, height, fullscreen, vsync, fsaa)
	width      = width      ~= nil and width      or self.width
	height     = height     ~= nil and height     or self.height
	fullscreen = fullscreen ~= nil and fullscreen or self.fullscreen
	vsync      = vsync      ~= nil and vsync      or self.vsync
	fsaa       = fsaa       ~= nil and fsaa       or self.fsaa
	return width, height, fullscreen, vsync, fsaa
end

---------------------------------
-- the love.screen.* functions --
---------------------------------

local function initCheck()
	if #internal.screens == 0 then
		error("ERROR: the screen list is empty. Remember to run the love.screen.init() before")
	end
end

local function getScreen(name)
	initCheck()
	name = name or internal.defaultscreen
	for i,v in ipairs(internal.screens) do
		if v.name == name then
			return v
		end
	end
	error("Unknown screen name")
end

local function getNumScreens()
	return #internal.screens
end

local function getScreens()
	initCheck()
        return internal.screens
end

local function init()
	local screen = newScreen(internal.defaultscreen)
	screen.isMain = true

	-- get the default settings from love.conf (usually defined in conf.lua)
	local t = {}
	if love and love.conf then
		t.screen = {}
		t.modules = {}
		-- load default settings
		love.conf(t)
	end

	-- apply default settings if not already set (for fullscreen, vsync and fsaa)
	if not t.screen then t.screen = {} end
	if not t.screen.fullscreen then t.screen.fullscreen = internal.defaultfullscreen end
	if not t.screen.vsync then t.screen.vsync = internal.defaultvsync end
	if not t.screen.fsaa then t.screen.fsaa = internal.defaultfsaa end

	-- title, width and height can be get drectly with love functions
	screen.title = love.window.getTitle()
	screen.width = love.graphics.getWidth()
	screen.height = love.graphics.getHeight()
	screen.fullscreen = t.screen.fullscreen
	screen.vsync = t.screen.vsync
	screen.fsaa = t.screen.fsaa
end


-- public functions

love.screen.newScreen = newScreen
love.screen.getScreen = getScreen
love.screen.getNumScreens = getNumScreens
love.screen.getScreens = getScreens
love.screen.init = init
package = "jumper"
version = "1.6-2"
source = {
   url = "https://github.com/Yonaba/Jumper/archive/jumper-1.6-2.tar.gz",
   dir = "Jumper-jumper-1.6-2"
}
description = {
   summary = "Fast and easy-to-use pathfinding library for 2D grid-bases games",
   detailed = [[
      Jumper is a pathfinding library designed for uniform-cost 2D grid-based games. It features a mix of A-Star, Jump Point Search
	  and Binary-Heaps. It aims to be fast and lightweight. It also features a clean public interface with chaining features 
	  which makes it very friendly and easy to use.
   ]],
   homepage = "http://github.com/Yonaba/Jumper",
   license = "MIT <http://www.opensource.org/licenses/mit-license.php>"
}
dependencies = {
   "lua >= 5.1"
}
build = {
  type = "builtin",
  modules = {
    ["init"] = "init.lua",
    ["jumper"] = "jumper.lua",
    ["core.bheap"] = "core/bheap.lua",
    ["core.grid"] = "core/grid.lua",
    ["core.heuristics"] = "core/heuristics.lua",
    ["core.node"] = "core/node.lua"
  }
}package = "jumper"
version = "1.6.3-1"
source = {
   url = "https://github.com/Yonaba/Jumper/archive/jumper-1.6.3-1.tar.gz",
   dir = "Jumper-jumper-1.6.3-1"
}
description = {
   summary = "Fast and easy-to-use pathfinding library for 2D grid-bases games",
   detailed = [[
      Jumper is a pathfinding library designed for uniform-cost 2D grid-based games. It features a mix of A-Star, Jump Point Search
	  and Binary-Heaps. It aims to be fast and lightweight. It also features a clean public interface with chaining features 
	  which makes it very friendly and easy to use.
   ]],
   homepage = "http://github.com/Yonaba/Jumper",
   license = "MIT <http://www.opensource.org/licenses/mit-license.php>"
}
dependencies = {
   "lua >= 5.1"
}
build = {
  type = "builtin",
  modules = {
    ["init"] = "init.lua",
    ["jumper"] = "jumper.lua",
    ["core.bheap"] = "core/bheap.lua",
    ["core.grid"] = "core/grid.lua",
    ["core.heuristics"] = "core/heuristics.lua",
    ["core.node"] = "core/node.lua"
  }
}package = "jumper"
version = "1.7.0-1"
source = {
   url = "https://github.com/Yonaba/Jumper/archive/jumper-1.7.0-1.tar.gz",
   dir = "Jumper-jumper-1.7.0-1"
}
description = {
   summary = "Fast and easy-to-use pathfinding library for 2D grid-based games",
   detailed = [[
      Jumper is a pathfinding library designed for 2D grid-based games.
      It aims to be fast and lightweight. It also features a clean public interface with chaining features 
      which makes it very friendly and easy to use.
   ]],
   homepage = "http://github.com/Yonaba/Jumper",
   license = "MIT <http://www.opensource.org/licenses/mit-license.php>",
   maintainer = "Roland Yonaba <roland.yonaba@gmail.com>",
}
dependencies = {
   "lua >= 5.1"
}
build = {
   type = "builtin",
   modules = {
      ["jumper.init"] = "jumper/init.lua",
      ["jumper.pathfinder"] = "jumper/pathfinder.lua",
      ["jumper.core.bheap"] = "jumper/core/bheap.lua",
      ["jumper.core.grid"] = "jumper/core/grid.lua",
      ["jumper.core.heuristics"] = "jumper/core/heuristics.lua",
      ["jumper.core.node"] = "jumper/core/node.lua",
      ["jumper.search.astar"] = "jumper/search/astar.lua",
      ["jumper.search.jps"] = "jumper/search/jps.lua",
   },
   copy_directories = {"docs"}
}
package = "jumper"
version = "1.8.0"
source = {
   url = "https://github.com/Yonaba/Jumper/archive/jumper-1.8.0.tar.gz",
   dir = "Jumper-jumper-1.8.0"
}
description = {
   summary = "Fast and easy-to-use pathfinding library for grid-based games",
   detailed = [[
      Jumper is a pathfinding library designed for grid-based games.
      It aims to be fast and lightweight. It also features wide range of search algorithms, 
	  a clean public interface with chaining features  which makes it very friendly and easy to use.
   ]],
   homepage = "http://github.com/Yonaba/Jumper",
   license = "MIT <http://www.opensource.org/licenses/mit-license.php>",
   maintainer = "Roland Yonaba <roland.yonaba@gmail.com>",
}
dependencies = {
   "lua >= 5.1"
}
build = {
   type = "builtin",
   modules = {
      ["jumper.grid"] = "jumper/grid.lua",
      ["jumper.pathfinder"] = "jumper/pathfinder.lua",
      ["jumper.core.bheap"] = "jumper/core/bheap.lua",
      ["jumper.core.heuristics"] = "jumper/core/heuristics.lua",
      ["jumper.core.node"] = "jumper/core/node.lua",
      ["jumper.core.path"] = "jumper/core/path.lua",
      ["jumper.search.astar"] = "jumper/search/astar.lua",
      ["jumper.search.jps"] = "jumper/search/jps.lua",
      ["jumper.search.dijkstra"] = "jumper/search/dijkstra.lua",
      ["jumper.search.bfs"] = "jumper/search/bfs.lua",
      ["jumper.search.dfs"] = "jumper/search/dfs.lua",
   },
   copy_directories = {"docs"}
}
package = "jumper"
version = "1.8.1-1"
source = {
   url = "https://github.com/Yonaba/Jumper/archive/jumper-1.8.1-1.tar.gz",
   dir = "Jumper-jumper-1.8.1-1"
}
description = {
   summary = "Fast and easy-to-use pathfinding library for grid-based games",
   detailed = [[
      Jumper is a pathfinding library designed for grid-based games.
      It aims to be fast and lightweight. It also features wide range of search algorithms, 
	  a clean public interface with chaining features  which makes it very friendly and easy to use.
   ]],
   homepage = "http://github.com/Yonaba/Jumper",
   license = "MIT <http://www.opensource.org/licenses/mit-license.php>",
   maintainer = "Roland Yonaba <roland.yonaba@gmail.com>",
}
dependencies = {
   "lua >= 5.1"
}
build = {
   type = "builtin",
   modules = {
      ["jumper.grid"] = "jumper/grid.lua",
      ["jumper.pathfinder"] = "jumper/pathfinder.lua",
      ["jumper.core.bheap"] = "jumper/core/bheap.lua",
      ["jumper.core.heuristics"] = "jumper/core/heuristics.lua",
      ["jumper.core.node"] = "jumper/core/node.lua",
      ["jumper.core.path"] = "jumper/core/path.lua",
      ["jumper.search.astar"] = "jumper/search/astar.lua",
      ["jumper.search.jps"] = "jumper/search/jps.lua",
      ["jumper.search.dijkstra"] = "jumper/search/dijkstra.lua",
      ["jumper.search.bfs"] = "jumper/search/bfs.lua",
      ["jumper.search.dfs"] = "jumper/search/dfs.lua",
   },
   copy_directories = {"docs","specs"}
}
context('Module BHeap', function()	
	local BHeap 
	
	before(function()
		BHeap = require ('jumper.core.bheap')
	end)
	
	context('BHeap class', function()
	
		test('BHeap() instantiates a new heap object', function()
			assert_equal(getmetatable(BHeap()), BHeap)
		end)
		
		test('the new heap is empty', function()
			assert_true((BHeap()):empty())
		end)
		
		test('items can be pushed inside', function()
			local h = BHeap()
			h:push(1):push(2):push(3)
			assert_equal(h.size, 3)
		end)
		
		test('popping returns the lowest element by default (< operator)', function()
			local h = BHeap()
			h:push(1):push(2):push(0)
			
			assert_equal(h:pop(),0)
			assert_equal(h:pop(),1)
			assert_equal(h:pop(),2)
			assert_nil(h:pop())
		end)
		
		test('a heap can be cleared', function()
			local h = BHeap()
			assert_true(h:empty())
			
			h:push(1):push(2):push(3)
			assert_false(h:empty())
			
			h:clear()
			assert_true(h:empty())			
		end)
		
		test('one can define a custom sort function', function()
			local sort = function(a,b) return a>b end
			local h = BHeap(sort)
			h:push(1):push(2):push(3)
			
			assert_equal(h:pop(),3)
			assert_equal(h:pop(),2)
			assert_equal(h:pop(),1)
			assert_nil(h:pop())
		end)		

		test('items pushed can be objects, with a custom sort function', function()
			local sortNode = function(a, b) return a.cost < b.cost end
			local makeObj = function(cost) return {cost = cost} end
			local h = BHeap(sortNode)
			h:push(makeObj(1)):push(makeObj(2)):push(makeObj(3))
			
			assert_equal(h:pop().cost,1)
			assert_equal(h:pop().cost,2)
			assert_equal(h:pop().cost,3)
			assert_nil(h:pop())					
		end)
		
		test('pushing a alue that cannot be compared to the previous ones raises an error', function()
			local h = BHeap()
			h:push(false)
			assert_error(pcall(h.push, h, false))
			assert_error(pcall(h.push, h, true))		
			assert_error(pcall(h.push, h, {}))		
			assert_error(pcall(h.push, h, function() end))		
		end)
		
		test('pushing nil does nothing', function()
			local h = BHeap()
			h:push()
			
			assert_true(h:empty())
			h:push(1):push()
			
			assert_false(h:empty())
			assert_equal(h.size,1)
		end)
		
		test('popping an empty heap returns nil', function()
			local h = BHeap()
			assert_nil(h:pop())		
		end)
		
		test('BHeap:heapify() forces a sort of the heap', function()
		
			local h = BHeap()
			local sort = function(a,b) return a.value < b.value end
			local function makeObj(v) return {value = v} end
			local h = BHeap(sort)
			local A, B, C = makeObj(1), makeObj(2), makeObj(3)
			
			h:push(A):push(B):push(C)
			C.value = 0
			h:heapify(C)
			
			local ret = h:pop()
			assert_true(ret == C)
			assert_equal(ret.value,0)
			
			local ret = h:pop()
			assert_true(ret == A)
			assert_equal(ret.value,1)

			local ret = h:pop()
			assert_true(ret == B)
			assert_equal(ret.value,2)
			
			h:push(A):push(B):push(C)
			C.value, B.value, A.value = 3, 2, 100
			h:heapify()

			local ret = h:pop()
			assert_true(ret == B)
			assert_equal(ret.value,2)
			
			local ret = h:pop()
			assert_true(ret == C)
			assert_equal(ret.value,3)

			local ret = h:pop()
			assert_true(ret == A)
			assert_equal(ret.value,100)
		
		end)
		
		
	end)
	
end)context('Module Grid', function()
	local Grid, Node
	
	before(function()
		Grid = require ('jumper.grid')
		Node = require ('jumper.core.node')
  end)
	
  context('Grid:new() or Grid() returns a new Grid object', function()
		
		test('Grid:new() or Grid() returns a new Grid object', function()
			assert_equal(getmetatable(getmetatable(Grid:new({{0}}))),Grid)
			assert_equal(getmetatable(getmetatable(Grid({{0}}))),Grid)
		end)
			
		test('Grid:new() requires a collision map upon initialization', function()
			local map = {{0,0},{0,0}}
			assert_not_nil(Grid:new(map))
		end)
			
		test('The passed-in map can be a string', function()
			local map = '00\n00'
			assert_not_nil(Grid:new(map))
		end)
			
		test('passing nil to Grid:new() or Grid() causes an error', function()
			assert_error(pcall(Grid, Grid))
			assert_error(pcall(Grid.new, Grid))
		end)			
			
		test('Grid and map should have the same width', function()
			local map = '00\n00'
			local map = {{0,0},{0,0}}
			local grid = Grid(map)
			local grid2 = Grid(map)
			assert_equal(grid.width, 2)
			assert_equal(grid2.width, 2)	
		end)	
		
		test('Grid and map should have the same height', function()
			local map = '00\n00\n00'
			local map2 = {{0,0},{0,0},{0,0},{0,0}}
			local grid = Grid(map)
			local grid2 = Grid(map2)
			assert_equal(grid.height, 3)
			assert_equal(grid2.height, 4)	
		end)
		
		test('Each value on the map matches a node on the grid', function()
			local map = {{0,0},{0,0},{0,0},{0,0}}
			local grid = Grid(map)
			
			for y in pairs(map) do
				for x in pairs(map[y]) do
					local node = grid:getNodeAt(x,y)
					assert_not_nil(node)
					assert_equal(getmetatable(node), Node)
				end
			end
		end)
		
		test('the passed-in map should have a width greather than 0',function()
			assert_error(pcall(Grid, Grid, {{},{}}))
			assert_error(pcall(Grid, Grid, '\n\n'))
		end)

		test('the passed-in map should have a height greather than 0',function()
			assert_error(pcall(Grid, Grid, {}))
			assert_error(pcall(Grid, Grid, ''))
		end)
		
		test('the passed-in map should have rows with the same width',function()
			assert_error(pcall(Grid, Grid, {{0},{0,0}}))
			assert_error(pcall(Grid, Grid, '00\n000'))
		end)

		test('values in the map should only be integers or strings',function()
			assert_error(pcall(Grid, Grid, {{0.1,0,0},{0,0,0}}))
			assert_error(pcall(Grid, Grid, {{0,function() end,0},{0,0,0}}))
		end)
		
	end)
	
	context('Grid types', function()
		
		test('passing a 2nd arg to Grid:new() or Grid() returns a postprocessed grid', function()
			local grid = Grid({{0}})
			local pgrid = Grid({{0}},true)
			assert_not_equal(getmetatable(grid), getmetatable(pgrid))
			assert_equal(getmetatable(getmetatable(grid)), getmetatable(getmetatable(pgrid)))
		end)
		
		test('postprocessed grids are memory safe, as nodes are cached on purpose', function()
			local map = {{0,0,0},{0,0,0},{0,0,0}}
			local pgrid = Grid(map, true)
			
			assert_equal(#pgrid:getNodes(), 0)
			local count = 0
			for node in pgrid:iter() do
				assert_equal(getmetatable(node), Node)
				count = count+1
			end
			assert_equal(count, pgrid.width*pgrid.height)
		end)
		
	end)
	
	context('Grid:isWalkablkeAt', function()
		
			test('returns whether or not a node is walkable',function()
				local map = {{0,0},{0,0},{0,1},{0,0}}
				local grid = Grid(map)			
				local walkable = 1
				
				for y in pairs(map) do
					for x in pairs(map[y]) do
						if map[y][x] == walkable then
							assert_true(grid:isWalkableAt(x,y,walkable))
						else
							assert_false(grid:isWalkableAt(x,y,walkable))
						end
					end
				end
				
				map = 'WXW\nWWW\n'
				grid = Grid(map)			
				walkable = 'W'
				
				for y = 1,2 do
					for x = 1,3 do
						if x==2 and y==1 then
							assert_false(grid:isWalkableAt(x,y,walkable))
						else
							assert_true(grid:isWalkableAt(x,y,walkable))
						end
					end
				end
				
			end)

			test('All nodes are walkable when no walkability rule was set', function()
				local map = {{0,0},{0,0}}
				local grid = Grid(map)
				
				for y in pairs(map) do
					for x in pairs(map[y]) do
						assert_true(grid:isWalkableAt(x,y,walkable))
					end
				end
			end)
		
	end)
		
	context('Grid:getMap()', function()
		
			test('returns the collision map',function()
				local map = {{0,0},{0,0}}
				local grid = Grid(map)
				assert_equal(grid:getMap(), map)
			end)
		
			test('returns the array parsed from a given that string',function()
				local map = '00\n00'
				local grid = Grid(map)
				assert_equal(type(grid:getMap()), 'table')
				assert_not_equal(grid:getMap(), map)
			end)
		
	end)
	
	context('Grid:getNodeAt()', function()
			local map, grid
			before(function()
				map = {
					{0,0,0,0},
					{0,0,0,0},
				}
				grid = Grid(map)
      end)
			
			test('returns the node at a given position', function()
				local node = grid:getNodeAt(1,1)
				assert_equal(getmetatable(node),Node)
				assert_equal(node.x,1)
				assert_equal(node.y,1)
			end)
			
			test('returns nil if the node does not exist', function()
				assert_nil(grid:getNodeAt(0,0))
				assert_nil(grid:getNodeAt(5,1))
			end)

			test('returns nil if one of its args is missing', function()
				assert_nil(grid:getNodeAt(0))
				assert_nil(grid:getNodeAt())
			end)			
		
	end)
		
	context('Grid:getNodes()', function()
	
		test('returns the array of nodes', function()
			local map = {{0,0},{0,0}}
			local grid = Grid(map)
			local nodes = grid:getNodes()
			
			assert_equal(type(nodes), 'table')	
			for y in pairs(nodes) do
				for x in pairs(nodes[y]) do
					assert_equal(getmetatable(nodes[y][x]),Node)
				end
			end 
		end)
	
	end)
	
	context('grid:getNeighbours()', function()
		
			test('returns neighbours of a given node', function()
				local map = {{0,0},{0,0},}
				local grid = Grid(map)
				local walkable = 0
				local node = grid:getNodeAt(1,1)
				local nb = grid:getNeighbours(node, walkable)
				
				assert_equal(type(nb), 'table')
				assert_equal(#nb, 2)
				assert_equal(nb[1], grid:getNodeAt(2,1))
				assert_equal(nb[2], grid:getNodeAt(1,2))
			end)
			
			test('passing a true as a third arg includes ajacent nodes', function()
				local map = {{0,0},{0,0},}
				local grid = Grid(map)
				local walkable, allowDiag = 0, true
				
				local node = grid:getNodeAt(1,1)
				local nb = grid:getNeighbours(node, walkable, allowDiag)
				
				assert_equal(type(nb), 'table')
				assert_equal(#nb, 3)
				assert_equal(nb[1], grid:getNodeAt(2,1))
				assert_equal(nb[2], grid:getNodeAt(1,2))
				assert_equal(nb[3], grid:getNodeAt(2,2))
			end)		
			
	end)
		
	context('Grid:iter()', function()
			
			test('iterates on all nodes in a grid', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				for n in grid:iter() do
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n.y] and map[n.y][n.x])
					assert_nil(record[n])
					record[n] = true
				end
			end)
			
			test('can iterate only on a rectangle of nodes', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				for n in grid:iter(2,2,3,3) do
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n.y] and map[n.y][n.x])					
					assert_gte(n.x, 2)
					assert_gte(n.y, 2)
					assert_lte(n.x, 3)
					assert_lte(n.y, 3)
					assert_nil(record[n])
					record[n] = true
				end
			end)			
		
	end)
		
	context('Grid:each()', function()
			
			test('calls a given function on each node in a grid', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				local function f(node,i) node.value = i end
				grid:each(f, 3)
				for n in grid:iter() do
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n.y] and map[n.y][n.x])
					assert_equal(n.value,3)
					assert_nil(record[n])
					record[n] = true
				end
			end)
		
	end)
		
	context('Grid:eachRange()', function()
			
			test('calls a given function on each node in a range', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				local function f(node,i) node.value = i end
				grid:eachRange(1,1,2,2,f,3)
				for n in grid:iter() do
					if n.x <= 2 and n.y <= 2 then
						assert_equal(n.value,3)
					else
						assert_nil(n.value)
					end
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n.y] and map[n.y][n.x])
					assert_nil(record[n])
					record[n] = true
				end
			end)
		
	end)		
		
	context('Grid:imap()', function()
			
			test('Maps a given function on each node in a grid', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}
				local function f(node,i) 
					node.v = i
					return node
				end
				grid:imap(f, 5)
				for n in grid:iter() do
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n.y] and map[n.y][n.x])
					assert_equal(n.v,5)
					assert_nil(record[n])
					record[n] = true
				end
			end)
		
	end)

	context('Grid:imapRange()', function()
			
			test('calls a given function on each node in a range', function()
				local map = {
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
					{0,0,0,0},
				}
				local grid = Grid(map)
				local record = {}				
				local function f(node,i) 
					node.v = i
					return node
				end
				grid:imapRange(3,3,4,4,f,7)
				for n in grid:iter() do
					if n.x >= 3 and n.y >= 3 then
						assert_equal(n.v,7)
					else
						assert_nil(n.v)
					end
					assert_equal(getmetatable(n), Node)
					assert_not_nil(map[n.y] and map[n.y][n.x])
					assert_nil(record[n])
					record[n] = true
				end
			end)
		
	end)		
		
end)context('Module Heuristics', function()
	local H
	
	before(function()
		H = require ('jumper.core.heuristics')
  end)
	
  context('MANHATTAN distance', function()
	
    test('is a function',function()
			assert_type(H.MANHATTAN, 'function')
    end)
	
		test('evaluates as |dx|+|dy|', function()
			assert_equal(H.MANHATTAN(0,0), 0)
			assert_equal(H.MANHATTAN(1,1), 2)
			assert_equal(H.MANHATTAN(-1,-2), 3)
			assert_equal(H.MANHATTAN(10,-2), 12)
			assert_equal(H.MANHATTAN(-5,8), 13)		
		end)
		
		test('calling the function with one arg raises an error', function()
			assert_error(pcall(H.MANHATTAN,1))	
		end)	
		
		test('calling the function with no args raises an error', function()
			assert_error(pcall(H.MANHATTAN))
		end)		
		
  end)

  context('EUCLIDIAN distance', function()
	
    test('is a function',function()
			assert_type(H.EUCLIDIAN, 'function')
    end)
	
		test('evaluates as SQUAREROOT(dx*dx + dy*dy)', function()
			assert_equal(H.EUCLIDIAN(0,0), 0)
			assert_equal(H.EUCLIDIAN(2,2), math.sqrt(8))
			assert_equal(H.EUCLIDIAN(-1,-2), math.sqrt(5))
			assert_equal(H.EUCLIDIAN(-3,1), math.sqrt(10))
			assert_equal(H.EUCLIDIAN(-5,3), math.sqrt(34))		
		end)
		
		test('calling the function with one arg raises an error', function()
			assert_error(pcall(H.EUCLIDIAN,1))	
		end)	
		
		test('calling the function with no args raises an error', function()
			assert_error(pcall(H.EUCLIDIAN))
		end)		
		
  end)
  
	context('DIAGONAL distance', function()
	
    test('is a function',function()
			assert_type(H.DIAGONAL, 'function')
    end)
	
		test('evaluates as MAX(|dx|+|dy|)', function()
			assert_equal(H.DIAGONAL(0,0), 0)
			assert_equal(H.DIAGONAL(2,2), 2)
			assert_equal(H.DIAGONAL(-1,-2), 2)
			assert_equal(H.DIAGONAL(-3,1), 3)
			assert_equal(H.DIAGONAL(-5,3), 5)		
		end)
		
		test('calling the function with one arg raises an error', function()
			assert_error(pcall(H.DIAGONAL,1))	
		end)	
		
		test('calling the function with no args raises an error', function()
			assert_error(pcall(H.DIAGONAL))
		end)		
		
  end)

	context('CARDINTCARD distance', function()
	
    test('is a function',function()
			assert_type(H.CARDINTCARD, 'function')
    end)
		
		test('evaluates as (SQRT(2)-1)*MIN(|dx|+|dy|)+MAX(|dx|+|dy|)', function()
			assert_equal(H.CARDINTCARD(0,0), 0)
			assert_less_than(H.CARDINTCARD(1,1)-(math.sqrt(2)),1e-6)
			assert_less_than(H.CARDINTCARD(-1,-2)-(1+math.sqrt(2)),1e-6)
			assert_less_than(H.CARDINTCARD(-3,1)-(2+math.sqrt(2)),1e-6)
			assert_less_than(H.CARDINTCARD(2,2)-(2*math.sqrt(2)),1e-6)
		end)
		
		test('calling the function with one arg raises an error', function()
			assert_error(pcall(H.CARDINTCARD,1))	
		end)	
		
		test('calling the function with no args raises an error', function()
			assert_error(pcall(H.CARDINTCARD))
		end)		
		
  end)
	
end)context('Module Node', function()
	local Node
	
	before(function()
		Node = require ('jumper.core.node')
  end)
	
  context('The Node Class', function()
	
    test('Node:new() or Node() returns a Node object',function()
			assert_equal(getmetatable(Node:new(0,0)),Node)
			assert_equal(getmetatable(Node(0,0)),Node)
    end)
	
		test('A Node has x and y attributes', function()
			local node = Node:new(1,3)
			assert_equal(node.x, 1)
			assert_equal(node.y, 3)
		end)
		
		test('Nodes can be compared, if they both have an F-cost', function()
		  local nodeA, nodeB = Node(1,2), Node(1,2)
			nodeA.f, nodeB.f = 1, 2
			assert_less_than(nodeA, nodeB)
			
			nodeA.f = 3
			assert_less_than(nodeB, nodeA)
		end)	
		
  end)

end)context('Module Pathfinder', function()
	local PF, H, Grid, Path, map, grid
	
	before(function()
		PF = require ('jumper.pathfinder')
		Grid = require ('jumper.grid')
		H = require ('jumper.core.heuristics')
		Path = require ('jumper.core.path')
		map = {{0,0,0},{0,0,0},{0,0,0}}
		grid = Grid(map)
  end)
	
  context('Pathfinder:new() or Pathfinder()', function()
		
		test('Inits a new Pathfinder object', function()
			assert_equal(getmetatable(PF(grid, 'ASTAR')), PF)
			assert_equal(getmetatable(PF:new(grid, 'ASTAR')), PF)
		end)
		
		test('First arg is a grid object', function()
			assert_error(pcall(PF, PF))
			assert_error(pcall(PF, PF, map))
			assert_equal(getmetatable(PF(grid)), PF)
		end)
		
		test('Second arg, when given must be a valid finderName', function()
			assert_error(pcall(PF, PF, grid, 'finder'))
			for i, finder in ipairs(PF:getFinders()) do
				assert_equal(getmetatable(PF(grid, finder)), PF)
			end
		end)
		
		test('Defaults to \'ASTAR\' when not given', function()
			local pf = PF(grid)
			assert_equal(getmetatable(pf), PF)
			assert_equal(pf:getFinder(), 'ASTAR')
		end)
		
		test('Third arg walkable can be a string, function, int or nil', function()
			assert_equal(getmetatable(PF(grid, 'ASTAR', 'A')), PF)
			assert_equal(getmetatable(PF(grid, 'ASTAR', function() end)), PF)
			assert_equal(getmetatable(PF(grid, 'ASTAR', 1)), PF)
			assert_equal(getmetatable(PF(grid, 'ASTAR', nil)), PF)
			assert_error(pcall(PF, PF, grid, 'ASTAR', 2.2))
			assert_error(pcall(PF, PF, grid, 'ASTAR', {}))
		end)
		
	end)
	
	context('Pathfinder:getGrid()', function()
		
		test('returns the grid object used by the Pathfinder', function()
			local pf = PF(grid)
			assert_equal(pf:getGrid(), grid)
		end)
		
	end)
	
	context('Pathfinder:setGrid()', function()
	
		test('Sets the grid object on which the Pathfinder performs', function()
			local pf = PF(grid)
			local newGrid = Grid('00000\n00000')
			
			assert_equal(pf:getGrid(), grid)
			pf:setGrid(newGrid)
			assert_equal(pf:getGrid(), newGrid)
		end)
		
		test('passing nil raises an error', function()
			local pf = PF(grid)
			assert_error(pcall(pf.setGrid, pf, nil))
		end)
		
	end)
	
	context('Pathfinder:getWalkable()', function()
	
		test('returns the walkable parameter', function()
			local pf = PF(grid, 'ASTAR', 1)
			assert_equal(pf:getWalkable(), 1)
		end)
		
		test('is nil when not given', function()
			local pf = PF(grid)
			assert_nil(pf:getWalkable())		
		end)
		
	end)
	
	context('Pathfinder:setWalkable()', function()
	
		test('sets the string, function, nil or int walkable value', function()
			local pf = PF(grid, 'ASTAR')
			assert_nil(pf:getWalkable())
			
			pf:setWalkable('A')
			assert_equal(pf:getWalkable(), 'A')
			
			pf:setWalkable(2)
			assert_equal(pf:getWalkable(), 2)
			
			local f = function() end
			pf:setWalkable(f)
			assert_equal(pf:getWalkable(), f)
		end)
		
		test('is nil when not given', function()
			local pf = PF(grid)
			assert_nil(pf:getWalkable())		
		end)
		
		test('raises an error when passed-in value is not a string, int, nil or function', function()
			local pf = PF(grid)			
			assert_error(pcall(pf.setWalkable, pf, {}))
			assert_error(pcall(pf.setWalkable, pf, 0.4))
		end)
		
	end)	
	
	context('Pathfinder:getFinder()', function()
		
		test('returns the finder name used', function()
			local pf = PF(grid, 'JPS')
			assert_equal(pf:getFinder(), 'JPS')
		end)
		
	end)
	
	context('Pathfinder:setFinder()', function()

		test('sets the finder to be used', function()
			local pf = PF(grid)
			pf:setFinder('DFS')
			assert_equal(pf:getFinder(), 'DFS')
		end)
		
		test('Upon init, the default finder, when not given, is \'ASTAR\'', function()
			local pf = PF(grid)
			assert_equal(pf:getFinder(), 'ASTAR')
		end)

		test('Passing nil sets \'ASTAR\` as the finder if no previous finder was set, is \'ASTAR\'', function()
			local pf = PF(grid)
			pf:setFinder()
			assert_equal(pf:getFinder(), 'ASTAR')
		end)
		
		test('Passing nil has no effect if a finder was set previously', function()
			local pf = PF(grid, 'JPS')
			pf:setFinder()
			assert_equal(pf:getFinder(), 'JPS')
		end)			
	
	end)
	
	context('Pathfinder:getFinders()', function()
		
		test('returns the list of all existing finders', function()
			local fs = PF:getFinders()
			local pf = PF(grid)
			
			assert_greater_than(#fs, 0)
			for i,finder in ipairs(fs) do
				pf:setFinder(finder)
				assert_equal(pf:getFinder(), finder)
			end
		end)
		
	end)
	
	context('Pathfinder:getHeuristic()', function()
		
		test('returns the heuristic function used', function()
			local pf = PF(grid)
			assert_not_nil(pf:getHeuristic())
		end)
		
		test('default heuristic is \'MANHATTAN\'', function()
			local pf = PF(grid)
			assert_equal(pf:getHeuristic(), H.MANHATTAN)
		end)
		
	end)
	
	context('Pathfinder:setHeuristic()', function()
		
		test('sets the heuristic function to be used', function()
			local pf = PF(grid)
			pf:setHeuristic('MANHATTAN')
			assert_equal(pf:getHeuristic(), H.MANHATTAN)
		end)
		
		test('handles custom heuristic functions', function()
			local pf = PF(grid)
			local f = function() end
			pf:setHeuristic(f)
			assert_equal(pf:getHeuristic(),f)
		end)
		
		test('passing nil produces an error',function()
			local pf = PF(grid)
			assert_error(pcall(pf.setHeuristic, pf))
		end)
		
	end)

	context('Pathfinder:getHeuristics()', function()
		
		test('returns all available heuristics', function()
			local hs = PF:getHeuristics()
			assert_greater_than(#hs, 0)
			local pf = PF(grid)
			for i, heur in ipairs(hs) do
				pf:setHeuristic(heur)
				assert_equal(pf:getHeuristic(), H[heur])
			end
		end)
		
	end)
	
	context('Pathfinder:getMode()', function()
	
		test('returns the actual search mode', function()
			local pf = PF(grid)
			pf:setMode('DIAGONAL')
			assert_equal(pf:getMode(),'DIAGONAL')
		end)

		test('default search mode is  \'DIAGONAL\'', function()
			local pf = PF(grid)
			assert_equal(pf:getMode(),'DIAGONAL')
		end)
		
	end)
	
	context('Pathfinder:setMode()', function()
		
		test('sets the search mode', function()
			local pf = PF(grid)		
			pf:setMode('ORTHOGONAL')
			assert_equal(pf:getMode(), 'ORTHOGONAL')
			pf:setMode('DIAGONAL')
			assert_equal(pf:getMode(), 'DIAGONAL')	
		end)
		
		test('passing nil or any other invalid arg causes an error', function()
			local pf = PF(grid)		
			
			assert_error(pcall(pf.setMode, pf))		
			assert_error(pcall(pf.setMode, pf, 'ORTHO'))		
			assert_error(pcall(pf.setMode, pf, function() end))	
		end)
		
	end)
	
	context('Pathfinder:getModes()', function()
		
		test('returns all available modes', function()
			local ms = PF:getModes()
			assert_equal(#ms, 2)
			local pf = PF(grid)
			
			for i, mode in ipairs(ms) do
				pf:setMode(mode)
				assert_equal(pf:getMode(),mode)
			end
		end)
		
	end)
	
	context('Pathfinder:version()', function()
		
		test('returns version and release date or empty strings', function()
			local vr, rd = PF:version()
			assert_equal(type(vr), 'string')
			assert_not_nil(vr:match('%d+%.%d+%.%d+') or vr == '')
			assert_equal(type(rd), 'string')
			assert_not_nil(rd:match('%d+/%d+/%d+') or rd == '')
		end)
		
	end)
	
	context('Pathfinder:getPath()', function()
		
		test('returns a path', function()
			local pf = PF(grid, 'ASTAR', 0)
			local path = pf:getPath(1,1,3,3)
			assert_equal(getmetatable(path), Path)
		end)
		
		test('start and end locations must exist on the map', function()
			local pf = PF(grid, 'ASTAR', 0)
			assert_error(pcall(pf.getPath, pf, 0,0, 3, 3))
			assert_error(pcall(pf.getPath, pf, 1, 1, 4, 4))
			assert_error(pcall(pf.getPath, pf, 0,0, 4, 4))
		end)
		
		test('goal location must be walkable', function()
			local pf = PF(grid, 'ASTAR', 0)
			map[3][3] = 1
			assert_error(pcall(pf.getPath, pf, 0,0, 3, 3))
		end)
		
		test('returns also the path length', function()
			local pf = PF(grid, 'ASTAR', 0)
			local path, len = pf:getPath(1,1,3,3)
			assert_equal(type(len), 'number')
			assert_gte(len, 0)
		end)
		
	end)	
	
end)context('Module Path', function()
	local Path, Node
	
	before(function()
		Path = require ('jumper.core.path')
		Node = require ('jumper.core.node')
  end)
	
  context('The Path Class', function()
	
    test('Path:new() or Path() returns a Path object',function()
			assert_equal(getmetatable(Path:new()),Path)
			assert_equal(getmetatable(Path()),Path)
    end)
		
    test('Path:iter() iterates on nodes forming the path',function()
			local p = Path()
			for i = 1,10 do p[#p+1] = Node(i,i) end
			
			local i = 0
			for node, count in p:iter() do
				i = i+1
				assert_equal(getmetatable(node), Node)
				assert_equal(node.x, i)
				assert_equal(node.y, i)
				assert_equal(count, i)
			end
    end)		
		
		test('Path:iter() is aliased as Path:nodes()',function()
			assert_equal(Path.iter, Path.nodes)
		end)
		
		test('Path:getLength() returns the length of the path', function()
			local p = Path()
			for i = 1,10 do p[#p+1] = Node(i,0) end
			assert_equal(p:getLength(),9)
			
			p = Path()
			for j = 1,10 do p[#p+1] = Node(0,j) end
			assert_equal(p:getLength(),9)

			p = Path()
			for i = 1,10 do p[#p+1] = Node(i,i) end
			assert_less_than(p:getLength()-9*math.sqrt(2),1e-6)			
		end)
		
		test('Path:fill() interpolates a path', function()
			local p = Path()
			for i = 1,9,2 do p[#p+1] = Node(i,i) end
			p.grid = {getNodeAt = function(self,x,y) return {x = x, y = y} end}
			p:fill()
			
			local i = 0
			for node, count in p:iter() do
				i = i+1
				assert_equal(node.x, i)
				assert_equal(node.y, i)
				assert_equal(count, i)
			end			
			
		end)
		
		test('Interpolation does not affect the total path length', function()
			local p = Path()
			for i = 1,10,3 do p[#p+1] = Node(i,i) end
			local len = p:getLength()
			p.grid = {getNodeAt = function(self,x,y) return {x = x, y = y} end}			
			p:fill()
			
			assert_less_than(p:getLength()-len,1e-6)			
		end)		

		test('Path:filter() compresses a path', function()
			local p = Path()
			for i = 1,10 do p[#p+1] = Node(i,i) end
			p:filter()
			
			assert_equal(p[1].x,1)
			assert_equal(p[1].y,1)
			assert_equal(p[2].x,10)
			assert_equal(p[2].y,10)
			for i = 3,10 do
				assert_nil(p[i])
			end
			
		end)

		test('Compression does not affect the total path length', function()
			local p = Path()
			for i = 1,10 do p[#p+1] = Node(i,i) end
			local len = p:getLength()
			p:fill()
			
			assert_less_than(p:getLength()-len,1e-6)			
		end)		
		
  end)

end)VARIABLES SECTION.

new
variable.name = test
variable.value = guy
add

new
variable.name = test2
add

END VARIABLES.



EVENTS SECTION.

new event as always
	event.name = test4
	event.logic = keydown down
	event.actions = move guy 0,3
add

new event as playeraction (guy2 talkTo guy3)
	event.name = test4
	event.actions = start chat hasItem
add

new event as always
	event.name = test
	
	event.logic = keydown right
	event.actions = move guy 3,0 
add
	
new event as always
	event.name = test
	event.logic = keydown left
	event.actions = move guy -3,0 
add

new event as always
	event.name = test
	event.logic = keydown up
	event.actions = move guy 0,-3 
add

END EVENTS.

ENTITIES SECTION.
new entity
	entity.name = guy
	entity.drawType = lovedraw
	entity.cells = 1,1,2,1,5,1,.10
	entity.zCalc = true
	entity.xy = 0,0
	entity.visible = true
	entity.boxes + 0,0,200,200,collision

add entity

new entity
	entity.name = guy2
	entity.drawType = lovedraw
	entity.cells = 1,1,2,1,5,1,.10
	entity.zCalc = true
	entity.xy = 500,0
	entity.visible = true
	entity.boxes + 0,0,30,30,collision

add entity


new entity
	entity.name = guy3
	entity.drawType = lovedraw
	entity.cells = 1,1,2,1,5,1,.10
	entity.zCalc = true
	entity.xy = 100,200
	entity.visible = true
	entity.boxes + 0,0,30,30,collision
	entity.actor = true
add entity

new entity
	entity.name = guy4
	entity.drawType = lovedraw
	entity.cells = 1,1,2,1,5,1,.10
	entity.zCalc = true
	entity.xy = 400,400
	entity.visible = true
	entity.boxes + 0,0,200,30,collision
add entity

END ENTITIES.


PLAYER ACTION BUTTONS SECTION.

new button
	button.name = talk
	button.action = talkTo
	button.boxes + -40,-40,40,40
	button.drawType = lovedraw
	button.visible = true
	button.text = talk
add button

new button
	button.name = push
	button.action = push
	button.boxes + 0,0,40,40
	button.drawType = lovedraw
	button.visible = true
	button.text = push
add button

new button
	button.name = pull
	button.action = pull
	button.boxes + -40,0,40,40
	button.drawType = lovedraw
	button.visible = true
	button.text = pull
add button

END PLAYER ACTION BUTTONS.


CHAT SECTION.

new chatnode
chatnode.id = 1
chatnode.text = action would use this node to start a chat
add chatnode

new chatnode
chatnode.id = 1_1
chatnode.text = after chat system takes over, this will be the first option for chat id 1
add chatnode

new chatnode
chatnode.id = 1_1_1
chatnode.text = after 1_1 is selected on chat 1, this will be chat option 1 for chatnode 1_1.

new chatnode
chatnode.id = 1_2
chatnode.text = this will be the second option for chat 1.

--- 
  chatnode ids can be as long as the conversation needs to be, don't have to be in order.
  


END CHAT.


BACK UP EVENTS.
new event as playerAction(entity1 get entity2)
	event.name = test 
	event.resetAfterRun = true
	event.actions = start chat hasItem
	event.logic = guy has item
	event.falseactions = start chat noItem
add event test

new event as onClick
	event.name = test 
	event.resetAfterRun = true
	event.logic = pointing at guy2 and guy has item
	event.actions = start chat hasItem
	event.falseactions = start chat noItem
add event test

new event as onClick
	event.name = test 
	event.resetAfterRun = true
	event.logic = pointing at *
	event.actions = set test pointingAt|name
add event test

new event as onClick
	event.name = test2
	event.resetAfterRun = true
	event.logic = pointing at nothing
	event.actions = set test2 mousePos 
	event.falseactions = addInv item guy
add timer test
new event as onClick
	event.name = test2
	event.resetAfterRun = true
	event.logic = pointing at nothing and keydown up
	event.actions = set test2 mousePos then moveTo variable|test 300,300 / moveTo variable|test 100,500 / moveTo variable|test 20,205 / moveTo variable|test variable|test2
	event.falseactions = set test2 mousePos then moveTo variable|test variable|test2
add timer test

new event as chataction
	event.name = test3
	event.resetAfterRun = true
	event.actions = move variable|test 100,10
	
add timer test

